/* IRM.h
   Generated by wsdl2h 1.2.16 from http://ium-vbox-win2k8:16100/irm_sealing/sealing_services?wsdl http://ium-vbox-win2k8:16100/irm_services/document_right_operations?wsdl and typemap.dat
   2011-09-30 15:00:56 GMT

   DO NOT INCLUDE THIS FILE DIRECTLY INTO YOUR PROJECT BUILDS
   USE THE soapcpp2-GENERATED SOURCE CODE FILES FOR YOUR PROJECT BUILDS

   gSOAP XML Web services tools.
   Copyright (C) 2001-2010 Robert van Engelen, Genivia Inc. All Rights Reserved.
   Part of this software is released under one of the following licenses:
   GPL or Genivia's license for commercial use.
*/

/** @page page_notes Build Notes

NOTE:

 - Run soapcpp2 on IRM.h to generate the SOAP/XML processing logic.
   Use soapcpp2 option -I to specify paths for #import
   To build with STL, 'stlvector.h' is imported from 'import' dir in package.
   Use soapcpp2 option -i to generate improved proxy and server classes.
 - Use wsdl2h options -c and -s to generate pure C code or C++ code without STL.
 - Use 'typemap.dat' to control namespace bindings and type mappings.
   It is strongly recommended to customize the names of the namespace prefixes
   generated by wsdl2h. To do so, modify the prefix bindings in the Namespaces
   section below and add the modified lines to 'typemap.dat' to rerun wsdl2h.
 - Use Doxygen (www.doxygen.org) on this file to generate documentation.
 - Use wsdl2h options -nname and -Nname to globally rename the prefix 'ns'.
 - Use wsdl2h option -d to enable DOM support for xsd:anyType.
 - Use wsdl2h option -g to auto-generate readers and writers for root elements.
 - Struct/class members serialized as XML attributes are annotated with a '@'.
 - Struct/class members that have a special role are annotated with a '$'.

WARNING:

   DO NOT INCLUDE THIS FILE DIRECTLY INTO YOUR PROJECT BUILDS.
   USE THE SOURCE CODE FILES GENERATED BY soapcpp2 FOR YOUR PROJECT BUILDS:
   THE soapStub.h FILE CONTAINS THIS CONTENT WITHOUT ANNOTATIONS.

LICENSE:

@verbatim
--------------------------------------------------------------------------------
gSOAP XML Web services tools
Copyright (C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.

This software is released under one of the following two licenses:
1) GPL or 2) Genivia's license for commercial use.
--------------------------------------------------------------------------------
1) GPL license.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

Author contact information:
engelen@genivia.com / engelen@acm.org
--------------------------------------------------------------------------------
2) A commercial-use license is available from Genivia, Inc., contact@genivia.com
--------------------------------------------------------------------------------
@endverbatim

*/


//gsoapopt w

/******************************************************************************\
 *                                                                            *
 * Definitions                                                                *
 *                                                                            *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Import                                                                     *
 *                                                                            *
\******************************************************************************/


// STL vector containers (use option -s to remove STL dependency)
#import "stlvector.h"

/******************************************************************************\
 *                                                                            *
 * Schema Namespaces                                                          *
 *                                                                            *
\******************************************************************************/


/* NOTE:

It is strongly recommended to customize the names of the namespace prefixes
generated by wsdl2h. To do so, modify the prefix bindings below and add the
modified lines to typemap.dat to rerun wsdl2h:

ns1 = "http://xmlns.oracle.com/irm/core"
ns2 = "http://xmlns.oracle.com/irm/content"
ns3 = "http://xmlns.oracle.com/irm/system"
ns4 = "http://xmlns.oracle.com/irm/content/wsdl"
ns5 = "http://xmlns.oracle.com/irm/classifications"
ns6 = "http://xmlns.oracle.com/irm/rights"
ns7 = "http://xmlns.oracle.com/irm/rights/wsdl"

*/

#define SOAP_NAMESPACE_OF_ns1	"http://xmlns.oracle.com/irm/core"
//gsoap ns1   schema namespace:	http://xmlns.oracle.com/irm/core
//gsoap ns1   schema form:	unqualified

#define SOAP_NAMESPACE_OF_ns2	"http://xmlns.oracle.com/irm/content"
//gsoap ns2   schema namespace:	http://xmlns.oracle.com/irm/content
//gsoap ns2   schema form:	unqualified

#define SOAP_NAMESPACE_OF_ns3	"http://xmlns.oracle.com/irm/system"
//gsoap ns3   schema namespace:	http://xmlns.oracle.com/irm/system
//gsoap ns3   schema form:	unqualified

#define SOAP_NAMESPACE_OF_ns4	"http://xmlns.oracle.com/irm/content/wsdl"
//gsoap ns4   schema namespace:	http://xmlns.oracle.com/irm/content/wsdl
//gsoap ns4   schema form:	unqualified

#define SOAP_NAMESPACE_OF_ns5	"http://xmlns.oracle.com/irm/classifications"
//gsoap ns5   schema namespace:	http://xmlns.oracle.com/irm/classifications
//gsoap ns5   schema form:	unqualified

#define SOAP_NAMESPACE_OF_ns6	"http://xmlns.oracle.com/irm/rights"
//gsoap ns6   schema namespace:	http://xmlns.oracle.com/irm/rights
//gsoap ns6   schema form:	unqualified

#define SOAP_NAMESPACE_OF_ns7	"http://xmlns.oracle.com/irm/rights/wsdl"
//gsoap ns7   schema namespace:	http://xmlns.oracle.com/irm/rights/wsdl
//gsoap ns7   schema form:	unqualified

/******************************************************************************\
 *                                                                            *
 * Built-in Schema Types and Top-Level Elements and Attributes                *
 *                                                                            *
\******************************************************************************/


/// Built-in type "xs:QName".
typedef std::string xsd__QName;

/// Primitive built-in type "xs:anyURI"
typedef std::string xsd__anyURI;

/// Built-in type "xs:base64Binary".
class xsd__base64Binary
{	unsigned char *__ptr;
	int __size;
	char *id, *type, *options; // NOTE: for DIME and MTOM XOP attachments only
	struct soap *soap;
};

/******************************************************************************\
 *                                                                            *
 * Forward Declarations                                                       *
 *                                                                            *
\******************************************************************************/



//  Forward declaration of class ns1__ClassificationSystem.
class ns1__ClassificationSystem;

//  Forward declaration of class ns1__ClassificationSystemRef.
class ns1__ClassificationSystemRef;

//  Forward declaration of class ns1__DesktopKeySetExtensions.
class ns1__DesktopKeySetExtensions;

//  Forward declaration of class ns1__Label.
class ns1__Label;

//  Forward declaration of class ns1__Classification.
class ns1__Classification;

//  Forward declaration of class ns1__LicenseCriteria.
class ns1__LicenseCriteria;

//  Forward declaration of class ns1__Feature.
class ns1__Feature;

//  Forward declaration of class ns1__TimeSpan.
class ns1__TimeSpan;

//  Forward declaration of class ns1__TimePeriod.
class ns1__TimePeriod;

//  Forward declaration of class ns1__ClassificationFilter.
class ns1__ClassificationFilter;

//  Forward declaration of class ns1__RelativeTimeSpan.
class ns1__RelativeTimeSpan;

//  Forward declaration of class ns1__AbsoluteTimeSpan.
class ns1__AbsoluteTimeSpan;

//  Forward declaration of class ns1__XPathClassificationFilter.
class ns1__XPathClassificationFilter;

//  Forward declaration of class ns1__XPathExpression.
class ns1__XPathExpression;

//  Forward declaration of class ns1__Account.
class ns1__Account;

//  Forward declaration of class ns1__AccountRef.
class ns1__AccountRef;

//  Forward declaration of class ns1__PageRange.
class ns1__PageRange;

//  Forward declaration of class ns2__CryptoSchema.
class ns2__CryptoSchema;

//  Forward declaration of class ns2__CryptoSchemaRef.
class ns2__CryptoSchemaRef;

//  Forward declaration of class ns2__RawKeySetExtensions.
class ns2__RawKeySetExtensions;

//  Forward declaration of class ns2__WrappedKeySetExtensions.
class ns2__WrappedKeySetExtensions;

//  Forward declaration of class ns2__KeySetExtensions.
class ns2__KeySetExtensions;

//  Forward declaration of class ns2__KeySet.
class ns2__KeySet;

//  Forward declaration of class ns2__KeySetRef.
class ns2__KeySetRef;

//  Forward declaration of class ns2__CustomData.
class ns2__CustomData;

//  Forward declaration of class ns2__SchemaVersion.
class ns2__SchemaVersion;

//  Forward declaration of class ns2__ContentSchema.
class ns2__ContentSchema;

//  Forward declaration of class ns2__EncryptionOptions.
class ns2__EncryptionOptions;

//  Forward declaration of class ns2__SealingOptions.
class ns2__SealingOptions;

//  Forward declaration of class ns2__ContentDescription.
class ns2__ContentDescription;

//  Forward declaration of class ns2__UnsupportedContentTypeFault.
class ns2__UnsupportedContentTypeFault;

//  Forward declaration of class ns2__IllegalEncryptedContentBlockSizeFault.
class ns2__IllegalEncryptedContentBlockSizeFault;

//  Forward declaration of class ns2__PublicHeaderLengthFault.
class ns2__PublicHeaderLengthFault;

//  Forward declaration of class ns2__ContentParseFault.
class ns2__ContentParseFault;

//  Forward declaration of class ns3__AuthorizationDeniedFault.
class ns3__AuthorizationDeniedFault;

//  Forward declaration of class _ns4__Seal.
class _ns4__Seal;

//  Forward declaration of class _ns4__SealResponse.
class _ns4__SealResponse;

//  Forward declaration of class _ns4__Unseal.
class _ns4__Unseal;

//  Forward declaration of class _ns4__UnsealResponse.
class _ns4__UnsealResponse;

//  Forward declaration of class _ns4__Reseal.
class _ns4__Reseal;

//  Forward declaration of class _ns4__ResealResponse.
class _ns4__ResealResponse;

//  Forward declaration of class _ns4__Reclassify.
class _ns4__Reclassify;

//  Forward declaration of class _ns4__ReclassifyResponse.
class _ns4__ReclassifyResponse;

//  Forward declaration of class _ns4__Peek.
class _ns4__Peek;

//  Forward declaration of class _ns4__PeekResponse.
class _ns4__PeekResponse;

//  Forward declaration of class _ns4__ValidatedPeek.
class _ns4__ValidatedPeek;

//  Forward declaration of class _ns4__ValidatedPeekResponse.
class _ns4__ValidatedPeekResponse;

//  Forward declaration of class ns5__ItemCode.
class ns5__ItemCode;

//  Forward declaration of class ns5__Context.
class ns5__Context;

//  Forward declaration of class ns5__ContextRef.
class ns5__ContextRef;

//  Forward declaration of class ns5__ItemConstraints.
class ns5__ItemConstraints;

//  Forward declaration of class ns5__UnknownContextFault.
class ns5__UnknownContextFault;

//  Forward declaration of class ns6__ContextInstance.
class ns6__ContextInstance;

//  Forward declaration of class ns6__ContextInstanceRef.
class ns6__ContextInstanceRef;

//  Forward declaration of class ns6__ContextTemplate.
class ns6__ContextTemplate;

//  Forward declaration of class ns6__ContextTemplateRef.
class ns6__ContextTemplateRef;

//  Forward declaration of class ns6__DocumentRole.
class ns6__DocumentRole;

//  Forward declaration of class ns6__DocumentRoleRef.
class ns6__DocumentRoleRef;

//  Forward declaration of class ns6__Domain.
class ns6__Domain;

//  Forward declaration of class ns6__DomainRef.
class ns6__DomainRef;

//  Forward declaration of class ns6__DocumentRight.
class ns6__DocumentRight;

//  Forward declaration of class ns6__DocumentRightRef.
class ns6__DocumentRightRef;

//  Forward declaration of class ns6__AccountAlreadyAssignedFault.
class ns6__AccountAlreadyAssignedFault;

//  Forward declaration of class ns6__UnsupportedDocumentRoleFault.
class ns6__UnsupportedDocumentRoleFault;

//  Forward declaration of class ns6__UnknownDocumentRoleFault.
class ns6__UnknownDocumentRoleFault;

//  Forward declaration of class ns6__UnknownDocumentRightFault.
class ns6__UnknownDocumentRightFault;

//  Forward declaration of class _ns7__AssignRole.
class _ns7__AssignRole;

//  Forward declaration of class _ns7__AssignRoleResponse.
class _ns7__AssignRoleResponse;

//  Forward declaration of class _ns7__ReassignRole.
class _ns7__ReassignRole;

//  Forward declaration of class _ns7__ReassignRoleResponse.
class _ns7__ReassignRoleResponse;

//  Forward declaration of class _ns7__CheckInRightsForAccount.
class _ns7__CheckInRightsForAccount;

//  Forward declaration of class _ns7__CheckInRightsForAccountResponse.
class _ns7__CheckInRightsForAccountResponse;

//  Forward declaration of class _ns7__SaveChangesToItems.
class _ns7__SaveChangesToItems;

//  Forward declaration of class _ns7__SaveChangesToItemsResponse.
class _ns7__SaveChangesToItemsResponse;

//  Forward declaration of class _ns7__UnassignRights.
class _ns7__UnassignRights;

//  Forward declaration of class _ns7__UnassignRightsResponse.
class _ns7__UnassignRightsResponse;

//  Forward declaration of class _ns7__ListRightsByContext.
class _ns7__ListRightsByContext;

//  Forward declaration of class _ns7__ListRightsByContextResponse.
class _ns7__ListRightsByContextResponse;

//  Forward declaration of class _ns7__ListRightsByAccount.
class _ns7__ListRightsByAccount;

//  Forward declaration of class _ns7__ListRightsByAccountResponse.
class _ns7__ListRightsByAccountResponse;

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/core                                         *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/content                                      *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/system                                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/content/wsdl                                 *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/classifications                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/rights                                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/rights/wsdl                                  *
 *                                                                            *
\******************************************************************************/


/// "http://xmlns.oracle.com/irm/core":LicenseCriteria_Storage is a simpleType restriction of xs:string.
/// @brief How a license is stored on a device.
/// Note: enum values are prefixed with 'ns1__LicenseCriteria_USCOREStorage' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns1__LicenseCriteria_USCOREStorage
{
/// @brief License can be stored on disk or memory.
	ns1__LicenseCriteria_USCOREStorage__PERSISTENT,	///< xs:string value="PERSISTENT"
/// @brief License can only be stored in memory.
	ns1__LicenseCriteria_USCOREStorage__TRANSIENT,	///< xs:string value="TRANSIENT"
/// @brief License can be stored in either memory or on disk.
	ns1__LicenseCriteria_USCOREStorage__ANY,	///< xs:string value="ANY"
};

/// "http://xmlns.oracle.com/irm/core":LicenseCriteria_Delivery is a simpleType restriction of xs:string.
/// @brief How a license is delivered to the device.
/// Note: enum values are prefixed with 'ns1__LicenseCriteria_USCOREDelivery' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns1__LicenseCriteria_USCOREDelivery
{
/// @brief License can be delivered during synchronization. Licenses of this type can also be requested on-demand. This allows licenses to be requested in-between synchronizations.
	ns1__LicenseCriteria_USCOREDelivery__SYNCHRONIZATION,	///< xs:string value="SYNCHRONIZATION"
/// @brief License can be delivered only on-demand. This is typically the delivery mechanism for licenses that are Transient or have time constraints that are relative to request time. Licenses of this type are not picked up during synchronization.
	ns1__LicenseCriteria_USCOREDelivery__ON_USCOREDEMAND,	///< xs:string value="ON_DEMAND"
/// @brief License is created and controlled by the client. This is a delivery mechanism used entirely on the client. The IRM client sometimes needs to make small, longer-lifetime, copies of a license to handle specific situations. These licenses are not synchronized with, nor refreshed against, the IRM server.
	ns1__LicenseCriteria_USCOREDelivery__CLIENT,	///< xs:string value="CLIENT"
};

/// "http://xmlns.oracle.com/irm/core":LicenseCriteria_Use is a simpleType restriction of xs:string.
/// @brief The intended use of a license. When content is opened an appropriate license, with an open feature, will be requested (and used). Licenses used in this fashion are called primary licenses. If a feature of a license is advertised as on demand the desktop can offer that feature to the user, but only when that feature is used will a license be requested. Licenses used in this fashion are called secondary licenses. For example, opening content will use a primary license, whereas optional printing might cause another license to be requested just for the print operation, this will be the secondary license.
/// Note: enum values are prefixed with 'ns1__LicenseCriteria_USCOREUse' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns1__LicenseCriteria_USCOREUse
{
/// @brief Primary use.
	ns1__LicenseCriteria_USCOREUse__PRIMARY,	///< xs:string value="PRIMARY"
/// @brief Secondary use. License will be typically requested on demand because of explicit use of an application feature. e.g printing. As a secondary license is used within the scope of a primary license, the secondary license will not cause a session to expire, but once out of a session the licenses will expire as normal.
	ns1__LicenseCriteria_USCOREUse__SECONDARY,	///< xs:string value="SECONDARY"
};

/// "http://xmlns.oracle.com/irm/core":Feature_Support is a simpleType restriction of xs:string.
/// @brief Feature support. This enumeration is used by methods that need to return the status of feature availability.
/// Note: enum values are prefixed with 'ns1__Feature_USCORESupport' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns1__Feature_USCORESupport
{
/// @brief Available. The feature is available for use.
	ns1__Feature_USCORESupport__AVAILABLE,	///< xs:string value="AVAILABLE"
/// @brief Available, but on-demand. The feature may be available, but must be obtained before it can be used.
	ns1__Feature_USCORESupport__ON_USCOREDEMAND,	///< xs:string value="ON_DEMAND"
/// @brief Unavailable. The feature is unavailable for use.
	ns1__Feature_USCORESupport__UNAVAILABLE,	///< xs:string value="UNAVAILABLE"
};

/// "http://xmlns.oracle.com/irm/core":Feature_Use is a simpleType restriction of xs:string.
/// @brief How this feature's usage is advertised to the user. A feature can either be immediately available for use, or advertised for use and requested on demand. For example, opening content is immediate use of the open feature, whereas printing might only use the print feature when the printing action is performed.
/// Note: enum values are prefixed with 'ns1__Feature_USCOREUse' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns1__Feature_USCOREUse
{
/// @brief Used immediately.
	ns1__Feature_USCOREUse__IMMEDIATE,	///< xs:string value="IMMEDIATE"
/// @brief Used on demand.
	ns1__Feature_USCOREUse__DEMAND,	///< xs:string value="DEMAND"
};

/// "http://xmlns.oracle.com/irm/core":TimeSpan_ReferencePoint is a simpleType restriction of xs:string.
/// @brief Time reference point. When referring to a span of time it can be compared against a number of reference points. The most common reference point is to compare against the current time. e.g. Is it lunch time? (between 12:00 and 13:00). Other reference points are available, such as when content was published. e.g. Was this content published this year? A time reference allows a time span to be associated with a time reference point, either current time, classification time or license creation time.
/// Note: enum values are prefixed with 'ns1__TimeSpan_USCOREReferencePoint' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns1__TimeSpan_USCOREReferencePoint
{
/// @brief Current time. Compare the time span against current time.
	ns1__TimeSpan_USCOREReferencePoint__CURRENT,	///< xs:string value="CURRENT"
/// @brief Classification time. Compare the time span against time the classification was applied (Classification Time).
	ns1__TimeSpan_USCOREReferencePoint__CLASSIFICATION,	///< xs:string value="CLASSIFICATION"
/// @brief License time. Compare the time span against time the license was granted (License Time).
	ns1__TimeSpan_USCOREReferencePoint__LICENSE,	///< xs:string value="LICENSE"
};

/// "http://xmlns.oracle.com/irm/core":TimePeriod_Units is a simpleType restriction of xs:string.
/// @brief Time units. Such as years, months or days.
/// Note: enum values are prefixed with 'ns1__TimePeriod_USCOREUnits' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns1__TimePeriod_USCOREUnits
{
/// @brief Seconds.
	ns1__TimePeriod_USCOREUnits__SECONDS,	///< xs:string value="SECONDS"
/// @brief Minutes.
	ns1__TimePeriod_USCOREUnits__MINUTES,	///< xs:string value="MINUTES"
/// @brief Hours.
	ns1__TimePeriod_USCOREUnits__HOURS,	///< xs:string value="HOURS"
/// @brief Days.
	ns1__TimePeriod_USCOREUnits__DAYS,	///< xs:string value="DAYS"
/// @brief Months.
	ns1__TimePeriod_USCOREUnits__MONTHS,	///< xs:string value="MONTHS"
/// @brief Years.
	ns1__TimePeriod_USCOREUnits__YEARS,	///< xs:string value="YEARS"
};

/// "http://xmlns.oracle.com/irm/core":RelativeTimeSpan_TimeBase is a simpleType restriction of xs:string.
/// @brief Relative time bases.
/// Note: enum values are prefixed with 'ns1__RelativeTimeSpan_USCORETimeBase' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns1__RelativeTimeSpan_USCORETimeBase
{
/// @brief Relative to classification time.
	ns1__RelativeTimeSpan_USCORETimeBase__CLASSIFICATION,	///< xs:string value="CLASSIFICATION"
/// @brief Relative to license creation time.
	ns1__RelativeTimeSpan_USCORETimeBase__LICENSE,	///< xs:string value="LICENSE"
/// @brief Relative to license request time.
	ns1__RelativeTimeSpan_USCORETimeBase__REQUEST,	///< xs:string value="REQUEST"
};

/// "http://xmlns.oracle.com/irm/core":Account_Type is a simpleType restriction of xs:string.
/// @brief The type of account. A user or group.
/// Note: enum values are prefixed with 'ns1__Account_USCOREType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns1__Account_USCOREType
{
/// @brief A user account.
	ns1__Account_USCOREType__USER,	///< xs:string value="USER"
/// @brief A group account.
	ns1__Account_USCOREType__GROUP,	///< xs:string value="GROUP"
};

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/content                                      *
 *                                                                            *
\******************************************************************************/


/// "http://xmlns.oracle.com/irm/content":ContentParseFault_Reason is a simpleType restriction of xs:string.
/// @brief The reason for the parse error.
/// Note: enum values are prefixed with 'ns2__ContentParseFault_USCOREReason' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns2__ContentParseFault_USCOREReason
{
/// @brief Truncated sealed content. The end of sealed content was encountered when more data was expected.
	ns2__ContentParseFault_USCOREReason__CONTENT_USCORETRUNCATED,	///< xs:string value="CONTENT_TRUNCATED"
/// @brief An XML block in sealed content has an invalid size. When reading XML from sealed content the size of the XML is written into the file. This error code indicates the size read is invalid (e.g. negative or too large a value).
	ns2__ContentParseFault_USCOREReason__XML_USCOREBLOCK_USCOREINVALID_USCORESIZE,	///< xs:string value="XML_BLOCK_INVALID_SIZE"
/// @brief An XML block in sealed content is empty.
	ns2__ContentParseFault_USCOREReason__XML_USCOREBLOCK_USCOREEMPTY,	///< xs:string value="XML_BLOCK_EMPTY"
/// @brief An XML block in sealed content is truncated or missing.
	ns2__ContentParseFault_USCOREReason__XML_USCOREBLOCK_USCORETRUNCATED,	///< xs:string value="XML_BLOCK_TRUNCATED"
/// @brief The sealed content preamble was not found. This error code indicates that the content is probably not a sealed.
	ns2__ContentParseFault_USCOREReason__PREAMBLE_USCORENOT_USCOREFOUND,	///< xs:string value="PREAMBLE_NOT_FOUND"
/// @brief The sealed content magic value was not found. This error code indicates that the content is probably corrupt or not sealed.
	ns2__ContentParseFault_USCOREReason__MAGIC_USCORENOT_USCOREFOUND,	///< xs:string value="MAGIC_NOT_FOUND"
/// @brief The public header is not present in the sealed content. This error code indicates that a valid XML document was found where the public header should be, but the XML document was not a public header. This error indicates that the XML has been modified.
	ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCOREMISSING,	///< xs:string value="PUBLIC_HEADER_MISSING"
/// @brief The public header XML is badly formed. This error code indicates that the public header XML cannot be parsed. This error indicates that the XML has been corrupted.
	ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORECORRUPT,	///< xs:string value="PUBLIC_HEADER_CORRUPT"
/// @brief The public header has failed signature verification. This error code indicates that the public header XML has a valid structure but the contents have been modified.
	ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORESIGNATURE_USCOREMISMATCH,	///< xs:string value="PUBLIC_HEADER_SIGNATURE_MISMATCH"
/// @brief The public header signatures are not present in the sealed content. This error code indicates that a valid XML document was found where the public header signatures should be, but the XML document was not a public header signature. This error indicates that the XML has been modified.
	ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORESIGNATURE_USCOREMISSING,	///< xs:string value="PUBLIC_HEADER_SIGNATURE_MISSING"
/// @brief The public header signatures XML is badly formed. This error code indicates that the public header signatures XML cannot be parsed. This error indicates that the XML has been corrupted.
	ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORESIGNATURE_USCORECORRUPT,	///< xs:string value="PUBLIC_HEADER_SIGNATURE_CORRUPT"
/// @brief A private header does not match the public header. This error code indicates that the content has probably been corrupted.
	ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCOREDATA_USCOREDIGEST_USCOREMISMATCH,	///< xs:string value="PUBLIC_HEADER_DATA_DIGEST_MISMATCH"
/// @brief The encrypted data has been modified. The contents of a block appear to have been corrupted. This error code indicates that the content has probably been corrupted.
	ns2__ContentParseFault_USCOREReason__PRIVATE_USCOREBLOCK_USCOREDIGEST_USCOREMISMATCH,	///< xs:string value="PRIVATE_BLOCK_DIGEST_MISMATCH"
/// @brief The contents of a sealed content private header are invalid. This error code indicates that the content has probably been corrupted.
	ns2__ContentParseFault_USCOREReason__PRIVATE_USCOREHEADER_USCORECORRUPT,	///< xs:string value="PRIVATE_HEADER_CORRUPT"
};

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/system                                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/content/wsdl                                 *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/classifications                              *
 *                                                                            *
\******************************************************************************/


/// "http://xmlns.oracle.com/irm/classifications":ItemConstraints_Type is a simpleType restriction of xs:string.
/// @brief Type of item constraint. The item constraint type determines how the item codes are interpreted - either locks or exclusions.
/// Note: enum values are prefixed with 'ns5__ItemConstraints_USCOREType' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns5__ItemConstraints_USCOREType
{
/// @brief Item locks. The Item Codes are interpreted as a list of allowed items.
	ns5__ItemConstraints_USCOREType__LOCKS,	///< xs:string value="LOCKS"
/// @brief Item exclusions. The Item Codes are interpreted as a list of disallowed items.
	ns5__ItemConstraints_USCOREType__EXCLUSIONS,	///< xs:string value="EXCLUSIONS"
};

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/rights                                       *
 *                                                                            *
\******************************************************************************/


/// "http://xmlns.oracle.com/irm/rights":ContextInstance_Visibility is a simpleType restriction of xs:string.
/// @brief Context visibility.
/// Note: enum values are prefixed with 'ns6__ContextInstance_USCOREVisibility' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns6__ContextInstance_USCOREVisibility
{
/// @brief Context visible to inspectors and context managers.
	ns6__ContextInstance_USCOREVisibility__DOMAIN,	///< xs:string value="DOMAIN"
/// @brief Context visible to context managers only.
	ns6__ContextInstance_USCOREVisibility__CONTEXT,	///< xs:string value="CONTEXT"
};

/// "http://xmlns.oracle.com/irm/rights":ContextInstance_Role is a simpleType restriction of xs:string.
/// @brief Roles within a context.
/// Note: enum values are prefixed with 'ns6__ContextInstance_USCORERole' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns6__ContextInstance_USCORERole
{
/// @brief None.
	ns6__ContextInstance_USCORERole__NONE,	///< xs:string value="NONE"
/// @brief Manager.
	ns6__ContextInstance_USCORERole__MANAGER,	///< xs:string value="MANAGER"
/// @brief Inspector.
	ns6__ContextInstance_USCORERole__INSPECTOR,	///< xs:string value="INSPECTOR"
};

/// "http://xmlns.oracle.com/irm/rights":ContextTemplate_Status is a simpleType restriction of xs:string.
/// @brief Status of the template. A template can be ready for use (active) or inactive. Only active template can be used to create new context classification.s
/// Note: enum values are prefixed with 'ns6__ContextTemplate_USCOREStatus' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns6__ContextTemplate_USCOREStatus
{
/// @brief Inactive template.
	ns6__ContextTemplate_USCOREStatus__INACTIVE,	///< xs:string value="INACTIVE"
/// @brief Active template.
	ns6__ContextTemplate_USCOREStatus__ACTIVE,	///< xs:string value="ACTIVE"
};

/// "http://xmlns.oracle.com/irm/rights":DocumentRole_ExportConstraints is a simpleType restriction of xs:string.
/// @brief Export constraint options. Export constraints specify what resealing and copying sealed content operations are permitted. For example, setting up a document role to be fully constrained disallows resealing and copy/paste operations within sealed content.
/// Note: enum values are prefixed with 'ns6__DocumentRole_USCOREExportConstraints' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns6__DocumentRole_USCOREExportConstraints
{
/// @brief Fully constrained. Content cannot be resealing or copied. Copying within the same document is permitted.
	ns6__DocumentRole_USCOREExportConstraints__FULL,	///< xs:string value="FULL"
/// @brief Constrained to trusted classifications. Allows content to be resealed or copied to the classifications specified in role's classification Destinations. Copying within the same document is permitted.
	ns6__DocumentRole_USCOREExportConstraints__TRUSTED,	///< xs:string value="TRUSTED"
/// @brief No constraints. Allows content to be resealed to any classification, copied into the clear or saved in unsealed form.
	ns6__DocumentRole_USCOREExportConstraints__NONE,	///< xs:string value="NONE"
};

/// "http://xmlns.oracle.com/irm/rights":DocumentRole_TimeConstraints is a simpleType restriction of xs:string.
/// @brief Time constraint common use cases. Time constraints are applied on a document role by filling the Time Spans property with the time constraints. A number of common use cases can be specified using the utility methods on Document Role Operations. One example is the Set Absolute Time Constraints method is a utility method that allows a time constraint based on absolute time to be specified. This enumeration lists common use cases when setting time constraints.
/// Note: enum values are prefixed with 'ns6__DocumentRole_USCORETimeConstraints' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns6__DocumentRole_USCORETimeConstraints
{
/// @brief No time constraints.
	ns6__DocumentRole_USCORETimeConstraints__NONE,	///< xs:string value="NONE"
/// @brief Absolute time constraint.
	ns6__DocumentRole_USCORETimeConstraints__ABSOLUTE,	///< xs:string value="ABSOLUTE"
/// @brief Relative assignment time constraint.
	ns6__DocumentRole_USCORETimeConstraints__RELATIVE_USCOREASSIGNMENT,	///< xs:string value="RELATIVE_ASSIGNMENT"
/// @brief Relative classification time constraint.
	ns6__DocumentRole_USCORETimeConstraints__RELATIVE_USCORECLASSIFICATION,	///< xs:string value="RELATIVE_CLASSIFICATION"
/// @brief Other time constraints not part of the common use cases.
	ns6__DocumentRole_USCORETimeConstraints__OTHER,	///< xs:string value="OTHER"
};

/// "http://xmlns.oracle.com/irm/rights":Domain_Role is a simpleType restriction of xs:string.
/// @brief Roles that user's can have within a domain.
/// Note: enum values are prefixed with 'ns6__Domain_USCORERole' to avoid name clashes, please use wsdl2h option -e to omit this prefix
enum ns6__Domain_USCORERole
{
/// @brief None.
	ns6__Domain_USCORERole__NONE,	///< xs:string value="NONE"
/// @brief Administrator.
	ns6__Domain_USCORERole__ADMINISTRATOR,	///< xs:string value="ADMINISTRATOR"
/// @brief Manager.
	ns6__Domain_USCORERole__MANAGER,	///< xs:string value="MANAGER"
/// @brief Inspector.
	ns6__Domain_USCORERole__INSPECTOR,	///< xs:string value="INSPECTOR"
};

/******************************************************************************\
 *                                                                            *
 * Schema Types and Top-Level Elements and Attributes                         *
 *   http://xmlns.oracle.com/irm/rights/wsdl                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://xmlns.oracle.com/irm/core                                         *
 *                                                                            *
\******************************************************************************/


/// "http://xmlns.oracle.com/irm/core":ClassificationSystem is a complexType.
/// @brief Classification system. A classification system is a definition of what data is sealed into content, how that meta-data is used to grant access to that content and how many cryptography keys are used. The classification system requires server logic to respond to license requests by returning appropriate License instances. Different classification systems are free to define what the cookie data is added to content and how to use this information in a server when responding with license details. For example, the Context classification system embeds a Context Cookie into sealed content. The context classification system also defines that for each context, one or more cryptography key sets can be used. One of these key sets is marked as the active one that is used to seal all new content. Licenses are obtained by assigning a role to a user or group, defining what rights are available within a context.
class ns1__ClassificationSystem
{ public:
/// @brief A globally unique id for the classification system.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":ClassificationSystemRef is a complexType.
/// @brief Classification system. A classification system is a definition of what data is sealed into content, how that meta-data is used to grant access to that content and how many cryptography keys are used. The classification system requires server logic to respond to license requests by returning appropriate License instances. Different classification systems are free to define what the cookie data is added to content and how to use this information in a server when responding with license details. For example, the Context classification system embeds a Context Cookie into sealed content. The context classification system also defines that for each context, one or more cryptography key sets can be used. One of these key sets is marked as the active one that is used to seal all new content. Licenses are obtained by assigning a role to a user or group, defining what rights are available within a context.
class ns1__ClassificationSystemRef
{ public:
/// @brief A globally unique id for the classification system.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":Label is a complexType.
/// @brief A label for something. A label comprises of a name and a description. The label also specifies a locale.
class ns1__Label
{ public:
/// @brief Locale. The intended locale for this label.
/// Element locale of type xs:string.
    std::string                          locale                         1;	///< Required element.
/// @brief Name. A name for the label.
/// Element name of type xs:string.
    std::string                          name                           1;	///< Required element.
/// @brief Description. A fuller description of what the label represents.
/// Element description of type xs:string.
    std::string*                         description                    0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":Classification is a complexType.
/// @brief Classification. A classification is the set of meta-data sealed into content during the sealing process. This information includes the classification Cookie which is an opaque blob of data, the URI which is used to determine which server to contact for licenses and key sets, and the Classification Time which is used in license algorithms when determining whether content can be accessed. The format of the data in the cookie is defined by the classification System. For example, the context classification system provides a Context Cookie for the classification meta-data. A context cookie associates sealed content with a Context and an Item Code. License rules are then based on matching the context and/or item code.
class ns1__Classification
{ public:
/// @brief The classification Id. The classification Id is used to lookup classification details during the sealing processes. When content is sealed, if the caller has not provided any classification labels, the classification Id is used to look up the corresponding classification details from a master list (returned from a synchronize or request call). The labels from the classification are then filled in automatically before the content is sealed. The classification Id can also be used as a key to identify a classification in a list of classifications. The context classification system uses the context Uuid value as a classification Id.
/// Element id of type xs:string.
    std::string                          id                             1;	///< Required element.
/// @brief The classification system. The Classification System defines how the classification is structured and what data it contains. It also defines how licenses and key sets relate to the classification.
/// Element system of type "http://xmlns.oracle.com/irm/core":ClassificationSystemRef.
    ns1__ClassificationSystemRef*        system                         1;	///< Required element.
/// @brief The key set used to encrypt/de-crypt content sealed with this classification. If the key set is not known (when sealing content) this property can be set to null.
/// Element keySet of type "http://xmlns.oracle.com/irm/content":KeySetRef.
    ns2__KeySetRef*                      keySet                         0;	///< Optional element.
/// @brief Desktop URI. The URI used by the desktop to contact a server for licenses, keys, classification details and status pages. The desktop URI is sealed in with the content and must therefore be valid in perpetuity or at least as long as the sealed content is in circulation.
/// Element uri of type xs:anyURI.
    xsd__anyURI                          uri                            1;	///< Required element.
/// @brief Classification Time. The classification time signifies when content was classified. This is usually set to the time content is sealed, but does not have to be. It can represent when content is logically classified, for example, when a publication is released, rather than when it physically created.
/// Element classificationTime of type xs:dateTime.
    time_t*                              classificationTime             0;	///< Optional element.
/// @brief Labels for the classification. A set localized names that help identify the classification. When content is sealed these labels will appear in the content public header. This information can then be extracted and displayed without having to unseal the content. As this information is sealed into content be aware of the size implications - provide succinct names and descriptions. If the classification name is sensitive labels do not need to be provided.
/// Vector of ns1__Label* with length 0..unbounded
    std::vector<ns1__Label*            > labels                         0;
/// TODO: <any namespace="##any" minOccurs="1" maxOccurs="1">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this element.
///       Use wsdl2h option -d for xsd__anyType DOM (soap_dom_element).
    _XML                                 __any                         0;	///< Catch any element content in XML string.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":LicenseCriteria is a complexType.
/// @brief License criteria. The license criteria defines the what you can do, with what classifications and when criteria.
class ns1__LicenseCriteria
{ public:
/// @brief Storage specifier. Whether this license should be stored in persistent storage or not.
/// Element storage of type "http://xmlns.oracle.com/irm/core":LicenseCriteria_Storage.
    enum ns1__LicenseCriteria_USCOREStorage  storage                        1;	///< Required element.
/// @brief Delivery specifier. Specifies whether this license can be shipped using synchronization and/or shipped from an on-demand request. Care should be made to ensure that a license that is delivered on synchronization does not have conflicting criteria - such as a time constraint based on the license request time.
/// Element delivery of type "http://xmlns.oracle.com/irm/core":LicenseCriteria_Delivery.
    enum ns1__LicenseCriteria_USCOREDelivery  delivery                       1;	///< Required element.
/// @brief License use. Whether this license is a primary or secondary license.
/// Element use of type "http://xmlns.oracle.com/irm/core":LicenseCriteria_Use.
    enum ns1__LicenseCriteria_USCOREUse  use                            1;	///< Required element.
/// @brief The valid features. The list of features this license allows.
/// Vector of ns1__Feature* with length 1..unbounded
    std::vector<ns1__Feature*          > features                       1;
/// @brief Time constraints.
/// Vector of ns1__TimeSpan* with length 0..unbounded
    std::vector<ns1__TimeSpan*         > timeSpans                      0;
/// @brief The refresh period. How long this license can be used before the license must be refreshed.
/// Element refreshPeriod of type "http://xmlns.oracle.com/irm/core":TimePeriod.
    ns1__TimePeriod*                     refreshPeriod                  0;	///< Optional element.
/// @brief Valid classifications. The classifications this license relates.
/// Element classifications of type "http://xmlns.oracle.com/irm/core":ClassificationFilter.
    ns1__ClassificationFilter*           classifications                1;	///< Required element.
/// @brief Trusted classifications. The classifications this license allows content to be copied or re-classified.
/// Element destinations of type "http://xmlns.oracle.com/irm/core":ClassificationFilter.
    ns1__ClassificationFilter*           destinations                   0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":Feature is a complexType.
/// @brief An operation that can be performed on content, such as opening or printing.
class ns1__Feature
{ public:
/// @brief The feature identity. The feature identity is a unique string that identifies the feature. e.g. oracle.irm.generic.Open. Feature identities must be globally unique. Features that the desktop does not understand are ignored.
/// Length of this string is within 0..50 characters
    std::string                                                        
                                         id                             1;	///< Required element.
/// @brief How this feature is obtained. An immediate feature is one that is available for use as soon as content is accessed. An on demand feature is one that is on offer for use, but has to be obtained before it can be used. e.g. An immediate feature might be to open content, and once opened may offer print the content as a on demand feature. If printing is required the desktop must obtain the rights to print (by requesting licenses).
/// Element use of type "http://xmlns.oracle.com/irm/core":Feature_Use.
    enum ns1__Feature_USCOREUse          use                            1;	///< Required element.
/// @brief Whether use of this feature is recorded. When an application feature is used the event can be recorded. Feature use can be recorded on-line and off-line. Off-line feature usage is uploaded when the desktop comes back on-line.
/// Element record of type xs:boolean.
    bool                                 record                         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":TimeSpan is an abstract complexType.
/// @brief A time span. A time span can have an optional start and stop time and a flexible time reference point.
class ns1__TimeSpan
{ public:
/// @brief The reference point for a time span.
/// Element referencePoint of type "http://xmlns.oracle.com/irm/core":TimeSpan_ReferencePoint.
    enum ns1__TimeSpan_USCOREReferencePoint  referencePoint                 1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":TimePeriod is a complexType.
/// @brief A definition of a length of time. A time period stores a period of time as a numeric value and the time units - years, days, hours, minutes or seconds. A time period can have a positive or negative value - indicating the direction of the time period. A negative time period amount would mean that the time period is in the past, a positive time period would mean the time period is in the future.
class ns1__TimePeriod
{ public:
/// @brief The time period amount. e.g. two minutes, two hours.
/// Element amount of type xs:int.
    int                                  amount                         1;	///< Required element.
/// @brief Time units. e.g. two minutes, two hours.
/// Element units of type "http://xmlns.oracle.com/irm/core":TimePeriod_Units.
    enum ns1__TimePeriod_USCOREUnits     units                          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":ClassificationFilter is an abstract complexType.
/// @brief Classification filtering. A classification filter is a way of identifying a set of classifications. The classification filter is used by License algorithms to relate license use to content. Content contains a Classification, a license contains the filter. A license can be used if it's classification filter matches the classification embedded in the sealed content.
class ns1__ClassificationFilter
{ public:
/// @brief The classification system. This classification system must match the System of the classification for this filter to match.
/// Element system of type "http://xmlns.oracle.com/irm/core":ClassificationSystemRef.
    ns1__ClassificationSystemRef*        system                         1;	///< Required element.
/// @brief Server URI. A Classification contains a URI and it is this URI that is used to contact a server to obtain licenses and keys. A classification filter will only match a Classification that exactly matches on URI value.
/// Element uri of type xs:anyURI.
    xsd__anyURI                          uri                            1;	///< Required element.
/// @brief Classification filter index. The main use of a classification filter is to link a license with a set of content. When sealed content is opened the Classification is extracted from the public header and checked against a set of available licenses. If the set of licenses being searched is large this process can take a long time. Each license is asked are you applicable to this classification? The search time linearly increases with the number of licenses. To improve performance during such scenarios an optional index can be provided on the classification filter. When licenses are stored they can be indexed with the index value and searches can be optimized by matching related licenses. The index lookup value is extracted from the classification Cookie using a special Content Attribute. This index content attribute is used to extract the textual value from the Classification that can be used to look up the set of licenses related to the content. The index content attribute is classification system specific. If no index content attribute is available or no classification index provided then the classification filter must be compared against all licenses that match the same URI (same server) and classification system as the content.
/// Element index of type xs:string.
    std::string*                         index                          0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":XPathExpression is a complexType.
/// @brief XPath expression.
class ns1__XPathExpression
{ public:
/// @brief The namespace contexts used in the expression.
/// Vector of xsd__QName with length 0..unbounded
    std::vector<xsd__QName             > namespaceContexts              0;
/// @brief The XPath expression value.
/// Element value of type xs:string.
    std::string                          value                          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":Account is a complexType.
/// @brief A user or group identifier. An account is the information required to identity a user or group stored in an external user store - such as LDAP. The data identifying a user or group is a UUID or GUID value. When internal operations ask for user or group related data (such as looking up licenses for a user) the user or group is identified by this UUID value. When referencing a user or group providing a UUID or GUID value in the format used by the user store can be problematic as the UUID or GUID value is not always easy to obtain. Referencing a user or group is made easier by the following alternative mechanisms. User Name. To identify a user by name provide a URN in the format urn:user:name where name is the user name. This format requires the user name to be URL encoded. e.g. for user bob smith the URN would be urn:user:bob%20smith. Group Name. To identify a group by name provide a URN in the format urn:group:name where name is the group name. This format requires the group name to be URL encoded. e.g. for group board of directors the URN would be urn:group:board%20of%20directors. UUID. To identify the user by UUID provide the raw uuid value as used by the user store. e.g. 4687dcb0-8b6e-4bc8-b65c-a8845c7e1e00.
class ns1__Account
{ public:
/// @brief The user or group UUID. The account UUID is used to uniquely identify the account regardless of whether the user or group name is altered. This value may or may not be in the standard UUID format 00000000-0000-0000-0000-000000000000 depending on the type of user store used.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// @brief The user or group name. For users this name will be the user name used for authentication.
/// Element name of type xs:string.
    std::string                          name                           1;	///< Required element.
/// @brief The type of account. Whether this account represents a user or group.
/// Element type of type "http://xmlns.oracle.com/irm/core":Account_Type.
    enum ns1__Account_USCOREType         type                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":AccountRef is a complexType.
/// @brief A user or group identifier. An account is the information required to identity a user or group stored in an external user store - such as LDAP. The data identifying a user or group is a UUID or GUID value. When internal operations ask for user or group related data (such as looking up licenses for a user) the user or group is identified by this UUID value. When referencing a user or group providing a UUID or GUID value in the format used by the user store can be problematic as the UUID or GUID value is not always easy to obtain. Referencing a user or group is made easier by the following alternative mechanisms. User Name. To identify a user by name provide a URN in the format urn:user:name where name is the user name. This format requires the user name to be URL encoded. e.g. for user bob smith the URN would be urn:user:bob%20smith. Group Name. To identify a group by name provide a URN in the format urn:group:name where name is the group name. This format requires the group name to be URL encoded. e.g. for group board of directors the URN would be urn:group:board%20of%20directors. UUID. To identify the user by UUID provide the raw uuid value as used by the user store. e.g. 4687dcb0-8b6e-4bc8-b65c-a8845c7e1e00.
class ns1__AccountRef
{ public:
/// @brief The user or group UUID. The account UUID is used to uniquely identify the account regardless of whether the user or group name is altered. This value may or may not be in the standard UUID format 00000000-0000-0000-0000-000000000000 depending on the type of user store used.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":PageRange is a complexType.
/// @brief A page range. A page range specifies a range of records starting from the First record index and ending at the Last record index time.
class ns1__PageRange
{ public:
/// @brief First record index. Indexes start at one.
/// Element first of type xs:int.
    int                                  first                          1;	///< Required element.
/// @brief Last record index. Must be greater than the first record index.
/// Element last of type xs:int.
    int                                  last                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://xmlns.oracle.com/irm/content                                      *
 *                                                                            *
\******************************************************************************/


/// "http://xmlns.oracle.com/irm/content":CryptoSchema is a complexType.
/// @brief Sealed content cryptography schema. A cryptography schema is used to link a Key Set with the set of cryptography algorithms used when working with that key set. A cryptography schema must be specified when creating a key set. The schema defines what types of cryptography key are generated and what key sizes are used. The cryptography schema is also used (via the key set) when sealing or unsealing content. When performing operations such as sealing or unsealing the schema defines what algorithms are used for encrypting (and decrypting) the content, signing the content and calculating digests.
class ns2__CryptoSchema
{ public:
/// @brief The identity of the schema. The identity must refer to a built-in engined defined cryptography schema.
/// Length of this string is within 0..50 characters
    std::string                                                        
                                         id                             1;	///< Required element.
/// @brief The encryption transformation. The encryption transformation is used to encrypt (and decrypt) the main body of the sealed content using the per content generated session key. e.g. AES/CTR/NoPadding.
/// Element encryptionTransformation of type xs:string.
    std::string                          encryptionTransformation       1;	///< Required element.
/// @brief The encryption key size (in bits). This information is used with a key set is generated.
/// Element encryptionKeySize of type xs:int.
    int                                  encryptionKeySize              1;	///< Required element.
/// @brief The signing algorithm specification. The signing algorithm is used to sign the public header of the sealed content to prevent tampering. e.g. HmacSHA256.
/// Element hmacSigningAlgorithm of type xs:string.
    std::string                          hmacSigningAlgorithm           1;	///< Required element.
/// @brief The key size (in bits) for the HMAC operation. This information is used with a key set is generated.
/// Element hmacSigningKeySize of type xs:int.
    int                                  hmacSigningKeySize             1;	///< Required element.
/// @brief The message digest algorithm. The digest is used to check the cipher text block has not been altered. e.g. SHA-256.
/// Element digestAlgorithm of type xs:string.
    std::string                          digestAlgorithm                1;	///< Required element.
/// @brief The session key encryption transformation. The session key transformation is used to encrypt the session key before embedding it into sealed content. e.g. AES/ECB/NoPadding.
/// Element sessionKeyEncryptionTransformation of type xs:string.
    std::string                          sessionKeyEncryptionTransformation 1;	///< Required element.
/// @brief The key size (in bits) for session key encryption. This information is used with a key set is generated.
/// Element sessionKeyEncryptionKeySize of type xs:int.
    int                                  sessionKeyEncryptionKeySize    1;	///< Required element.
/// @brief If true, only FIPS-approved cryptography implementations should be used.
/// Element useFips of type xs:boolean.
    bool                                 useFips                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":CryptoSchemaRef is a complexType.
/// @brief Sealed content cryptography schema. A cryptography schema is used to link a Key Set with the set of cryptography algorithms used when working with that key set. A cryptography schema must be specified when creating a key set. The schema defines what types of cryptography key are generated and what key sizes are used. The cryptography schema is also used (via the key set) when sealing or unsealing content. When performing operations such as sealing or unsealing the schema defines what algorithms are used for encrypting (and decrypting) the content, signing the content and calculating digests.
class ns2__CryptoSchemaRef
{ public:
/// @brief The identity of the schema. The identity must refer to a built-in engined defined cryptography schema.
/// Element id of type xs:string.
    std::string                          id                             1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":KeySetExtensions is an abstract complexType.
/// @brief Key set extensions. Key set extensions allow additional information to be attached to a Key Set. This information might be encrypted key values or raw key values. These extensions can be different depending on the use of the key set, or how the key set was obtained.
class ns2__KeySetExtensions
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":KeySet is a complexType.
/// @brief A set of cryptography keys used in the sealing and unsealing process. A key set is the set of cryptography keys (and associated information) needed to create and open sealed content. Key sets are identified by a UUID. This UUID is stamped into sealed content and used to associate the content with the key set used to encrypt that content. The cryptography Schema determines what type and strength of cryptography keys are used. These cryptography keys, if required, can be provided with the key set in the Extensions property. This extensions property, for example, could contain the cryptography key values in wrapped form.
class ns2__KeySet
{ public:
/// @brief Key UUID. An immutable and unique UUID for the key. This identifier will be sealed into content so cannot not be altered for the lifetime of content.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// @brief The cryptography schema used to create this key.
/// Element schema of type "http://xmlns.oracle.com/irm/content":CryptoSchemaRef.
    ns2__CryptoSchemaRef*                schema                         1;	///< Required element.
/// @brief Date and time the key was created.
/// Element creationTime of type xs:dateTime.
    time_t                               creationTime                   1;	///< Required element.
/// @brief Extended information for the key set. Extensions are optional, so this property may have a null value.
/// Element extensions of type "http://xmlns.oracle.com/irm/content":KeySetExtensions.
    ns2__KeySetExtensions*               extensions                     0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":KeySetRef is a complexType.
/// @brief A set of cryptography keys used in the sealing and unsealing process. A key set is the set of cryptography keys (and associated information) needed to create and open sealed content. Key sets are identified by a UUID. This UUID is stamped into sealed content and used to associate the content with the key set used to encrypt that content. The cryptography Schema determines what type and strength of cryptography keys are used. These cryptography keys, if required, can be provided with the key set in the Extensions property. This extensions property, for example, could contain the cryptography key values in wrapped form.
class ns2__KeySetRef
{ public:
/// @brief Key UUID. An immutable and unique UUID for the key. This identifier will be sealed into content so cannot not be altered for the lifetime of content.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":CustomData is a complexType.
/// @brief Sealed content custom data. Sealed content can contain data that is not part of the sealed content Classification. This data is called the custom data and can be considered a set of opaque data entries for use by sealed content integrations.
class ns2__CustomData
{ public:
/// @brief Custom data UUID This UUID value should uniquely identify the type of custom data provided. This allows different vendors/integrations to add custom data to sealed content without the custom data entries clashing.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// TODO: <any namespace="##any" minOccurs="1" maxOccurs="1">
/// TODO: Schema extensibility is user-definable.
///       Consult the protocol documentation to change or insert declarations.
///       Use wsdl2h option -x to remove this element.
///       Use wsdl2h option -d for xsd__anyType DOM (soap_dom_element).
    _XML                                 __any                         0;	///< Catch any element content in XML string.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":SchemaVersion is a complexType.
/// @brief A schema version. A version numbering scheme for a Content Schema.
class ns2__SchemaVersion
{ public:
/// @brief Version string. e.g. 6.0
/// Element version of type xs:string.
    std::string                          version                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":ContentSchema is a complexType.
/// @brief Schema version information for sealed content. When content is sealed, it is sealed against a schema. This schema defines the format of the sealed content. The desktop will support opening content for all the schemas it is aware of. If tries to open content for a schema it does not support it will prompt the user to upgrade their desktop installation. The content schema stores the schema number and the minimum desktop version required to work with that schema version.
class ns2__ContentSchema
{ public:
/// @brief Schema version. e.g. 5.0.0.
/// Element schemaVersion of type "http://xmlns.oracle.com/irm/content":SchemaVersion.
    ns2__SchemaVersion*                  schemaVersion                  1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":EncryptionOptions is a complexType.
/// @brief Encryption options for sealing content. The most common use of this class is to alter the size of the encrypted content blocks in the sealed file. Note that most of the important parameters (algorithm, key-size, etc.) are determined by the choice of Crypto Schema associated with the classification.
class ns2__EncryptionOptions
{ public:
/// @brief Public header repeat period. If non-zero, then the public header period defines how often to repeat the public header. After the specified number of encrypted chunks, the public header will be repeated. This feature can be used with content that is provided in stream form so that clients can observe the data stream and start de-crypting once a public header has been encountered.
/// Element publicHeaderPeriod of type xs:int.
    int                                  publicHeaderPeriod             1;	///< Required element.
/// @brief Encrypted content block size. This is the length (in bytes) of an individual cipher-text block. This value must be a multiple of the cipher block size used to encrypt content. The default value is 16K.
/// Element encryptedContentBlockSize of type xs:int.
    int                                  encryptedContentBlockSize      1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":SealingOptions is a complexType.
/// @brief Sealing options. There are a number of parameters required when content is sealed. These include the Classification details, additional user defined custom meta data, a content schema and fine-grained control of the content encryption processes (using encryption options).
class ns2__SealingOptions
{ public:
/// @brief Classification. The classification to use when sealing the content.
/// Element classification of type "http://xmlns.oracle.com/irm/core":Classification.
    ns1__Classification*                 classification                 1;	///< Required element.
/// @brief Custom data. Custom meta data is sealed into the sealed content public header. This information can be accessed using Peek.
/// Vector of ns2__CustomData* with length 0..unbounded
    std::vector<ns2__CustomData*       > customData                     0;
/// @brief Content schema. The content schema is a content specific version number that can be used by the desktop to help interpret any version specific details there may be with the sealed content.
/// Element contentSchema of type "http://xmlns.oracle.com/irm/content":ContentSchema.
    ns2__ContentSchema*                  contentSchema                  0;	///< Optional element.
/// @brief Creation time. When content is sealed a creation time stamp is added to the sealed content meta-data. This information can be accessed using Peek. Usually the creation time is the time the content was sealed, but it could be a specified to be a different time, perhaps to match the attributes of the unsealed content.
/// Element creationTime of type xs:dateTime.
    time_t*                              creationTime                   0;	///< Optional element.
/// @brief Encryption options. Encryption options allow fine grained control over the structure of the encrypted sealed content.
/// Element encryptionOptions of type "http://xmlns.oracle.com/irm/content":EncryptionOptions.
    ns2__EncryptionOptions*              encryptionOptions              0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":ContentDescription is a complexType.
/// @brief Sealed content meta data. The sealed content description is meta data that is added to content during the sealing process. The content description contains the classification details and any user defined meta data. The content description can be extracted from sealed content using the Peek method.
class ns2__ContentDescription
{ public:
/// @brief Content schema version.
/// Element schema of type "http://xmlns.oracle.com/irm/content":ContentSchema.
    ns2__ContentSchema*                  schema                         1;	///< Required element.
/// @brief The classification used to seal the content.
/// Element classification of type "http://xmlns.oracle.com/irm/core":Classification.
    ns1__Classification*                 classification                 1;	///< Required element.
/// @brief Optional custom data.
/// Vector of ns2__CustomData* with length 0..unbounded
    std::vector<ns2__CustomData*       > customData                     0;
/// @brief Date and time when the content was originally sealed.
/// Element creationTime of type xs:dateTime.
    time_t                               creationTime                   1;	///< Required element.
/// @brief Date and time when the content was last (re)sealed.
/// Element editTime of type xs:dateTime.
    time_t                               editTime                       1;	///< Required element.
/// @brief The MIME type of the sealed file.
/// Element sealedMime of type xs:string.
    std::string                          sealedMime                     1;	///< Required element.
/// @brief The size of the original unsealed file. -1 if unknown.
/// Element unsealedSize of type xs:long.
    LONG64                               unsealedSize                   1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":UnsupportedContentTypeFault is a complexType.
/// @brief Unsupported content type/format. The sealing process is restricted to certain content types/formats.
class ns2__UnsupportedContentTypeFault
{ public:
/// @brief The unknown thing.
/// Element value of type xs:string.
    std::string                          value                          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":IllegalEncryptedContentBlockSizeFault is a complexType.
/// @brief Illegal encrypted content block size. When performing a sealing operation, content encryption options can be supplied that control the size of the encrypted content blocks. The encrypted content block size must be a multiple of the cipher block size. The cipher block size relates to the Crypto Schema involved in the sealing process. This restriction on encrypted content block sizes allows the sealing process to work with block based ciphers as well as streaming ciphers.
class ns2__IllegalEncryptedContentBlockSizeFault
{ public:
/// @brief Cipher block size.
/// Element blockSize of type xs:int.
    int                                  blockSize                      1;	///< Required element.
/// @brief Encrypted encrypted content block size.
/// Element encryptedContentBlockSize of type xs:int.
    int                                  encryptedContentBlockSize      1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":PublicHeaderLengthFault is a complexType.
/// @brief Public header length exception. When sealed content is created (or resealed) a public header is written into sealed content as XML. The public header has a maximum size defined that prevents creation of large public headers. A public header will typically only exceed the maximum size if the custom data or classification cookie are large.
class ns2__PublicHeaderLengthFault
{ public:
/// @brief Actual length.
/// Element length of type xs:int.
    int                                  length                         1;	///< Required element.
/// @brief Maximum length.
/// Element maximum of type xs:int.
    int                                  maximum                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/content":ContentParseFault is a complexType.
/// @brief Sealed content parse exception. This exception is thrown when the unsealing or resealing process encounters a parse error.
class ns2__ContentParseFault
{ public:
/// @brief The reason the parsing failed.
/// Element reason of type "http://xmlns.oracle.com/irm/content":ContentParseFault_Reason.
    enum ns2__ContentParseFault_USCOREReason  reason                         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://xmlns.oracle.com/irm/system                                       *
 *                                                                            *
\******************************************************************************/


/// "http://xmlns.oracle.com/irm/system":AuthorizationDeniedFault is a complexType.
/// @brief Authorization denied.
class ns3__AuthorizationDeniedFault
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://xmlns.oracle.com/irm/content/wsdl                                 *
 *                                                                            *
\******************************************************************************/



/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":Seal

/// "http://xmlns.oracle.com/irm/content/wsdl":Seal is a complexType.
/// @brief Seal content. Sealing is the process of taking plaintext content, encrypting and signing the content with an associated Classification. If the classification provided is a context classification system classification, this method will provide an automatic Item Code if one is not specified in the classification details. To perform a sealing operation the authenticated user must have the rights to seal content for the specified classification. Sealing is authorized if the authenticated user has a license that allows the oracle.irm.generic.Seal Feature for the Classification specified in the sealing options.
class _ns4__Seal
{ public:
/// @brief The data stream.
/// Element stream of type xs:base64Binary.
    xsd__base64Binary                    stream                         1;	///< Required element.
/// @brief The unsealed or sealed MIME type of the data provided in the stream. The stream is assumed to contain unsealed data. It is advisable to use the sealed MIME type; this ensures the sealed content content type is unambiguous. e.g. the {text/plain} content type can be sealed as sealed text or sealed email. If the {text/plain} MIME type is specified the content will be sealed as sealed text.
/// Element mimeType of type xs:string.
    std::string                          mimeType                       1;	///< Required element.
/// @brief The sealing options.
/// Element options of type "http://xmlns.oracle.com/irm/content":SealingOptions.
    ns2__SealingOptions*                 options                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":SealResponse

/// "http://xmlns.oracle.com/irm/content/wsdl":SealResponse is a complexType.
class _ns4__SealResponse
{ public:
/// @brief Sealed data stream.
/// Element return of type xs:base64Binary.
    xsd__base64Binary                    return_                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":Unseal

/// "http://xmlns.oracle.com/irm/content/wsdl":Unseal is a complexType.
/// @brief Unseal a stream into an output stream. Unsealing is the process of taking sealed content, de-crypting it and returning the original unsealed content. To perform an unsealing operation the authenticated user must have the rights to unseal content. Unsealing is allowed if the authenticated user has a license that allows the oracle.irm.generic.SaveUnsealed Feature for the content's Classification.
class _ns4__Unseal
{ public:
/// @brief Sealed data.
/// Element input of type xs:base64Binary.
    xsd__base64Binary                    input                          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":UnsealResponse

/// "http://xmlns.oracle.com/irm/content/wsdl":UnsealResponse is a complexType.
class _ns4__UnsealResponse
{ public:
/// @brief Unsealed data stream.
/// Element return of type xs:base64Binary.
    xsd__base64Binary                    return_                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":Reseal

/// "http://xmlns.oracle.com/irm/content/wsdl":Reseal is a complexType.
/// @brief Reseal content with new custom data. Resealing is the process of altering the data or meta-data in sealed content. This method allows the custom data portion of the meta data to be replaced. To perform a resealing operation the authenticated user must have the rights to reseal the content. Resealing is allowed if the authenticated user has a valid license that has the oracle.irm.generic.Reseal Feature for the content's Classification.
class _ns4__Reseal
{ public:
/// @brief Sealed data.
/// Element input of type xs:base64Binary.
    xsd__base64Binary                    input                          1;	///< Required element.
/// @brief The new custom data.
/// Vector of ns2__CustomData* with length 0..unbounded
    std::vector<ns2__CustomData*       > customData                     0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":ResealResponse

/// "http://xmlns.oracle.com/irm/content/wsdl":ResealResponse is a complexType.
class _ns4__ResealResponse
{ public:
/// @brief Updated sealed data stream.
/// Element return of type xs:base64Binary.
    xsd__base64Binary                    return_                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":Reclassify

/// "http://xmlns.oracle.com/irm/content/wsdl":Reclassify is a complexType.
/// @brief Re-classify sealed content. Re-classification is the process of altering the Classification of the sealed content without having to perform a two step unseal and seal. During re-classification the content is re-encrypted and re-signed. If the classification labels or key set are not provided then the sealing process will attempt to fill in these details. If no labels are provided in the classification the labels are filled in automatically. Labels can only be filled in if provided classification Id matches the classification returned by the server. If no key set is provided then the key set is filled in from the license used to perform the sealing operation. If the license specifies multiple key sets then the first key set in the license is used. To perform a resealing operation the authenticated user must have a license for both the source classification and the target classification. The source classification license must allow the oracle.irm.generic.CopyTo or oracle.irm.generic.SaveUnsealed Feature. The target classification license must allow the oracle.irm.generic.Seal feature. If the source license has a copy to feature the transformation is only permitted if target classification is allowed by the trusted Destinations of the source classification license. If the source license has a save unsealed feature then there are no restrictions on the target classification.
class _ns4__Reclassify
{ public:
/// @brief Sealed data.
/// Element input of type xs:base64Binary.
    xsd__base64Binary                    input                          1;	///< Required element.
/// @brief New classification.
/// Element classification of type "http://xmlns.oracle.com/irm/core":Classification.
    ns1__Classification*                 classification                 1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":ReclassifyResponse

/// "http://xmlns.oracle.com/irm/content/wsdl":ReclassifyResponse is a complexType.
class _ns4__ReclassifyResponse
{ public:
/// @brief Updated sealed data stream.
/// Element return of type xs:base64Binary.
    xsd__base64Binary                    return_                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":Peek

/// "http://xmlns.oracle.com/irm/content/wsdl":Peek is a complexType.
/// @brief Peek sealed content. Peeking is the process of extracting the meta-data added to sealed content. This variant does not attempt to check the public header against its declared signature. If the meta-data has been altered post-sealing this method will not throw an exception. Any sealed content can be peek, the authenticated account does not require a license for the content's classification. This meta-data includes the Classification as well as information such as the Creation Time. The peeking process only examines the start of the sealed content. If a file is large it is not necessary to send the complete content, just the start of the file that contains the public header XML. This can improve performance when peeking large files.
class _ns4__Peek
{ public:
/// @brief Sealed data.
/// Element input of type xs:base64Binary.
    xsd__base64Binary                    input                          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":PeekResponse

/// "http://xmlns.oracle.com/irm/content/wsdl":PeekResponse is a complexType.
class _ns4__PeekResponse
{ public:
/// @brief The meta-data and classification details sealed into the content.
/// Element return of type "http://xmlns.oracle.com/irm/content":ContentDescription.
    ns2__ContentDescription*             return_                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":ValidatedPeek

/// "http://xmlns.oracle.com/irm/content/wsdl":ValidatedPeek is a complexType.
/// @brief Peek sealed content (with validation of the signature). Peeking is the process of extracting the meta-data added to sealed content. This variant attempts to check the public header against its declared signature. If the public header meta-data has been altered post sealing this method will throw an exception. A validated peek is allowed if the authenticated user has a license that has the open Feature for the content's Classification. The peeking process only examines the start of the sealed content. If a file is large it is not necessary to send the complete content, just the start of the file that contains the public header XML and signature. This can improve performance when peeking large files.
class _ns4__ValidatedPeek
{ public:
/// @brief Sealed data.
/// Element input of type xs:base64Binary.
    xsd__base64Binary                    input                          1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":ValidatedPeekResponse

/// "http://xmlns.oracle.com/irm/content/wsdl":ValidatedPeekResponse is a complexType.
class _ns4__ValidatedPeekResponse
{ public:
/// @brief The meta-data and classification details sealed into the content.
/// Element return of type "http://xmlns.oracle.com/irm/content":ContentDescription.
    ns2__ContentDescription*             return_                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://xmlns.oracle.com/irm/classifications                              *
 *                                                                            *
\******************************************************************************/


/// "http://xmlns.oracle.com/irm/classifications":ItemCode is a complexType.
/// @brief Sealed content identifier. An item code is a fine-grained way of identifying sealed content. An item code is made up of a string based Value and an optional Time stamp. When sealed content contains an item code the value and time stamp can be used to identify the content. The item code value is typically the file name and the time stamp indicates when the sealed content was created. However, these are just suggested uses - there is no requirement that these the file name/current time be used for these values. Two item codes are considered logically identical if the item code values are the same and, if present, the time stamps are the same.
class ns5__ItemCode
{ public:
/// @brief The item code value. There is no requirement for item codes to be unique.
/// Element value of type xs:string.
    std::string                          value                          1;	///< Required element.
/// @brief The item code time stamp. This time stamp usually indicates the time the item was created.
/// Element time of type xs:dateTime.
    time_t*                              time                           0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/classifications":Context is a complexType.
/// @brief A context. A context is used as a coarse grained way of classifying sealed documents. When content is sealed to the context classification system the sealed content contains details of the Context together with semi-unique value called the Item Code. This information together is called the Context Cookie. Rights to access context classified content is expressed in terms of the context and optionally the item code. e.g. "john can access all content sealed against context top secret" or "mary can access only content sealed against context top secret with an item code of secrets.sdoc". A context is identified by an UUID value.
class ns5__Context
{ public:
/// @brief Context UUID. A globally unique UUID for the context.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/classifications":ContextRef is a complexType.
/// @brief A context. A context is used as a coarse grained way of classifying sealed documents. When content is sealed to the context classification system the sealed content contains details of the Context together with semi-unique value called the Item Code. This information together is called the Context Cookie. Rights to access context classified content is expressed in terms of the context and optionally the item code. e.g. "john can access all content sealed against context top secret" or "mary can access only content sealed against context top secret with an item code of secrets.sdoc". A context is identified by an UUID value.
class ns5__ContextRef
{ public:
/// @brief Context UUID. A globally unique UUID for the context.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/classifications":ItemConstraints is a complexType.
/// @brief Item constraints. Item constraints contain a set of Item Code definitions that are either allowed or disallowed. A list of allowed items are called item locks and a list of excluded items are called item exclusions. Item constraints are used to create Classification Filter objects that allow (or disallow) access to individual sealed content items.
class ns5__ItemConstraints
{ public:
/// @brief The item codes. The set of allowed or disallowed items.
/// Vector of ns5__ItemCode* with length 0..unbounded
    std::vector<ns5__ItemCode*         > itemCodes                      0;
/// @brief The type of constraint.
/// Element type of type "http://xmlns.oracle.com/irm/classifications":ItemConstraints_Type.
    enum ns5__ItemConstraints_USCOREType  type                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/classifications":UnknownContextFault is a complexType.
/// @brief Unknown context. Thrown when a context does not exist or has been deleted. This exception is typically thrown when details about a context are requested but the context UUID provided does not match to any known UUID.
class ns5__UnknownContextFault
{ public:
/// @brief The unknown context UUID.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://xmlns.oracle.com/irm/rights                                       *
 *                                                                            *
\******************************************************************************/


/// "http://xmlns.oracle.com/irm/rights":ContextTemplate is a complexType.
/// @brief Context template. A context template provides a template structure for creating a Context Instance. The template supplies the default labels for a context and the list of Document Role definitions available to the context manager. A Context Instance has a permanent link back to the context template. If changes are made to the roles in the template, they immediately take effect in the context. This allows new role definitions that are added to the template to immediately be available for use in the context.
class ns6__ContextTemplate
{ public:
/// @brief An UUID for the template.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// @brief Template labels. The labels provide a default set of names and descriptions for a Context created from this template.
/// Vector of ns1__Label* with length 0..unbounded
    std::vector<ns1__Label*            > labels                         0;
/// @brief Template status. The default value is for a template to be in-active.
/// Element status of type "http://xmlns.oracle.com/irm/rights":ContextTemplate_Status.
    enum ns6__ContextTemplate_USCOREStatus  status                         1;	///< Required element.
/// @brief Document roles. The set of document roles that can be assign to account.
/// Vector of ns6__DocumentRoleRef* with length 0..unbounded
    std::vector<ns6__DocumentRoleRef*  > roles                          0;
/// @brief The domain that owns this context template.
/// Element domain of type "http://xmlns.oracle.com/irm/rights":DomainRef.
    ns6__DomainRef*                      domain                         0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":ContextTemplateRef is a complexType.
/// @brief Context template. A context template provides a template structure for creating a Context Instance. The template supplies the default labels for a context and the list of Document Role definitions available to the context manager. A Context Instance has a permanent link back to the context template. If changes are made to the roles in the template, they immediately take effect in the context. This allows new role definitions that are added to the template to immediately be available for use in the context.
class ns6__ContextTemplateRef
{ public:
/// @brief An UUID for the template.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// @brief The domain that owns this context template.
/// Element domain of type "http://xmlns.oracle.com/irm/rights":DomainRef.
    ns6__DomainRef*                      domain                         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":DocumentRole is a complexType.
/// @brief Context classified document role. A document role defines what features of the IRM Desktop a user can perform. It includes details such as what features are audited, the elapsed time a document can be used off-line, item constraints and time constraints.
class ns6__DocumentRole
{ public:
/// @brief Role UUID.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// @brief Role labels. A set of names and descriptions for the role.
/// Vector of ns1__Label* with length 0..unbounded
    std::vector<ns1__Label*            > labels                         0;
/// @brief Storage specifier. Whether this role allows off-line working (persistent storage) or not.
/// Element storage of type "http://xmlns.oracle.com/irm/core":LicenseCriteria_Storage.
    enum ns1__LicenseCriteria_USCOREStorage  storage                        1;	///< Required element.
/// @brief The valid features. The list of features this role allows.
/// Vector of ns1__Feature* with length 0..unbounded
    std::vector<ns1__Feature*          > features                       0;
/// @brief Time constraints.
/// Vector of ns1__TimeSpan* with length 0..unbounded
    std::vector<ns1__TimeSpan*         > timeSpans                      0;
/// @brief The refresh period. How long this role can be used before the server must be re-contacted.
/// Element refreshPeriod of type "http://xmlns.oracle.com/irm/core":TimePeriod.
    ns1__TimePeriod*                     refreshPeriod                  0;	///< Optional element.
/// @brief Item constraints. The type of item constraints that can be applied to rights assigned from this role.
/// Element itemConstraints of type "http://xmlns.oracle.com/irm/classifications":ItemConstraints_Type.
    enum ns5__ItemConstraints_USCOREType  itemConstraints                1;	///< Required element.
/// @brief Set the export constraints on a role. Export constraints control how sealed content can be resealed to other classifications, or copied between sealed content. Altering the export constraints of a document role automatically adds (or removes) the appropriate Feature definitions to the role that infer those export constraints. This methods is provided as an alternative way to adding or removing features manually to/from the document role.
/// Element exportConstraints of type "http://xmlns.oracle.com/irm/rights":DocumentRole_ExportConstraints.
    enum ns6__DocumentRole_USCOREExportConstraints  exportConstraints              1;	///< Required element.
/// @brief The domain that owns this role. Document roles must have an unique Uuid within a domain.
/// Element domain of type "http://xmlns.oracle.com/irm/rights":DomainRef.
    ns6__DomainRef*                      domain                         0;	///< Optional element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":DocumentRoleRef is a complexType.
/// @brief Context classified document role. A document role defines what features of the IRM Desktop a user can perform. It includes details such as what features are audited, the elapsed time a document can be used off-line, item constraints and time constraints.
class ns6__DocumentRoleRef
{ public:
/// @brief Role UUID.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// @brief The domain that owns this role. Document roles must have an unique Uuid within a domain.
/// Element domain of type "http://xmlns.oracle.com/irm/rights":DomainRef.
    ns6__DomainRef*                      domain                         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":Domain is a complexType.
/// @brief Domain. A domain is a way of organizing security policies relating to Context based classifications. A domain owns a set of document roles and context templates. The document roles are for use within this domain with. Each Context will have associated with it all or a sub-set of these roles for assignment to accounts. Context templates can be used to create Context classification instances with a well defined structure. e.g. defining which roles are available for use within a Context.
class ns6__Domain
{ public:
/// @brief The UUID of the domain. Any domain can be uniquely identified by it's UUID.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// @brief Domain labels. A set of labels for this domain.
/// Vector of ns1__Label* with length 0..unbounded
    std::vector<ns1__Label*            > labels                         0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":DomainRef is a complexType.
/// @brief Domain. A domain is a way of organizing security policies relating to Context based classifications. A domain owns a set of document roles and context templates. The document roles are for use within this domain with. Each Context will have associated with it all or a sub-set of these roles for assignment to accounts. Context templates can be used to create Context classification instances with a well defined structure. e.g. defining which roles are available for use within a Context.
class ns6__DomainRef
{ public:
/// @brief The UUID of the domain. Any domain can be uniquely identified by it's UUID.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":DocumentRight is a complexType.
/// @brief Context classified document rights. A right is the outcome of assigning a Document Role to an Account. A right can also specify item restrictions specific to the account. To hinder attempts at password sharing, document role based rights that are served to the device and cannot be used until the rights are checked back in from the device (or the offline period expires).
class ns6__DocumentRight
{ public:
/// @brief Globally unique right Id. The UUID for a right can be used to uniquely identify the right. This UUID is allocated when a role is assigned to an account.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// @brief The account. The account that has been assigned the Document Role.
/// Element account of type "http://xmlns.oracle.com/irm/core":AccountRef.
    ns1__AccountRef*                     account                        1;	///< Required element.
/// @brief The role. The role assigned to the Account.
/// Element role of type "http://xmlns.oracle.com/irm/rights":DocumentRole.
    ns6__DocumentRole*                   role                           1;	///< Required element.
/// @brief Role assignment time. When the role was assigned to the account.
/// Element assignedTime of type xs:dateTime.
    time_t                               assignedTime                   1;	///< Required element.
/// @brief Item restrictions. Depending on what item restrictions the Document Role defines, this is the list of allowed or disallowed items.
/// Vector of ns5__ItemCode* with length 0..unbounded
    std::vector<ns5__ItemCode*         > itemCodes                      0;
/// @brief The related context. A role is assigned for use with a particular Context and only applies to documents classified against that Context.
/// Element context of type "http://xmlns.oracle.com/irm/rights":ContextInstanceRef.
    ns6__ContextInstanceRef*             context                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":DocumentRightRef is a complexType.
/// @brief Context classified document rights. A right is the outcome of assigning a Document Role to an Account. A right can also specify item restrictions specific to the account. To hinder attempts at password sharing, document role based rights that are served to the device and cannot be used until the rights are checked back in from the device (or the offline period expires).
class ns6__DocumentRightRef
{ public:
/// @brief Globally unique right Id. The UUID for a right can be used to uniquely identify the right. This UUID is allocated when a role is assigned to an account.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":AccountAlreadyAssignedFault is a complexType.
/// @brief Account already assigned a role. This exception is raised when an account already has a role assigned with a context.
class ns6__AccountAlreadyAssignedFault
{ public:
/// @brief The account.
/// Element account of type "http://xmlns.oracle.com/irm/core":AccountRef.
    ns1__AccountRef*                     account                        1;	///< Required element.
/// @brief The document role.
/// Element role of type "http://xmlns.oracle.com/irm/rights":DocumentRoleRef.
    ns6__DocumentRoleRef*                role                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":UnsupportedDocumentRoleFault is a complexType.
/// @brief Unsupported document role. When a role is assigned to an account (within a context) the context must allow the document role. This exception is thrown if the document role is not supported by the context.
class ns6__UnsupportedDocumentRoleFault
{ public:
/// @brief The invalid document role.
/// Element role of type "http://xmlns.oracle.com/irm/rights":DocumentRoleRef.
    ns6__DocumentRoleRef*                role                           1;	///< Required element.
/// @brief The context.
/// Element context of type "http://xmlns.oracle.com/irm/rights":ContextInstanceRef.
    ns6__ContextInstanceRef*             context                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":UnknownDocumentRoleFault is a complexType.
/// @brief Unknown document role. The document role does not exist, or has been deleted.
class ns6__UnknownDocumentRoleFault
{ public:
/// @brief The document role UUID.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// @brief The domain that owns that document role.
/// Element domain of type "http://xmlns.oracle.com/irm/rights":DomainRef.
    ns6__DomainRef*                      domain                         1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/rights":UnknownDocumentRightFault is a complexType.
/// @brief Unknown right. The right with the specified UUID does not exist. The right may have been unassigned.
class ns6__UnknownDocumentRightFault
{ public:
/// @brief The right UUID.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/******************************************************************************\
 *                                                                            *
 * Schema Complex Types and Top-Level Elements                                *
 *   http://xmlns.oracle.com/irm/rights/wsdl                                  *
 *                                                                            *
\******************************************************************************/



/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":AssignRole

/// "http://xmlns.oracle.com/irm/rights/wsdl":AssignRole is a complexType.
/// @brief Assign a document role. A document role can be assigned, within a context, to one or more accounts. An account can only have one role assigned within a Context. If any of the provided accounts already has the role assigned the account is silently ignored and the role is not re-assigned.
class _ns7__AssignRole
{ public:
/// @brief The context.
/// Element context of type "http://xmlns.oracle.com/irm/rights":ContextInstanceRef.
    ns6__ContextInstanceRef*             context                        1;	///< Required element.
/// @brief The role.
/// Element role of type "http://xmlns.oracle.com/irm/rights":DocumentRoleRef.
    ns6__DocumentRoleRef*                role                           1;	///< Required element.
/// @brief The accounts.
/// Vector of ns1__AccountRef* with length 0..unbounded
    std::vector<ns1__AccountRef*       > accounts                       0;
/// @brief Item restrictions. Can be empty.
/// Vector of ns5__ItemCode* with length 0..unbounded
    std::vector<ns5__ItemCode*         > items                          0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":AssignRoleResponse

/// "http://xmlns.oracle.com/irm/rights/wsdl":AssignRoleResponse is a complexType.
class _ns7__AssignRoleResponse
{ public:
/// @brief The assigned rights.
/// Vector of ns6__DocumentRight* with length 0..unbounded
    std::vector<ns6__DocumentRight*    > return_                        0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":ReassignRole

/// "http://xmlns.oracle.com/irm/rights/wsdl":ReassignRole is a complexType.
/// @brief Alter role assignments. Change the role assigned to an account. This also resets any item restrictions placed on the assigned right. As an account can only have one role assigned within a Context this method can be used to alter the role assignment without a two-step unassign right and assign role.
class _ns7__ReassignRole
{ public:
/// @brief The rights.
/// Vector of ns6__DocumentRightRef* with length 0..unbounded
    std::vector<ns6__DocumentRightRef* > rights                         0;
/// @brief The role.
/// Element role of type "http://xmlns.oracle.com/irm/rights":DocumentRoleRef.
    ns6__DocumentRoleRef*                role                           1;	///< Required element.
/// @brief Item restrictions. Can be empty.
/// Vector of ns5__ItemCode* with length 0..unbounded
    std::vector<ns5__ItemCode*         > items                          0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":ReassignRoleResponse

/// "http://xmlns.oracle.com/irm/rights/wsdl":ReassignRoleResponse is a complexType.
class _ns7__ReassignRoleResponse
{ public:
/// @brief The re-assigned rights.
/// Vector of ns6__DocumentRight* with length 0..unbounded
    std::vector<ns6__DocumentRight*    > return_                        0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":CheckInRightsForAccount

/// "http://xmlns.oracle.com/irm/rights/wsdl":CheckInRightsForAccount is a complexType.
/// @brief Check all rights in use by an account. If a user's device fails, or has issues with desktop installations, the rights that are in use can be force-ably checked in. This allows the account to request the rights on another device. If the account does not exist an empty collection is returned. The checked-in rights are restricted to the contexts that the caller is a context manager.
class _ns7__CheckInRightsForAccount
{ public:
/// @brief The account.
/// Element account of type "http://xmlns.oracle.com/irm/core":AccountRef.
    ns1__AccountRef*                     account                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":CheckInRightsForAccountResponse

/// "http://xmlns.oracle.com/irm/rights/wsdl":CheckInRightsForAccountResponse is a complexType.
class _ns7__CheckInRightsForAccountResponse
{ public:
/// @brief The rights that were in use by the specified account.
/// Vector of ns6__DocumentRight* with length 0..unbounded
    std::vector<ns6__DocumentRight*    > return_                        0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":SaveChangesToItems

/// "http://xmlns.oracle.com/irm/rights/wsdl":SaveChangesToItems is a complexType.
/// @brief Alter the item restrictions for a set of rights. Alter the item restrictions on one or more Document Right. Changes are made to the list of item restrictions by comparing the two copies of the item codes provided and either removing or adding item restrictions by looking at the delta. For example if the delta (as compared to the first list of items) contains additional Item Code instances then new items will be added to the rights. However, if the delta (as compared to the first list of items) does not contain an Item Code instance then the items will be removed from the rights.
class _ns7__SaveChangesToItems
{ public:
/// @brief The rights to alter.
/// Vector of ns6__DocumentRightRef* with length 0..unbounded
    std::vector<ns6__DocumentRightRef* > rights                         0;
/// @brief The item codes.
/// Vector of ns5__ItemCode* with length 0..unbounded
    std::vector<ns5__ItemCode*         > itemCodes                      0;
/// @brief The changes.
/// Vector of ns5__ItemCode* with length 0..unbounded
    std::vector<ns5__ItemCode*         > delta                          0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":SaveChangesToItemsResponse

/// "http://xmlns.oracle.com/irm/rights/wsdl":SaveChangesToItemsResponse is a complexType.
class _ns7__SaveChangesToItemsResponse
{ public:
/// @brief The altered rights.
/// Vector of ns6__DocumentRight* with length 0..unbounded
    std::vector<ns6__DocumentRight*    > return_                        0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":UnassignRights

/// "http://xmlns.oracle.com/irm/rights/wsdl":UnassignRights is a complexType.
/// @brief Un-assign a set of rights. If the right has already been unassigned this method will not report an error.
class _ns7__UnassignRights
{ public:
/// @brief The rights to un-assign.
/// Vector of ns6__DocumentRightRef* with length 0..unbounded
    std::vector<ns6__DocumentRightRef* > rights                         0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":UnassignRightsResponse

/// "http://xmlns.oracle.com/irm/rights/wsdl":UnassignRightsResponse is a complexType.
class _ns7__UnassignRightsResponse
{ public:
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":ListRightsByContext

/// "http://xmlns.oracle.com/irm/rights/wsdl":ListRightsByContext is a complexType.
/// @brief List rights assigned within a context. This method lists rights assigned within a context, ordered by the date the role was assigned (most recent rights first). If large numbers of rights are assigned the page range parameter can be used to retrieve the rights in smaller chunks.
class _ns7__ListRightsByContext
{ public:
/// @brief The context.
/// Element context of type "http://xmlns.oracle.com/irm/rights":ContextInstanceRef.
    ns6__ContextInstanceRef*             context                        1;	///< Required element.
/// @brief Page range for the search result.
/// Element pageRange of type "http://xmlns.oracle.com/irm/core":PageRange.
    ns1__PageRange*                      pageRange                      1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":ListRightsByContextResponse

/// "http://xmlns.oracle.com/irm/rights/wsdl":ListRightsByContextResponse is a complexType.
class _ns7__ListRightsByContextResponse
{ public:
/// @brief The list of rights or an empty collection if the context does not have any document rights.
/// Vector of ns6__DocumentRight* with length 0..unbounded
    std::vector<ns6__DocumentRight*    > return_                        0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":ListRightsByAccount

/// "http://xmlns.oracle.com/irm/rights/wsdl":ListRightsByAccount is a complexType.
/// @brief List rights for an account. Rights listed for an account include rights obtained indirectly through group membership. If the account does not exist an empty collection is returned. Only rights that the caller is allowed to view will be returned. The caller can view rights if they are a context manager or inspector (for the related context).
class _ns7__ListRightsByAccount
{ public:
/// @brief The account.
/// Element account of type "http://xmlns.oracle.com/irm/core":AccountRef.
    ns1__AccountRef*                     account                        1;	///< Required element.
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":ListRightsByAccountResponse

/// "http://xmlns.oracle.com/irm/rights/wsdl":ListRightsByAccountResponse is a complexType.
class _ns7__ListRightsByAccountResponse
{ public:
/// @brief The list of rights or an empty collection if the account does not have any document rights.
/// Vector of ns6__DocumentRight* with length 0..unbounded
    std::vector<ns6__DocumentRight*    > return_                        0;
/// A handle to the soap struct that manages this instance (automatically set)
    struct soap                         *soap                          ;
};

/// "http://xmlns.oracle.com/irm/core":DesktopKeySetExtensions is a complexType with complexContent extension of "http://xmlns.oracle.com/irm/content":KeySetExtensions.
/// @brief Desktop key exchange content and signing keys. Desktop key set extensions can be used to associate a set of encrypted symmetric keys with a key set for use in exchanging keys in a Desktop Bundle.
class ns1__DesktopKeySetExtensions : public ns2__KeySetExtensions
{ public:
/*  INHERITED FROM ns2__KeySetExtensions:
    END OF INHERITED */
/// @brief A token provided by the recipient of the key set. This token can be used to identify what public key (or keys) was used to encrypt the key set.
/// Element identityToken of type xs:string.
    std::string                          identityToken                  1;	///< Required element.
/// @brief The content key in encrypted form.
/// Element encryptedContentKey of type xs:base64Binary.
    xsd__base64Binary                    encryptedContentKey            1;	///< Required element.
/// @brief The signing key in encrypted form.
/// Element encryptedSigningKey of type xs:base64Binary.
    xsd__base64Binary                    encryptedSigningKey            1;	///< Required element.
};

/// "http://xmlns.oracle.com/irm/core":RelativeTimeSpan is a complexType with complexContent extension of "http://xmlns.oracle.com/irm/core":TimeSpan.
/// @brief A relative time span. A relative time span defines a start time and stop time that is relative to an absolute point in time.
class ns1__RelativeTimeSpan : public ns1__TimeSpan
{ public:
/*  INHERITED FROM ns1__TimeSpan:
/// @brief The reference point for a time span.
/// Element referencePoint of type "http://xmlns.oracle.com/irm/core":TimeSpan_ReferencePoint.
    enum ns1__TimeSpan_USCOREReferencePoint  referencePoint                 1;	///< Required element.
    END OF INHERITED */
/// @brief The relative time base. The time base value determines that absolute time the relative time span refers. e.g. For one month after the classification was applied compared to current time.
/// Element timeBase of type "http://xmlns.oracle.com/irm/core":RelativeTimeSpan_TimeBase.
    enum ns1__RelativeTimeSpan_USCORETimeBase  timeBase                       1;	///< Required element.
/// @brief Start time for the time span. For a time span that just has a stop time this property can be left un-set.
/// Element startTime of type "http://xmlns.oracle.com/irm/core":TimePeriod.
    ns1__TimePeriod*                     startTime                      0;	///< Optional element.
/// @brief Stop time for the time span. For an open ended time span this property can be left un-set.
/// Element stopTime of type "http://xmlns.oracle.com/irm/core":TimePeriod.
    ns1__TimePeriod*                     stopTime                       0;	///< Optional element.
};

/// "http://xmlns.oracle.com/irm/core":AbsoluteTimeSpan is a complexType with complexContent extension of "http://xmlns.oracle.com/irm/core":TimeSpan.
/// @brief An absolute time span. An absolute time span defines a period of time bounded by a start and stop time.
class ns1__AbsoluteTimeSpan : public ns1__TimeSpan
{ public:
/*  INHERITED FROM ns1__TimeSpan:
/// @brief The reference point for a time span.
/// Element referencePoint of type "http://xmlns.oracle.com/irm/core":TimeSpan_ReferencePoint.
    enum ns1__TimeSpan_USCOREReferencePoint  referencePoint                 1;	///< Required element.
    END OF INHERITED */
/// @brief Start time for the time span. For a time span that just has a stop time this property can be left un-set.
/// Element startTime of type xs:dateTime.
    time_t*                              startTime                      0;	///< Optional element.
/// @brief Stop time for the time span. For an open ended time span this property can be left un-set.
/// Element stopTime of type xs:dateTime.
    time_t*                              stopTime                       0;	///< Optional element.
};

/// "http://xmlns.oracle.com/irm/core":XPathClassificationFilter is a complexType with complexContent extension of "http://xmlns.oracle.com/irm/core":ClassificationFilter.
/// @brief An XPath based classification filter. An XPath classification filter uses a boolean XPath expression to filter out applicable classifications. The classification Cookie is transformed into an XML document and then compared against the boolean XPath expression. This can be used as a generic way of filtering out Classification instances by running an expression against the XML based cookie. For example, the context classification system uses an XPath that matches on the Context UUID. e.g. the following XPath expression would match all sealed content that had a context cookie with a context UUID of 37bbe0fa-9eb4-462e-85b6-9796610f1b20. context:ContextCookie/context[uuid='37bbe0fa-9eb4-462e-85b6-9796610f1b20'].
class ns1__XPathClassificationFilter : public ns1__ClassificationFilter
{ public:
/*  INHERITED FROM ns1__ClassificationFilter:
/// @brief The classification system. This classification system must match the System of the classification for this filter to match.
/// Element system of type "http://xmlns.oracle.com/irm/core":ClassificationSystemRef.
    ns1__ClassificationSystemRef*        system                         1;	///< Required element.
/// @brief Server URI. A Classification contains a URI and it is this URI that is used to contact a server to obtain licenses and keys. A classification filter will only match a Classification that exactly matches on URI value.
/// Element uri of type xs:anyURI.
    xsd__anyURI                          uri                            1;	///< Required element.
/// @brief Classification filter index. The main use of a classification filter is to link a license with a set of content. When sealed content is opened the Classification is extracted from the public header and checked against a set of available licenses. If the set of licenses being searched is large this process can take a long time. Each license is asked are you applicable to this classification? The search time linearly increases with the number of licenses. To improve performance during such scenarios an optional index can be provided on the classification filter. When licenses are stored they can be indexed with the index value and searches can be optimized by matching related licenses. The index lookup value is extracted from the classification Cookie using a special Content Attribute. This index content attribute is used to extract the textual value from the Classification that can be used to look up the set of licenses related to the content. The index content attribute is classification system specific. If no index content attribute is available or no classification index provided then the classification filter must be compared against all licenses that match the same URI (same server) and classification system as the content.
/// Element index of type xs:string.
    std::string*                         index                          0;	///< Optional element.
    END OF INHERITED */
/// @brief The XPath expression. The results of this expression are evaluated as be a boolean value.
/// Element expression of type "http://xmlns.oracle.com/irm/core":XPathExpression.
    ns1__XPathExpression*                expression                     1;	///< Required element.
};

/// "http://xmlns.oracle.com/irm/content":RawKeySetExtensions is a complexType with complexContent extension of "http://xmlns.oracle.com/irm/content":KeySetExtensions.
/// @brief Raw content encryption and signing keys. A raw key set extensions can be used to associate a raw set of symmetric keys with a key set. Useful in the key set information needs to be serialized out, say in XML, in a unprotected form (the keys are in the clear).
class ns2__RawKeySetExtensions : public ns2__KeySetExtensions
{ public:
/*  INHERITED FROM ns2__KeySetExtensions:
    END OF INHERITED */
/// @brief Content encryption key.
/// Element encryptionKey of type xs:base64Binary.
    xsd__base64Binary                    encryptionKey                  1;	///< Required element.
/// @brief Signing key.
/// Element signingKey of type xs:base64Binary.
    xsd__base64Binary                    signingKey                     1;	///< Required element.
};

/// "http://xmlns.oracle.com/irm/content":WrappedKeySetExtensions is a complexType with complexContent extension of "http://xmlns.oracle.com/irm/content":KeySetExtensions.
/// @brief Wrapped content encryption and signing keys. A wrapped key set extensions can be used to associate a wrapped set of symmetric keys with a key set. Useful in the key set information needs to be serialized out, say in XML, in a safe form.
class ns2__WrappedKeySetExtensions : public ns2__KeySetExtensions
{ public:
/*  INHERITED FROM ns2__KeySetExtensions:
    END OF INHERITED */
/// @brief The key alias used to wrap these keys.
/// Element alias of type xs:string.
    std::string                          alias                          1;	///< Required element.
/// @brief Wrapped content encryption key.
/// Element encryptionKey of type xs:base64Binary.
    xsd__base64Binary                    encryptionKey                  1;	///< Required element.
/// @brief Wrapped signing key.
/// Element signingKey of type xs:base64Binary.
    xsd__base64Binary                    signingKey                     1;	///< Required element.
};

/// "http://xmlns.oracle.com/irm/rights":ContextInstance is a complexType with complexContent extension of "http://xmlns.oracle.com/irm/classifications":Context.
/// @brief A context created from a template. A Context created from Context Template has a number of additional properties relating to Domain administration and Item Code usage.
class ns6__ContextInstance : public ns5__Context
{ public:
/*  INHERITED FROM ns5__Context:
/// @brief Context UUID. A globally unique UUID for the context.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
    END OF INHERITED */
/// @brief Labels for the context. A context must have at least one name and description for the default language. Alternative names and descriptions can be provided for localized languages.
/// Vector of ns1__Label* with length 0..unbounded
    std::vector<ns1__Label*            > labels                         0;
/// @brief Context level item exclusions. Document related rights can include individual account based Item Code inclusions and exclusions. However, if a document is accidently released and needs to be excluded for all accounts, Context level item exclusions can be used.
/// Vector of ns5__ItemCode* with length 0..unbounded
    std::vector<ns5__ItemCode*         > items                          0;
/// @brief Trusted contexts. The list of contexts that can be used for resealing. i.e. the list of contexts that can be specified as the destination classification when resealing content sealed to this context.
/// Vector of ns6__ContextInstanceRef* with length 0..unbounded
    std::vector<ns6__ContextInstanceRef*> trustedContexts                0;
/// @brief Context visibility. Inspectors are able to view all Context instances and examine details such as account rights. Context can be hidden from inspectors. e.g. if the Context was for mergers and acquisitions it may need to be hidden from domain level inspectors. The default is that a Context is visible to domain level users such as inspectors.
/// Element visibility of type "http://xmlns.oracle.com/irm/rights":ContextInstance_Visibility.
    enum ns6__ContextInstance_USCOREVisibility  visibility                     1;	///< Required element.
/// @brief The context template. This property represents the relationship between the context and the context template. This relationship is set when the context is created.
/// Element template of type "http://xmlns.oracle.com/irm/rights":ContextTemplateRef.
    ns6__ContextTemplateRef*             template_                      1;	///< Required element.
};

/// "http://xmlns.oracle.com/irm/rights":ContextInstanceRef is a complexType with complexContent extension of "http://xmlns.oracle.com/irm/classifications":ContextRef.
/// @brief A context created from a template. A Context created from Context Template has a number of additional properties relating to Domain administration and Item Code usage.
class ns6__ContextInstanceRef : public ns5__ContextRef
{ public:
/*  INHERITED FROM ns5__ContextRef:
/// @brief Context UUID. A globally unique UUID for the context.
/// Element uuid of type xs:string.
    std::string                          uuid                           1;	///< Required element.
    END OF INHERITED */
};

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://xmlns.oracle.com/irm/core                                         *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://xmlns.oracle.com/irm/core                                         *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://xmlns.oracle.com/irm/content                                      *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://xmlns.oracle.com/irm/content                                      *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://xmlns.oracle.com/irm/system                                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://xmlns.oracle.com/irm/system                                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://xmlns.oracle.com/irm/content/wsdl                                 *
 *                                                                            *
\******************************************************************************/


/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":UnsupportedContentTypeFault of type "http://xmlns.oracle.com/irm/content":UnsupportedContentTypeFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":IllegalEncryptedContentBlockSizeFault of type "http://xmlns.oracle.com/irm/content":IllegalEncryptedContentBlockSizeFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":PublicHeaderLengthFault of type "http://xmlns.oracle.com/irm/content":PublicHeaderLengthFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":AuthorizationDeniedFault of type "http://xmlns.oracle.com/irm/system":AuthorizationDeniedFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://xmlns.oracle.com/irm/content/wsdl":ContentParseFault of type "http://xmlns.oracle.com/irm/content":ContentParseFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://xmlns.oracle.com/irm/content/wsdl                                 *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://xmlns.oracle.com/irm/classifications                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://xmlns.oracle.com/irm/classifications                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://xmlns.oracle.com/irm/rights                                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://xmlns.oracle.com/irm/rights                                       *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Elements                                              *
 *   http://xmlns.oracle.com/irm/rights/wsdl                                  *
 *                                                                            *
\******************************************************************************/


/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":AccountAlreadyAssignedFault of type "http://xmlns.oracle.com/irm/rights":AccountAlreadyAssignedFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":UnsupportedDocumentRoleFault of type "http://xmlns.oracle.com/irm/rights":UnsupportedDocumentRoleFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":UnknownContextFault of type "http://xmlns.oracle.com/irm/classifications":UnknownContextFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":UnknownDocumentRoleFault of type "http://xmlns.oracle.com/irm/rights":UnknownDocumentRoleFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":AuthorizationDeniedFault of type "http://xmlns.oracle.com/irm/system":AuthorizationDeniedFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/// Top-level root element "http://xmlns.oracle.com/irm/rights/wsdl":UnknownDocumentRightFault of type "http://xmlns.oracle.com/irm/rights":UnknownDocumentRightFault.
/// Note: use wsdl2h option -g to auto-generate a top-level root element declaration and processing code.

/******************************************************************************\
 *                                                                            *
 * Additional Top-Level Attributes                                            *
 *   http://xmlns.oracle.com/irm/rights/wsdl                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Services                                                                   *
 *                                                                            *
\******************************************************************************/


//gsoap ns4  service name:	SealingServicesBinding 
//gsoap ns4  service type:	SealingServices 
//gsoap ns4  service port:	http://ium-vbox-win2k8:16100/irm_sealing/sealing_services 
//gsoap ns4  service namespace:	http://xmlns.oracle.com/irm/content/wsdl 
//gsoap ns4  service transport:	http://schemas.xmlsoap.org/soap/http 

//gsoap ns7  service name:	DocumentRightOperationsBinding 
//gsoap ns7  service type:	DocumentRightOperations 
//gsoap ns7  service port:	http://ium-vbox-win2k8:16100/irm_services/document_right_operations 
//gsoap ns7  service namespace:	http://xmlns.oracle.com/irm/rights/wsdl 
//gsoap ns7  service transport:	http://schemas.xmlsoap.org/soap/http 

/** @mainpage Service Definitions

@section Service_bindings Service Bindings
  - @ref SealingServicesBinding
  - @ref DocumentRightOperationsBinding

@section Service_more More Information
- @ref page_notes "Notes"
- @ref page_XMLDataBinding "XML Data Binding"
- @ref SOAP_ENV__Header "SOAP Header Content"
- @ref SOAP_ENV__Detail "SOAP Fault Detail Content" (when applicable)


*/

/**

@page SealingServicesBinding Binding "SealingServicesBinding"

@section SealingServicesService_service Service Documentation "SealingServicesService"

            Sealing, unsealing, resealing and peeking services for content. Sealing is the process of taking unprotected content, encrypting it and adding in meta data called a classification. Unsealing is the term used when sealed content is decrypted. Resealing is the term used when altering the sealed content meta data or classification. Peeking is the term given to the process of extracting meta data from sealed content without decrypting the content. The methods on the sealing services are designed to used remotely, where the content is sent to a server, processes and the results returned to the client. The sealing services support the MTOM (Message Transmission Optimization Mechanism) feature. This allows the services to transfer the binary sealed and unsealed content in the most optimal form available. When sending content to using the sealing services it is recommended to enable MTOM in the client web service stack.
        

@section SealingServicesBinding_operations Operations of Binding  "SealingServicesBinding"
  - @ref __ns4__Seal
  - @ref __ns4__Unseal
  - @ref __ns4__Reseal
  - @ref __ns4__Reclassify
  - @ref __ns4__Peek
  - @ref __ns4__ValidatedPeek

@section SealingServicesBinding_ports Endpoints of Binding  "SealingServicesBinding"
  - http://ium-vbox-win2k8:16100/irm_sealing/sealing_services

Note: use wsdl2h option -N to change the service binding prefix name

*/

/**

@page DocumentRightOperationsBinding Binding "DocumentRightOperationsBinding"

@section DocumentRightOperationsService_service Service Documentation "DocumentRightOperationsService"

            Document right operations. Document right operations include checking in rights, altering item restrictions, listing rights and checking items across sets of rights.
        

@section DocumentRightOperationsBinding_operations Operations of Binding  "DocumentRightOperationsBinding"
  - @ref __ns7__AssignRole
  - @ref __ns7__ReassignRole
  - @ref __ns7__CheckInRightsForAccount
  - @ref __ns7__SaveChangesToItems
  - @ref __ns7__UnassignRights
  - @ref __ns7__ListRightsByContext
  - @ref __ns7__ListRightsByAccount

@section DocumentRightOperationsBinding_ports Endpoints of Binding  "DocumentRightOperationsBinding"
  - http://ium-vbox-win2k8:16100/irm_services/document_right_operations

Note: use wsdl2h option -N to change the service binding prefix name

*/

/******************************************************************************\
 *                                                                            *
 * SOAP Fault Detail                                                          *
 *                                                                            *
\******************************************************************************/

/**

The SOAP Fault is part of the gSOAP context and its content is accessed
through the soap.fault->detail variable (SOAP 1.1) or the
soap.fault->SOAP_ENV__Detail variable (SOAP 1.2).
Use option -j to omit.

*/
struct SOAP_ENV__Detail
{
// xsd:anyAttribute omitted: to parse attribute content of the Detail element into DOM anyAttribute, use wsdl2h option -d.
    ns3__AuthorizationDeniedFault*       ns4__AuthorizationDeniedFault ;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/content/wsdl":AuthorizationDeniedFault" part "fault"
    ns2__ContentParseFault*              ns4__ContentParseFault        ;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/content/wsdl":ContentParseFault" part "fault"
    ns2__IllegalEncryptedContentBlockSizeFault*  ns4__IllegalEncryptedContentBlockSizeFault;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/content/wsdl":IllegalEncryptedContentBlockSizeFault" part "fault"
    ns2__PublicHeaderLengthFault*        ns4__PublicHeaderLengthFault  ;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/content/wsdl":PublicHeaderLengthFault" part "fault"
    ns2__UnsupportedContentTypeFault*    ns4__UnsupportedContentTypeFault;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/content/wsdl":UnsupportedContentTypeFault" part "fault"
    ns6__AccountAlreadyAssignedFault*    ns7__AccountAlreadyAssignedFault;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/rights/wsdl":AccountAlreadyAssignedFault" part "fault"
    ns3__AuthorizationDeniedFault*       ns7__AuthorizationDeniedFault ;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/rights/wsdl":AuthorizationDeniedFault" part "fault"
    ns5__UnknownContextFault*            ns7__UnknownContextFault      ;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/rights/wsdl":UnknownContextFault" part "fault"
    ns6__UnknownDocumentRightFault*      ns7__UnknownDocumentRightFault;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/rights/wsdl":UnknownDocumentRightFault" part "fault"
    ns6__UnknownDocumentRoleFault*       ns7__UnknownDocumentRoleFault ;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/rights/wsdl":UnknownDocumentRoleFault" part "fault"
    ns6__UnsupportedDocumentRoleFault*   ns7__UnsupportedDocumentRoleFault;
///< SOAP Fault element ""http://xmlns.oracle.com/irm/rights/wsdl":UnsupportedDocumentRoleFault" part "fault"
    int                                  __type                        ;	///< set to SOAP_TYPE_X for a serializable type X
    void                                *fault                         ;	///< points to serializable object X or NULL
    _XML                                 __any                         ;	///< Catch any element content in XML string.
};

/******************************************************************************\
 *                                                                            *
 * Service Binding                                                            *
 *   SealingServicesBinding                                                   *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns4__Seal                                                              *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns4__Seal" of service binding "SealingServicesBinding"

/**

Operation details:


                Seal content. Sealing is the process of taking plaintext content, encrypting and signing the content with an associated Classification. If the classification provided is a context classification system classification, this method will provide an automatic Item Code if one is not specified in the classification details. To perform a sealing operation the authenticated user must have the rights to seal content for the specified classification. Sealing is authorized if the authenticated user has a license that allows the oracle.irm.generic.Seal Feature for the Classification specified in the sealing options.
            
  - SOAP document/literal style
  - SOAP action="urn:SealingServices#Seal"
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":UnsupportedContentTypeFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":IllegalEncryptedContentBlockSizeFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":PublicHeaderLengthFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns4__Seal(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns4__Seal*                         ns4__Seal,
    // response parameters:
    _ns4__SealResponse*                 ns4__SealResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns4__Seal(
    struct soap *soap,
    // request parameters:
    _ns4__Seal*                         ns4__Seal,
    // response parameters:
    _ns4__SealResponse*                 ns4__SealResponse
  );
@endcode

C++ proxy class (defined in soapSealingServicesBindingProxy.h):
@code
  class SealingServicesBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapSealingServicesBindingService.h):
@code
  class SealingServicesBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns4  service method-style:	Seal document
//gsoap ns4  service method-encoding:	Seal literal
//gsoap ns4  service method-action:	Seal urn:SealingServices#Seal
//gsoap ns4  service method-fault:	Seal ns4__UnsupportedContentTypeFault
//gsoap ns4  service method-fault:	Seal ns4__IllegalEncryptedContentBlockSizeFault
//gsoap ns4  service method-fault:	Seal ns4__PublicHeaderLengthFault
//gsoap ns4  service method-fault:	Seal ns4__AuthorizationDeniedFault
int __ns4__Seal(
    _ns4__Seal*                         ns4__Seal,	///< Request parameter
    _ns4__SealResponse*                 ns4__SealResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns4__Unseal                                                            *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns4__Unseal" of service binding "SealingServicesBinding"

/**

Operation details:


                Unseal a stream into an output stream. Unsealing is the process of taking sealed content, de-crypting it and returning the original unsealed content. To perform an unsealing operation the authenticated user must have the rights to unseal content. Unsealing is allowed if the authenticated user has a license that allows the oracle.irm.generic.SaveUnsealed Feature for the content's Classification.
            
  - SOAP document/literal style
  - SOAP action="urn:SealingServices#Unseal"
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":ContentParseFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns4__Unseal(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns4__Unseal*                       ns4__Unseal,
    // response parameters:
    _ns4__UnsealResponse*               ns4__UnsealResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns4__Unseal(
    struct soap *soap,
    // request parameters:
    _ns4__Unseal*                       ns4__Unseal,
    // response parameters:
    _ns4__UnsealResponse*               ns4__UnsealResponse
  );
@endcode

C++ proxy class (defined in soapSealingServicesBindingProxy.h):
@code
  class SealingServicesBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapSealingServicesBindingService.h):
@code
  class SealingServicesBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns4  service method-style:	Unseal document
//gsoap ns4  service method-encoding:	Unseal literal
//gsoap ns4  service method-action:	Unseal urn:SealingServices#Unseal
//gsoap ns4  service method-fault:	Unseal ns4__ContentParseFault
//gsoap ns4  service method-fault:	Unseal ns4__AuthorizationDeniedFault
int __ns4__Unseal(
    _ns4__Unseal*                       ns4__Unseal,	///< Request parameter
    _ns4__UnsealResponse*               ns4__UnsealResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns4__Reseal                                                            *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns4__Reseal" of service binding "SealingServicesBinding"

/**

Operation details:


                Reseal content with new custom data. Resealing is the process of altering the data or meta-data in sealed content. This method allows the custom data portion of the meta data to be replaced. To perform a resealing operation the authenticated user must have the rights to reseal the content. Resealing is allowed if the authenticated user has a valid license that has the oracle.irm.generic.Reseal Feature for the content's Classification.
            
  - SOAP document/literal style
  - SOAP action="urn:SealingServices#Reseal"
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":ContentParseFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns4__Reseal(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns4__Reseal*                       ns4__Reseal,
    // response parameters:
    _ns4__ResealResponse*               ns4__ResealResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns4__Reseal(
    struct soap *soap,
    // request parameters:
    _ns4__Reseal*                       ns4__Reseal,
    // response parameters:
    _ns4__ResealResponse*               ns4__ResealResponse
  );
@endcode

C++ proxy class (defined in soapSealingServicesBindingProxy.h):
@code
  class SealingServicesBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapSealingServicesBindingService.h):
@code
  class SealingServicesBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns4  service method-style:	Reseal document
//gsoap ns4  service method-encoding:	Reseal literal
//gsoap ns4  service method-action:	Reseal urn:SealingServices#Reseal
//gsoap ns4  service method-fault:	Reseal ns4__ContentParseFault
//gsoap ns4  service method-fault:	Reseal ns4__AuthorizationDeniedFault
int __ns4__Reseal(
    _ns4__Reseal*                       ns4__Reseal,	///< Request parameter
    _ns4__ResealResponse*               ns4__ResealResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns4__Reclassify                                                        *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns4__Reclassify" of service binding "SealingServicesBinding"

/**

Operation details:


                Re-classify sealed content. Re-classification is the process of altering the Classification of the sealed content without having to perform a two step unseal and seal. During re-classification the content is re-encrypted and re-signed. If the classification labels or key set are not provided then the sealing process will attempt to fill in these details. If no labels are provided in the classification the labels are filled in automatically. Labels can only be filled in if provided classification Id matches the classification returned by the server. If no key set is provided then the key set is filled in from the license used to perform the sealing operation. If the license specifies multiple key sets then the first key set in the license is used. To perform a resealing operation the authenticated user must have a license for both the source classification and the target classification. The source classification license must allow the oracle.irm.generic.CopyTo or oracle.irm.generic.SaveUnsealed Feature. The target classification license must allow the oracle.irm.generic.Seal feature. If the source license has a copy to feature the transformation is only permitted if target classification is allowed by the trusted Destinations of the source classification license. If the source license has a save unsealed feature then there are no restrictions on the target classification.
            
  - SOAP document/literal style
  - SOAP action="urn:SealingServices#Reclassify"
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":ContentParseFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns4__Reclassify(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns4__Reclassify*                   ns4__Reclassify,
    // response parameters:
    _ns4__ReclassifyResponse*           ns4__ReclassifyResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns4__Reclassify(
    struct soap *soap,
    // request parameters:
    _ns4__Reclassify*                   ns4__Reclassify,
    // response parameters:
    _ns4__ReclassifyResponse*           ns4__ReclassifyResponse
  );
@endcode

C++ proxy class (defined in soapSealingServicesBindingProxy.h):
@code
  class SealingServicesBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapSealingServicesBindingService.h):
@code
  class SealingServicesBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns4  service method-style:	Reclassify document
//gsoap ns4  service method-encoding:	Reclassify literal
//gsoap ns4  service method-action:	Reclassify urn:SealingServices#Reclassify
//gsoap ns4  service method-fault:	Reclassify ns4__ContentParseFault
//gsoap ns4  service method-fault:	Reclassify ns4__AuthorizationDeniedFault
int __ns4__Reclassify(
    _ns4__Reclassify*                   ns4__Reclassify,	///< Request parameter
    _ns4__ReclassifyResponse*           ns4__ReclassifyResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns4__Peek                                                              *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns4__Peek" of service binding "SealingServicesBinding"

/**

Operation details:


                Peek sealed content. Peeking is the process of extracting the meta-data added to sealed content. This variant does not attempt to check the public header against its declared signature. If the meta-data has been altered post-sealing this method will not throw an exception. Any sealed content can be peek, the authenticated account does not require a license for the content's classification. This meta-data includes the Classification as well as information such as the Creation Time. The peeking process only examines the start of the sealed content. If a file is large it is not necessary to send the complete content, just the start of the file that contains the public header XML. This can improve performance when peeking large files.
            
  - SOAP document/literal style
  - SOAP action="urn:SealingServices#Peek"
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":ContentParseFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns4__Peek(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns4__Peek*                         ns4__Peek,
    // response parameters:
    _ns4__PeekResponse*                 ns4__PeekResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns4__Peek(
    struct soap *soap,
    // request parameters:
    _ns4__Peek*                         ns4__Peek,
    // response parameters:
    _ns4__PeekResponse*                 ns4__PeekResponse
  );
@endcode

C++ proxy class (defined in soapSealingServicesBindingProxy.h):
@code
  class SealingServicesBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapSealingServicesBindingService.h):
@code
  class SealingServicesBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns4  service method-style:	Peek document
//gsoap ns4  service method-encoding:	Peek literal
//gsoap ns4  service method-action:	Peek urn:SealingServices#Peek
//gsoap ns4  service method-fault:	Peek ns4__ContentParseFault
int __ns4__Peek(
    _ns4__Peek*                         ns4__Peek,	///< Request parameter
    _ns4__PeekResponse*                 ns4__PeekResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns4__ValidatedPeek                                                     *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns4__ValidatedPeek" of service binding "SealingServicesBinding"

/**

Operation details:


                Peek sealed content (with validation of the signature). Peeking is the process of extracting the meta-data added to sealed content. This variant attempts to check the public header against its declared signature. If the public header meta-data has been altered post sealing this method will throw an exception. A validated peek is allowed if the authenticated user has a license that has the open Feature for the content's Classification. The peeking process only examines the start of the sealed content. If a file is large it is not necessary to send the complete content, just the start of the file that contains the public header XML and signature. This can improve performance when peeking large files.
            
  - SOAP document/literal style
  - SOAP action="urn:SealingServices#ValidatedPeek"
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":ContentParseFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/content/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns4__ValidatedPeek(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns4__ValidatedPeek*                ns4__ValidatedPeek,
    // response parameters:
    _ns4__ValidatedPeekResponse*        ns4__ValidatedPeekResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns4__ValidatedPeek(
    struct soap *soap,
    // request parameters:
    _ns4__ValidatedPeek*                ns4__ValidatedPeek,
    // response parameters:
    _ns4__ValidatedPeekResponse*        ns4__ValidatedPeekResponse
  );
@endcode

C++ proxy class (defined in soapSealingServicesBindingProxy.h):
@code
  class SealingServicesBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapSealingServicesBindingService.h):
@code
  class SealingServicesBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns4  service method-style:	ValidatedPeek document
//gsoap ns4  service method-encoding:	ValidatedPeek literal
//gsoap ns4  service method-action:	ValidatedPeek urn:SealingServices#ValidatedPeek
//gsoap ns4  service method-fault:	ValidatedPeek ns4__ContentParseFault
//gsoap ns4  service method-fault:	ValidatedPeek ns4__AuthorizationDeniedFault
int __ns4__ValidatedPeek(
    _ns4__ValidatedPeek*                ns4__ValidatedPeek,	///< Request parameter
    _ns4__ValidatedPeekResponse*        ns4__ValidatedPeekResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Binding                                                            *
 *   DocumentRightOperationsBinding                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns7__AssignRole                                                        *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns7__AssignRole" of service binding "DocumentRightOperationsBinding"

/**

Operation details:


                Assign a document role. A document role can be assigned, within a context, to one or more accounts. An account can only have one role assigned within a Context. If any of the provided accounts already has the role assigned the account is silently ignored and the role is not re-assigned.
            
  - SOAP document/literal style
  - SOAP action="urn:DocumentRightOperations#AssignRole"
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":AccountAlreadyAssignedFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":UnsupportedDocumentRoleFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":UnknownContextFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":UnknownDocumentRoleFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns7__AssignRole(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns7__AssignRole*                   ns7__AssignRole,
    // response parameters:
    _ns7__AssignRoleResponse*           ns7__AssignRoleResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns7__AssignRole(
    struct soap *soap,
    // request parameters:
    _ns7__AssignRole*                   ns7__AssignRole,
    // response parameters:
    _ns7__AssignRoleResponse*           ns7__AssignRoleResponse
  );
@endcode

C++ proxy class (defined in soapDocumentRightOperationsBindingProxy.h):
@code
  class DocumentRightOperationsBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapDocumentRightOperationsBindingService.h):
@code
  class DocumentRightOperationsBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns7  service method-style:	AssignRole document
//gsoap ns7  service method-encoding:	AssignRole literal
//gsoap ns7  service method-action:	AssignRole urn:DocumentRightOperations#AssignRole
//gsoap ns7  service method-fault:	AssignRole ns7__AccountAlreadyAssignedFault
//gsoap ns7  service method-fault:	AssignRole ns7__UnsupportedDocumentRoleFault
//gsoap ns7  service method-fault:	AssignRole ns7__UnknownContextFault
//gsoap ns7  service method-fault:	AssignRole ns7__UnknownDocumentRoleFault
//gsoap ns7  service method-fault:	AssignRole ns7__AuthorizationDeniedFault
int __ns7__AssignRole(
    _ns7__AssignRole*                   ns7__AssignRole,	///< Request parameter
    _ns7__AssignRoleResponse*           ns7__AssignRoleResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns7__ReassignRole                                                      *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns7__ReassignRole" of service binding "DocumentRightOperationsBinding"

/**

Operation details:


                Alter role assignments. Change the role assigned to an account. This also resets any item restrictions placed on the assigned right. As an account can only have one role assigned within a Context this method can be used to alter the role assignment without a two-step unassign right and assign role.
            
  - SOAP document/literal style
  - SOAP action="urn:DocumentRightOperations#ReassignRole"
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":UnsupportedDocumentRoleFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":UnknownDocumentRoleFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":UnknownDocumentRightFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns7__ReassignRole(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns7__ReassignRole*                 ns7__ReassignRole,
    // response parameters:
    _ns7__ReassignRoleResponse*         ns7__ReassignRoleResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns7__ReassignRole(
    struct soap *soap,
    // request parameters:
    _ns7__ReassignRole*                 ns7__ReassignRole,
    // response parameters:
    _ns7__ReassignRoleResponse*         ns7__ReassignRoleResponse
  );
@endcode

C++ proxy class (defined in soapDocumentRightOperationsBindingProxy.h):
@code
  class DocumentRightOperationsBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapDocumentRightOperationsBindingService.h):
@code
  class DocumentRightOperationsBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns7  service method-style:	ReassignRole document
//gsoap ns7  service method-encoding:	ReassignRole literal
//gsoap ns7  service method-action:	ReassignRole urn:DocumentRightOperations#ReassignRole
//gsoap ns7  service method-fault:	ReassignRole ns7__UnsupportedDocumentRoleFault
//gsoap ns7  service method-fault:	ReassignRole ns7__UnknownDocumentRoleFault
//gsoap ns7  service method-fault:	ReassignRole ns7__UnknownDocumentRightFault
//gsoap ns7  service method-fault:	ReassignRole ns7__AuthorizationDeniedFault
int __ns7__ReassignRole(
    _ns7__ReassignRole*                 ns7__ReassignRole,	///< Request parameter
    _ns7__ReassignRoleResponse*         ns7__ReassignRoleResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns7__CheckInRightsForAccount                                           *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns7__CheckInRightsForAccount" of service binding "DocumentRightOperationsBinding"

/**

Operation details:


                Check all rights in use by an account. If a user's device fails, or has issues with desktop installations, the rights that are in use can be force-ably checked in. This allows the account to request the rights on another device. If the account does not exist an empty collection is returned. The checked-in rights are restricted to the contexts that the caller is a context manager.
            
  - SOAP document/literal style
  - SOAP action="urn:DocumentRightOperations#CheckInRightsForAccount"
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns7__CheckInRightsForAccount(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns7__CheckInRightsForAccount*      ns7__CheckInRightsForAccount,
    // response parameters:
    _ns7__CheckInRightsForAccountResponse* ns7__CheckInRightsForAccountResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns7__CheckInRightsForAccount(
    struct soap *soap,
    // request parameters:
    _ns7__CheckInRightsForAccount*      ns7__CheckInRightsForAccount,
    // response parameters:
    _ns7__CheckInRightsForAccountResponse* ns7__CheckInRightsForAccountResponse
  );
@endcode

C++ proxy class (defined in soapDocumentRightOperationsBindingProxy.h):
@code
  class DocumentRightOperationsBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapDocumentRightOperationsBindingService.h):
@code
  class DocumentRightOperationsBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns7  service method-style:	CheckInRightsForAccount document
//gsoap ns7  service method-encoding:	CheckInRightsForAccount literal
//gsoap ns7  service method-action:	CheckInRightsForAccount urn:DocumentRightOperations#CheckInRightsForAccount
//gsoap ns7  service method-fault:	CheckInRightsForAccount ns7__AuthorizationDeniedFault
int __ns7__CheckInRightsForAccount(
    _ns7__CheckInRightsForAccount*      ns7__CheckInRightsForAccount,	///< Request parameter
    _ns7__CheckInRightsForAccountResponse* ns7__CheckInRightsForAccountResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns7__SaveChangesToItems                                                *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns7__SaveChangesToItems" of service binding "DocumentRightOperationsBinding"

/**

Operation details:


                Alter the item restrictions for a set of rights. Alter the item restrictions on one or more Document Right. Changes are made to the list of item restrictions by comparing the two copies of the item codes provided and either removing or adding item restrictions by looking at the delta. For example if the delta (as compared to the first list of items) contains additional Item Code instances then new items will be added to the rights. However, if the delta (as compared to the first list of items) does not contain an Item Code instance then the items will be removed from the rights.
            
  - SOAP document/literal style
  - SOAP action="urn:DocumentRightOperations#SaveChangesToItems"
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":UnknownDocumentRightFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns7__SaveChangesToItems(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns7__SaveChangesToItems*           ns7__SaveChangesToItems,
    // response parameters:
    _ns7__SaveChangesToItemsResponse*   ns7__SaveChangesToItemsResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns7__SaveChangesToItems(
    struct soap *soap,
    // request parameters:
    _ns7__SaveChangesToItems*           ns7__SaveChangesToItems,
    // response parameters:
    _ns7__SaveChangesToItemsResponse*   ns7__SaveChangesToItemsResponse
  );
@endcode

C++ proxy class (defined in soapDocumentRightOperationsBindingProxy.h):
@code
  class DocumentRightOperationsBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapDocumentRightOperationsBindingService.h):
@code
  class DocumentRightOperationsBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns7  service method-style:	SaveChangesToItems document
//gsoap ns7  service method-encoding:	SaveChangesToItems literal
//gsoap ns7  service method-action:	SaveChangesToItems urn:DocumentRightOperations#SaveChangesToItems
//gsoap ns7  service method-fault:	SaveChangesToItems ns7__UnknownDocumentRightFault
//gsoap ns7  service method-fault:	SaveChangesToItems ns7__AuthorizationDeniedFault
int __ns7__SaveChangesToItems(
    _ns7__SaveChangesToItems*           ns7__SaveChangesToItems,	///< Request parameter
    _ns7__SaveChangesToItemsResponse*   ns7__SaveChangesToItemsResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns7__UnassignRights                                                    *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns7__UnassignRights" of service binding "DocumentRightOperationsBinding"

/**

Operation details:


                Un-assign a set of rights. If the right has already been unassigned this method will not report an error.
            
  - SOAP document/literal style
  - SOAP action="urn:DocumentRightOperations#UnassignRights"
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns7__UnassignRights(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns7__UnassignRights*               ns7__UnassignRights,
    // response parameters:
    _ns7__UnassignRightsResponse*       ns7__UnassignRightsResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns7__UnassignRights(
    struct soap *soap,
    // request parameters:
    _ns7__UnassignRights*               ns7__UnassignRights,
    // response parameters:
    _ns7__UnassignRightsResponse*       ns7__UnassignRightsResponse
  );
@endcode

C++ proxy class (defined in soapDocumentRightOperationsBindingProxy.h):
@code
  class DocumentRightOperationsBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapDocumentRightOperationsBindingService.h):
@code
  class DocumentRightOperationsBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns7  service method-style:	UnassignRights document
//gsoap ns7  service method-encoding:	UnassignRights literal
//gsoap ns7  service method-action:	UnassignRights urn:DocumentRightOperations#UnassignRights
//gsoap ns7  service method-fault:	UnassignRights ns7__AuthorizationDeniedFault
int __ns7__UnassignRights(
    _ns7__UnassignRights*               ns7__UnassignRights,	///< Request parameter
    _ns7__UnassignRightsResponse*       ns7__UnassignRightsResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns7__ListRightsByContext                                               *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns7__ListRightsByContext" of service binding "DocumentRightOperationsBinding"

/**

Operation details:


                List rights assigned within a context. This method lists rights assigned within a context, ordered by the date the role was assigned (most recent rights first). If large numbers of rights are assigned the page range parameter can be used to retrieve the rights in smaller chunks.
            
  - SOAP document/literal style
  - SOAP action="urn:DocumentRightOperations#ListRightsByContext"
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":UnknownContextFault (literal)
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns7__ListRightsByContext(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns7__ListRightsByContext*          ns7__ListRightsByContext,
    // response parameters:
    _ns7__ListRightsByContextResponse*  ns7__ListRightsByContextResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns7__ListRightsByContext(
    struct soap *soap,
    // request parameters:
    _ns7__ListRightsByContext*          ns7__ListRightsByContext,
    // response parameters:
    _ns7__ListRightsByContextResponse*  ns7__ListRightsByContextResponse
  );
@endcode

C++ proxy class (defined in soapDocumentRightOperationsBindingProxy.h):
@code
  class DocumentRightOperationsBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapDocumentRightOperationsBindingService.h):
@code
  class DocumentRightOperationsBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns7  service method-style:	ListRightsByContext document
//gsoap ns7  service method-encoding:	ListRightsByContext literal
//gsoap ns7  service method-action:	ListRightsByContext urn:DocumentRightOperations#ListRightsByContext
//gsoap ns7  service method-fault:	ListRightsByContext ns7__UnknownContextFault
//gsoap ns7  service method-fault:	ListRightsByContext ns7__AuthorizationDeniedFault
int __ns7__ListRightsByContext(
    _ns7__ListRightsByContext*          ns7__ListRightsByContext,	///< Request parameter
    _ns7__ListRightsByContextResponse*  ns7__ListRightsByContextResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * Service Operation                                                          *
 *   __ns7__ListRightsByAccount                                               *
 *                                                                            *
\******************************************************************************/


/// Operation "__ns7__ListRightsByAccount" of service binding "DocumentRightOperationsBinding"

/**

Operation details:


                List rights for an account. Rights listed for an account include rights obtained indirectly through group membership. If the account does not exist an empty collection is returned. Only rights that the caller is allowed to view will be returned. The caller can view rights if they are a context manager or inspector (for the related context).
            
  - SOAP document/literal style
  - SOAP action="urn:DocumentRightOperations#ListRightsByAccount"
  - SOAP Fault: "http://xmlns.oracle.com/irm/rights/wsdl":AuthorizationDeniedFault (literal)

C stub function (defined in soapClient.c[pp] generated by soapcpp2):
@code
  int soap_call___ns7__ListRightsByAccount(
    struct soap *soap,
    NULL, // char *endpoint = NULL selects default endpoint for this operation
    NULL, // char *action = NULL selects default action for this operation
    // request parameters:
    _ns7__ListRightsByAccount*          ns7__ListRightsByAccount,
    // response parameters:
    _ns7__ListRightsByAccountResponse*  ns7__ListRightsByAccountResponse
  );
@endcode

C server function (called from the service dispatcher defined in soapServer.c[pp]):
@code
  int __ns7__ListRightsByAccount(
    struct soap *soap,
    // request parameters:
    _ns7__ListRightsByAccount*          ns7__ListRightsByAccount,
    // response parameters:
    _ns7__ListRightsByAccountResponse*  ns7__ListRightsByAccountResponse
  );
@endcode

C++ proxy class (defined in soapDocumentRightOperationsBindingProxy.h):
@code
  class DocumentRightOperationsBindingProxy;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use proxy classes;

C++ service class (defined in soapDocumentRightOperationsBindingService.h):
@code
  class DocumentRightOperationsBindingService;
@endcode
Important: use soapcpp2 option '-i' to generate greatly improved and easy-to-use service classes;

*/

//gsoap ns7  service method-style:	ListRightsByAccount document
//gsoap ns7  service method-encoding:	ListRightsByAccount literal
//gsoap ns7  service method-action:	ListRightsByAccount urn:DocumentRightOperations#ListRightsByAccount
//gsoap ns7  service method-fault:	ListRightsByAccount ns7__AuthorizationDeniedFault
int __ns7__ListRightsByAccount(
    _ns7__ListRightsByAccount*          ns7__ListRightsByAccount,	///< Request parameter
    _ns7__ListRightsByAccountResponse*  ns7__ListRightsByAccountResponse	///< Response parameter
);

/******************************************************************************\
 *                                                                            *
 * XML Data Binding                                                           *
 *                                                                            *
\******************************************************************************/


/**

@page page_XMLDataBinding XML Data Binding

SOAP/XML services use data bindings contractually bound by WSDL and auto-
generated by wsdl2h and soapcpp2 (see Service Bindings). Plain data bindings
are adopted from XML schemas as part of the WSDL types section or when running
wsdl2h on a set of schemas to produce non-SOAP-based XML data bindings.

The following readers and writers are C/C++ data type (de)serializers auto-
generated by wsdl2h and soapcpp2. Run soapcpp2 on this file to generate the
(de)serialization code, which is stored in soapC.c[pp]. Include "soapH.h" in
your code to import these data type and function declarations. Only use the
soapcpp2-generated files in your project build. Do not include the wsdl2h-
generated .h file in your code.

XML content can be retrieved from:
  - a FILE* fd, using soap->recvfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->is = ...
  - a buffer, using the soap->frecv() callback

XML content can be stored to:
  - a FILE* fd, using soap->sendfd = fd
  - a socket, using soap->socket = ...
  - a C++ stream, using soap->os = ...
  - a buffer, using the soap->fsend() callback


@section ns1 Top-level root elements of schema "http://xmlns.oracle.com/irm/core"

@section ns2 Top-level root elements of schema "http://xmlns.oracle.com/irm/content"

@section ns3 Top-level root elements of schema "http://xmlns.oracle.com/irm/system"

@section ns4 Top-level root elements of schema "http://xmlns.oracle.com/irm/content/wsdl"

  - <ns4:Seal> @ref _ns4__Seal
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__Seal(struct soap*, _ns4__Seal*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__Seal(struct soap*, _ns4__Seal*);
    @endcode

  - <ns4:SealResponse> @ref _ns4__SealResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__SealResponse(struct soap*, _ns4__SealResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__SealResponse(struct soap*, _ns4__SealResponse*);
    @endcode

  - <ns4:Unseal> @ref _ns4__Unseal
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__Unseal(struct soap*, _ns4__Unseal*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__Unseal(struct soap*, _ns4__Unseal*);
    @endcode

  - <ns4:UnsealResponse> @ref _ns4__UnsealResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__UnsealResponse(struct soap*, _ns4__UnsealResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__UnsealResponse(struct soap*, _ns4__UnsealResponse*);
    @endcode

  - <ns4:Reseal> @ref _ns4__Reseal
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__Reseal(struct soap*, _ns4__Reseal*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__Reseal(struct soap*, _ns4__Reseal*);
    @endcode

  - <ns4:ResealResponse> @ref _ns4__ResealResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__ResealResponse(struct soap*, _ns4__ResealResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__ResealResponse(struct soap*, _ns4__ResealResponse*);
    @endcode

  - <ns4:Reclassify> @ref _ns4__Reclassify
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__Reclassify(struct soap*, _ns4__Reclassify*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__Reclassify(struct soap*, _ns4__Reclassify*);
    @endcode

  - <ns4:ReclassifyResponse> @ref _ns4__ReclassifyResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__ReclassifyResponse(struct soap*, _ns4__ReclassifyResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__ReclassifyResponse(struct soap*, _ns4__ReclassifyResponse*);
    @endcode

  - <ns4:Peek> @ref _ns4__Peek
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__Peek(struct soap*, _ns4__Peek*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__Peek(struct soap*, _ns4__Peek*);
    @endcode

  - <ns4:PeekResponse> @ref _ns4__PeekResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__PeekResponse(struct soap*, _ns4__PeekResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__PeekResponse(struct soap*, _ns4__PeekResponse*);
    @endcode

  - <ns4:ValidatedPeek> @ref _ns4__ValidatedPeek
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__ValidatedPeek(struct soap*, _ns4__ValidatedPeek*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__ValidatedPeek(struct soap*, _ns4__ValidatedPeek*);
    @endcode

  - <ns4:ValidatedPeekResponse> @ref _ns4__ValidatedPeekResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns4__ValidatedPeekResponse(struct soap*, _ns4__ValidatedPeekResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns4__ValidatedPeekResponse(struct soap*, _ns4__ValidatedPeekResponse*);
    @endcode

  - <ns4:UnsupportedContentTypeFault> (use wsdl2h option -g to auto-generate)

  - <ns4:IllegalEncryptedContentBlockSizeFault> (use wsdl2h option -g to auto-generate)

  - <ns4:PublicHeaderLengthFault> (use wsdl2h option -g to auto-generate)

  - <ns4:AuthorizationDeniedFault> (use wsdl2h option -g to auto-generate)

  - <ns4:ContentParseFault> (use wsdl2h option -g to auto-generate)

@section ns5 Top-level root elements of schema "http://xmlns.oracle.com/irm/classifications"

@section ns6 Top-level root elements of schema "http://xmlns.oracle.com/irm/rights"

@section ns7 Top-level root elements of schema "http://xmlns.oracle.com/irm/rights/wsdl"

  - <ns7:AssignRole> @ref _ns7__AssignRole
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__AssignRole(struct soap*, _ns7__AssignRole*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__AssignRole(struct soap*, _ns7__AssignRole*);
    @endcode

  - <ns7:AssignRoleResponse> @ref _ns7__AssignRoleResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__AssignRoleResponse(struct soap*, _ns7__AssignRoleResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__AssignRoleResponse(struct soap*, _ns7__AssignRoleResponse*);
    @endcode

  - <ns7:ReassignRole> @ref _ns7__ReassignRole
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__ReassignRole(struct soap*, _ns7__ReassignRole*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__ReassignRole(struct soap*, _ns7__ReassignRole*);
    @endcode

  - <ns7:ReassignRoleResponse> @ref _ns7__ReassignRoleResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__ReassignRoleResponse(struct soap*, _ns7__ReassignRoleResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__ReassignRoleResponse(struct soap*, _ns7__ReassignRoleResponse*);
    @endcode

  - <ns7:CheckInRightsForAccount> @ref _ns7__CheckInRightsForAccount
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__CheckInRightsForAccount(struct soap*, _ns7__CheckInRightsForAccount*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__CheckInRightsForAccount(struct soap*, _ns7__CheckInRightsForAccount*);
    @endcode

  - <ns7:CheckInRightsForAccountResponse> @ref _ns7__CheckInRightsForAccountResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__CheckInRightsForAccountResponse(struct soap*, _ns7__CheckInRightsForAccountResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__CheckInRightsForAccountResponse(struct soap*, _ns7__CheckInRightsForAccountResponse*);
    @endcode

  - <ns7:SaveChangesToItems> @ref _ns7__SaveChangesToItems
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__SaveChangesToItems(struct soap*, _ns7__SaveChangesToItems*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__SaveChangesToItems(struct soap*, _ns7__SaveChangesToItems*);
    @endcode

  - <ns7:SaveChangesToItemsResponse> @ref _ns7__SaveChangesToItemsResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__SaveChangesToItemsResponse(struct soap*, _ns7__SaveChangesToItemsResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__SaveChangesToItemsResponse(struct soap*, _ns7__SaveChangesToItemsResponse*);
    @endcode

  - <ns7:UnassignRights> @ref _ns7__UnassignRights
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__UnassignRights(struct soap*, _ns7__UnassignRights*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__UnassignRights(struct soap*, _ns7__UnassignRights*);
    @endcode

  - <ns7:UnassignRightsResponse> @ref _ns7__UnassignRightsResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__UnassignRightsResponse(struct soap*, _ns7__UnassignRightsResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__UnassignRightsResponse(struct soap*, _ns7__UnassignRightsResponse*);
    @endcode

  - <ns7:ListRightsByContext> @ref _ns7__ListRightsByContext
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__ListRightsByContext(struct soap*, _ns7__ListRightsByContext*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__ListRightsByContext(struct soap*, _ns7__ListRightsByContext*);
    @endcode

  - <ns7:ListRightsByContextResponse> @ref _ns7__ListRightsByContextResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__ListRightsByContextResponse(struct soap*, _ns7__ListRightsByContextResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__ListRightsByContextResponse(struct soap*, _ns7__ListRightsByContextResponse*);
    @endcode

  - <ns7:ListRightsByAccount> @ref _ns7__ListRightsByAccount
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__ListRightsByAccount(struct soap*, _ns7__ListRightsByAccount*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__ListRightsByAccount(struct soap*, _ns7__ListRightsByAccount*);
    @endcode

  - <ns7:ListRightsByAccountResponse> @ref _ns7__ListRightsByAccountResponse
    @code
    // Reader (returns SOAP_OK on success):
    soap_read__ns7__ListRightsByAccountResponse(struct soap*, _ns7__ListRightsByAccountResponse*);
    // Writer (returns SOAP_OK on success):
    soap_write__ns7__ListRightsByAccountResponse(struct soap*, _ns7__ListRightsByAccountResponse*);
    @endcode

  - <ns7:AccountAlreadyAssignedFault> (use wsdl2h option -g to auto-generate)

  - <ns7:UnsupportedDocumentRoleFault> (use wsdl2h option -g to auto-generate)

  - <ns7:UnknownContextFault> (use wsdl2h option -g to auto-generate)

  - <ns7:UnknownDocumentRoleFault> (use wsdl2h option -g to auto-generate)

  - <ns7:AuthorizationDeniedFault> (use wsdl2h option -g to auto-generate)

  - <ns7:UnknownDocumentRightFault> (use wsdl2h option -g to auto-generate)

*/

/* End of IRM.h */
