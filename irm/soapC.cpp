/* soapC.cpp
   Generated by gSOAP 2.7.16 from IRM.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.16 2011-09-30 15:01:10 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns6__Domain_USCORERole:
		return soap_in_ns6__Domain_USCORERole(soap, NULL, NULL, "ns6:Domain_Role");
	case SOAP_TYPE_ns6__DocumentRole_USCORETimeConstraints:
		return soap_in_ns6__DocumentRole_USCORETimeConstraints(soap, NULL, NULL, "ns6:DocumentRole_TimeConstraints");
	case SOAP_TYPE_ns6__DocumentRole_USCOREExportConstraints:
		return soap_in_ns6__DocumentRole_USCOREExportConstraints(soap, NULL, NULL, "ns6:DocumentRole_ExportConstraints");
	case SOAP_TYPE_ns6__ContextTemplate_USCOREStatus:
		return soap_in_ns6__ContextTemplate_USCOREStatus(soap, NULL, NULL, "ns6:ContextTemplate_Status");
	case SOAP_TYPE_ns6__ContextInstance_USCORERole:
		return soap_in_ns6__ContextInstance_USCORERole(soap, NULL, NULL, "ns6:ContextInstance_Role");
	case SOAP_TYPE_ns6__ContextInstance_USCOREVisibility:
		return soap_in_ns6__ContextInstance_USCOREVisibility(soap, NULL, NULL, "ns6:ContextInstance_Visibility");
	case SOAP_TYPE_ns5__ItemConstraints_USCOREType:
		return soap_in_ns5__ItemConstraints_USCOREType(soap, NULL, NULL, "ns5:ItemConstraints_Type");
	case SOAP_TYPE_ns2__ContentParseFault_USCOREReason:
		return soap_in_ns2__ContentParseFault_USCOREReason(soap, NULL, NULL, "ns2:ContentParseFault_Reason");
	case SOAP_TYPE_ns1__Account_USCOREType:
		return soap_in_ns1__Account_USCOREType(soap, NULL, NULL, "ns1:Account_Type");
	case SOAP_TYPE_ns1__RelativeTimeSpan_USCORETimeBase:
		return soap_in_ns1__RelativeTimeSpan_USCORETimeBase(soap, NULL, NULL, "ns1:RelativeTimeSpan_TimeBase");
	case SOAP_TYPE_ns1__TimePeriod_USCOREUnits:
		return soap_in_ns1__TimePeriod_USCOREUnits(soap, NULL, NULL, "ns1:TimePeriod_Units");
	case SOAP_TYPE_ns1__TimeSpan_USCOREReferencePoint:
		return soap_in_ns1__TimeSpan_USCOREReferencePoint(soap, NULL, NULL, "ns1:TimeSpan_ReferencePoint");
	case SOAP_TYPE_ns1__Feature_USCOREUse:
		return soap_in_ns1__Feature_USCOREUse(soap, NULL, NULL, "ns1:Feature_Use");
	case SOAP_TYPE_ns1__Feature_USCORESupport:
		return soap_in_ns1__Feature_USCORESupport(soap, NULL, NULL, "ns1:Feature_Support");
	case SOAP_TYPE_ns1__LicenseCriteria_USCOREUse:
		return soap_in_ns1__LicenseCriteria_USCOREUse(soap, NULL, NULL, "ns1:LicenseCriteria_Use");
	case SOAP_TYPE_ns1__LicenseCriteria_USCOREDelivery:
		return soap_in_ns1__LicenseCriteria_USCOREDelivery(soap, NULL, NULL, "ns1:LicenseCriteria_Delivery");
	case SOAP_TYPE_ns1__LicenseCriteria_USCOREStorage:
		return soap_in_ns1__LicenseCriteria_USCOREStorage(soap, NULL, NULL, "ns1:LicenseCriteria_Storage");
	case SOAP_TYPE_ns6__UnknownDocumentRightFault:
		return soap_in_ns6__UnknownDocumentRightFault(soap, NULL, NULL, "ns6:UnknownDocumentRightFault");
	case SOAP_TYPE_ns6__UnknownDocumentRoleFault:
		return soap_in_ns6__UnknownDocumentRoleFault(soap, NULL, NULL, "ns6:UnknownDocumentRoleFault");
	case SOAP_TYPE_ns6__UnsupportedDocumentRoleFault:
		return soap_in_ns6__UnsupportedDocumentRoleFault(soap, NULL, NULL, "ns6:UnsupportedDocumentRoleFault");
	case SOAP_TYPE_ns6__AccountAlreadyAssignedFault:
		return soap_in_ns6__AccountAlreadyAssignedFault(soap, NULL, NULL, "ns6:AccountAlreadyAssignedFault");
	case SOAP_TYPE_ns6__DocumentRightRef:
		return soap_in_ns6__DocumentRightRef(soap, NULL, NULL, "ns6:DocumentRightRef");
	case SOAP_TYPE_ns6__DocumentRight:
		return soap_in_ns6__DocumentRight(soap, NULL, NULL, "ns6:DocumentRight");
	case SOAP_TYPE_ns6__DomainRef:
		return soap_in_ns6__DomainRef(soap, NULL, NULL, "ns6:DomainRef");
	case SOAP_TYPE_ns6__Domain:
		return soap_in_ns6__Domain(soap, NULL, NULL, "ns6:Domain");
	case SOAP_TYPE_ns6__DocumentRoleRef:
		return soap_in_ns6__DocumentRoleRef(soap, NULL, NULL, "ns6:DocumentRoleRef");
	case SOAP_TYPE_ns6__DocumentRole:
		return soap_in_ns6__DocumentRole(soap, NULL, NULL, "ns6:DocumentRole");
	case SOAP_TYPE_ns6__ContextTemplateRef:
		return soap_in_ns6__ContextTemplateRef(soap, NULL, NULL, "ns6:ContextTemplateRef");
	case SOAP_TYPE_ns6__ContextTemplate:
		return soap_in_ns6__ContextTemplate(soap, NULL, NULL, "ns6:ContextTemplate");
	case SOAP_TYPE_ns6__ContextInstanceRef:
		return soap_in_ns6__ContextInstanceRef(soap, NULL, NULL, "ns6:ContextInstanceRef");
	case SOAP_TYPE_ns6__ContextInstance:
		return soap_in_ns6__ContextInstance(soap, NULL, NULL, "ns6:ContextInstance");
	case SOAP_TYPE_ns5__UnknownContextFault:
		return soap_in_ns5__UnknownContextFault(soap, NULL, NULL, "ns5:UnknownContextFault");
	case SOAP_TYPE_ns5__ItemConstraints:
		return soap_in_ns5__ItemConstraints(soap, NULL, NULL, "ns5:ItemConstraints");
	case SOAP_TYPE_ns5__ContextRef:
		return soap_in_ns5__ContextRef(soap, NULL, NULL, "ns5:ContextRef");
	case SOAP_TYPE_ns5__Context:
		return soap_in_ns5__Context(soap, NULL, NULL, "ns5:Context");
	case SOAP_TYPE_ns5__ItemCode:
		return soap_in_ns5__ItemCode(soap, NULL, NULL, "ns5:ItemCode");
	case SOAP_TYPE_ns3__AuthorizationDeniedFault:
		return soap_in_ns3__AuthorizationDeniedFault(soap, NULL, NULL, "ns3:AuthorizationDeniedFault");
	case SOAP_TYPE_ns2__ContentParseFault:
		return soap_in_ns2__ContentParseFault(soap, NULL, NULL, "ns2:ContentParseFault");
	case SOAP_TYPE_ns2__PublicHeaderLengthFault:
		return soap_in_ns2__PublicHeaderLengthFault(soap, NULL, NULL, "ns2:PublicHeaderLengthFault");
	case SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault:
		return soap_in_ns2__IllegalEncryptedContentBlockSizeFault(soap, NULL, NULL, "ns2:IllegalEncryptedContentBlockSizeFault");
	case SOAP_TYPE_ns2__UnsupportedContentTypeFault:
		return soap_in_ns2__UnsupportedContentTypeFault(soap, NULL, NULL, "ns2:UnsupportedContentTypeFault");
	case SOAP_TYPE_ns2__ContentDescription:
		return soap_in_ns2__ContentDescription(soap, NULL, NULL, "ns2:ContentDescription");
	case SOAP_TYPE_ns2__SealingOptions:
		return soap_in_ns2__SealingOptions(soap, NULL, NULL, "ns2:SealingOptions");
	case SOAP_TYPE_ns2__EncryptionOptions:
		return soap_in_ns2__EncryptionOptions(soap, NULL, NULL, "ns2:EncryptionOptions");
	case SOAP_TYPE_ns2__ContentSchema:
		return soap_in_ns2__ContentSchema(soap, NULL, NULL, "ns2:ContentSchema");
	case SOAP_TYPE_ns2__SchemaVersion:
		return soap_in_ns2__SchemaVersion(soap, NULL, NULL, "ns2:SchemaVersion");
	case SOAP_TYPE_ns2__CustomData:
		return soap_in_ns2__CustomData(soap, NULL, NULL, "ns2:CustomData");
	case SOAP_TYPE_ns2__KeySetRef:
		return soap_in_ns2__KeySetRef(soap, NULL, NULL, "ns2:KeySetRef");
	case SOAP_TYPE_ns2__KeySet:
		return soap_in_ns2__KeySet(soap, NULL, NULL, "ns2:KeySet");
	case SOAP_TYPE_ns2__KeySetExtensions:
		return soap_in_ns2__KeySetExtensions(soap, NULL, NULL, "ns2:KeySetExtensions");
	case SOAP_TYPE_ns2__WrappedKeySetExtensions:
		return soap_in_ns2__WrappedKeySetExtensions(soap, NULL, NULL, "ns2:WrappedKeySetExtensions");
	case SOAP_TYPE_ns2__RawKeySetExtensions:
		return soap_in_ns2__RawKeySetExtensions(soap, NULL, NULL, "ns2:RawKeySetExtensions");
	case SOAP_TYPE_ns2__CryptoSchemaRef:
		return soap_in_ns2__CryptoSchemaRef(soap, NULL, NULL, "ns2:CryptoSchemaRef");
	case SOAP_TYPE_ns2__CryptoSchema:
		return soap_in_ns2__CryptoSchema(soap, NULL, NULL, "ns2:CryptoSchema");
	case SOAP_TYPE_ns1__PageRange:
		return soap_in_ns1__PageRange(soap, NULL, NULL, "ns1:PageRange");
	case SOAP_TYPE_ns1__AccountRef:
		return soap_in_ns1__AccountRef(soap, NULL, NULL, "ns1:AccountRef");
	case SOAP_TYPE_ns1__Account:
		return soap_in_ns1__Account(soap, NULL, NULL, "ns1:Account");
	case SOAP_TYPE_ns1__XPathExpression:
		return soap_in_ns1__XPathExpression(soap, NULL, NULL, "ns1:XPathExpression");
	case SOAP_TYPE_ns1__XPathClassificationFilter:
		return soap_in_ns1__XPathClassificationFilter(soap, NULL, NULL, "ns1:XPathClassificationFilter");
	case SOAP_TYPE_ns1__AbsoluteTimeSpan:
		return soap_in_ns1__AbsoluteTimeSpan(soap, NULL, NULL, "ns1:AbsoluteTimeSpan");
	case SOAP_TYPE_ns1__RelativeTimeSpan:
		return soap_in_ns1__RelativeTimeSpan(soap, NULL, NULL, "ns1:RelativeTimeSpan");
	case SOAP_TYPE_ns1__ClassificationFilter:
		return soap_in_ns1__ClassificationFilter(soap, NULL, NULL, "ns1:ClassificationFilter");
	case SOAP_TYPE_ns1__TimePeriod:
		return soap_in_ns1__TimePeriod(soap, NULL, NULL, "ns1:TimePeriod");
	case SOAP_TYPE_ns1__TimeSpan:
		return soap_in_ns1__TimeSpan(soap, NULL, NULL, "ns1:TimeSpan");
	case SOAP_TYPE_ns1__Feature:
		return soap_in_ns1__Feature(soap, NULL, NULL, "ns1:Feature");
	case SOAP_TYPE_ns1__LicenseCriteria:
		return soap_in_ns1__LicenseCriteria(soap, NULL, NULL, "ns1:LicenseCriteria");
	case SOAP_TYPE_ns1__Classification:
		return soap_in_ns1__Classification(soap, NULL, NULL, "ns1:Classification");
	case SOAP_TYPE_ns1__Label:
		return soap_in_ns1__Label(soap, NULL, NULL, "ns1:Label");
	case SOAP_TYPE_ns1__DesktopKeySetExtensions:
		return soap_in_ns1__DesktopKeySetExtensions(soap, NULL, NULL, "ns1:DesktopKeySetExtensions");
	case SOAP_TYPE_ns1__ClassificationSystemRef:
		return soap_in_ns1__ClassificationSystemRef(soap, NULL, NULL, "ns1:ClassificationSystemRef");
	case SOAP_TYPE_ns1__ClassificationSystem:
		return soap_in_ns1__ClassificationSystem(soap, NULL, NULL, "ns1:ClassificationSystem");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, NULL, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_ns7__ListRightsByAccountResponse:
		return soap_in_PointerTo_ns7__ListRightsByAccountResponse(soap, NULL, NULL, "ns7:ListRightsByAccountResponse");
	case SOAP_TYPE_PointerTo_ns7__ListRightsByAccount:
		return soap_in_PointerTo_ns7__ListRightsByAccount(soap, NULL, NULL, "ns7:ListRightsByAccount");
	case SOAP_TYPE_PointerTo_ns7__ListRightsByContextResponse:
		return soap_in_PointerTo_ns7__ListRightsByContextResponse(soap, NULL, NULL, "ns7:ListRightsByContextResponse");
	case SOAP_TYPE_PointerTo_ns7__ListRightsByContext:
		return soap_in_PointerTo_ns7__ListRightsByContext(soap, NULL, NULL, "ns7:ListRightsByContext");
	case SOAP_TYPE_PointerTo_ns7__UnassignRightsResponse:
		return soap_in_PointerTo_ns7__UnassignRightsResponse(soap, NULL, NULL, "ns7:UnassignRightsResponse");
	case SOAP_TYPE_PointerTo_ns7__UnassignRights:
		return soap_in_PointerTo_ns7__UnassignRights(soap, NULL, NULL, "ns7:UnassignRights");
	case SOAP_TYPE_PointerTo_ns7__SaveChangesToItemsResponse:
		return soap_in_PointerTo_ns7__SaveChangesToItemsResponse(soap, NULL, NULL, "ns7:SaveChangesToItemsResponse");
	case SOAP_TYPE_PointerTo_ns7__SaveChangesToItems:
		return soap_in_PointerTo_ns7__SaveChangesToItems(soap, NULL, NULL, "ns7:SaveChangesToItems");
	case SOAP_TYPE_PointerTo_ns7__CheckInRightsForAccountResponse:
		return soap_in_PointerTo_ns7__CheckInRightsForAccountResponse(soap, NULL, NULL, "ns7:CheckInRightsForAccountResponse");
	case SOAP_TYPE_PointerTo_ns7__CheckInRightsForAccount:
		return soap_in_PointerTo_ns7__CheckInRightsForAccount(soap, NULL, NULL, "ns7:CheckInRightsForAccount");
	case SOAP_TYPE_PointerTo_ns7__ReassignRoleResponse:
		return soap_in_PointerTo_ns7__ReassignRoleResponse(soap, NULL, NULL, "ns7:ReassignRoleResponse");
	case SOAP_TYPE_PointerTo_ns7__ReassignRole:
		return soap_in_PointerTo_ns7__ReassignRole(soap, NULL, NULL, "ns7:ReassignRole");
	case SOAP_TYPE_PointerTo_ns7__AssignRoleResponse:
		return soap_in_PointerTo_ns7__AssignRoleResponse(soap, NULL, NULL, "ns7:AssignRoleResponse");
	case SOAP_TYPE_PointerTo_ns7__AssignRole:
		return soap_in_PointerTo_ns7__AssignRole(soap, NULL, NULL, "ns7:AssignRole");
	case SOAP_TYPE_PointerTo_ns4__ValidatedPeekResponse:
		return soap_in_PointerTo_ns4__ValidatedPeekResponse(soap, NULL, NULL, "ns4:ValidatedPeekResponse");
	case SOAP_TYPE_PointerTo_ns4__ValidatedPeek:
		return soap_in_PointerTo_ns4__ValidatedPeek(soap, NULL, NULL, "ns4:ValidatedPeek");
	case SOAP_TYPE_PointerTo_ns4__PeekResponse:
		return soap_in_PointerTo_ns4__PeekResponse(soap, NULL, NULL, "ns4:PeekResponse");
	case SOAP_TYPE_PointerTo_ns4__Peek:
		return soap_in_PointerTo_ns4__Peek(soap, NULL, NULL, "ns4:Peek");
	case SOAP_TYPE_PointerTo_ns4__ReclassifyResponse:
		return soap_in_PointerTo_ns4__ReclassifyResponse(soap, NULL, NULL, "ns4:ReclassifyResponse");
	case SOAP_TYPE_PointerTo_ns4__Reclassify:
		return soap_in_PointerTo_ns4__Reclassify(soap, NULL, NULL, "ns4:Reclassify");
	case SOAP_TYPE_PointerTo_ns4__ResealResponse:
		return soap_in_PointerTo_ns4__ResealResponse(soap, NULL, NULL, "ns4:ResealResponse");
	case SOAP_TYPE_PointerTo_ns4__Reseal:
		return soap_in_PointerTo_ns4__Reseal(soap, NULL, NULL, "ns4:Reseal");
	case SOAP_TYPE_PointerTo_ns4__UnsealResponse:
		return soap_in_PointerTo_ns4__UnsealResponse(soap, NULL, NULL, "ns4:UnsealResponse");
	case SOAP_TYPE_PointerTo_ns4__Unseal:
		return soap_in_PointerTo_ns4__Unseal(soap, NULL, NULL, "ns4:Unseal");
	case SOAP_TYPE_PointerTo_ns4__SealResponse:
		return soap_in_PointerTo_ns4__SealResponse(soap, NULL, NULL, "ns4:SealResponse");
	case SOAP_TYPE_PointerTo_ns4__Seal:
		return soap_in_PointerTo_ns4__Seal(soap, NULL, NULL, "ns4:Seal");
	case SOAP_TYPE_PointerTons6__UnsupportedDocumentRoleFault:
		return soap_in_PointerTons6__UnsupportedDocumentRoleFault(soap, NULL, NULL, "ns6:UnsupportedDocumentRoleFault");
	case SOAP_TYPE_PointerTons6__UnknownDocumentRoleFault:
		return soap_in_PointerTons6__UnknownDocumentRoleFault(soap, NULL, NULL, "ns6:UnknownDocumentRoleFault");
	case SOAP_TYPE_PointerTons6__UnknownDocumentRightFault:
		return soap_in_PointerTons6__UnknownDocumentRightFault(soap, NULL, NULL, "ns6:UnknownDocumentRightFault");
	case SOAP_TYPE_PointerTons5__UnknownContextFault:
		return soap_in_PointerTons5__UnknownContextFault(soap, NULL, NULL, "ns5:UnknownContextFault");
	case SOAP_TYPE_PointerTons6__AccountAlreadyAssignedFault:
		return soap_in_PointerTons6__AccountAlreadyAssignedFault(soap, NULL, NULL, "ns6:AccountAlreadyAssignedFault");
	case SOAP_TYPE_PointerTons2__UnsupportedContentTypeFault:
		return soap_in_PointerTons2__UnsupportedContentTypeFault(soap, NULL, NULL, "ns2:UnsupportedContentTypeFault");
	case SOAP_TYPE_PointerTons2__PublicHeaderLengthFault:
		return soap_in_PointerTons2__PublicHeaderLengthFault(soap, NULL, NULL, "ns2:PublicHeaderLengthFault");
	case SOAP_TYPE_PointerTons2__IllegalEncryptedContentBlockSizeFault:
		return soap_in_PointerTons2__IllegalEncryptedContentBlockSizeFault(soap, NULL, NULL, "ns2:IllegalEncryptedContentBlockSizeFault");
	case SOAP_TYPE_PointerTons2__ContentParseFault:
		return soap_in_PointerTons2__ContentParseFault(soap, NULL, NULL, "ns2:ContentParseFault");
	case SOAP_TYPE_PointerTons3__AuthorizationDeniedFault:
		return soap_in_PointerTons3__AuthorizationDeniedFault(soap, NULL, NULL, "ns3:AuthorizationDeniedFault");
	case SOAP_TYPE_PointerTons6__ContextTemplateRef:
		return soap_in_PointerTons6__ContextTemplateRef(soap, NULL, NULL, "ns6:ContextTemplateRef");
	case SOAP_TYPE_PointerTons1__XPathExpression:
		return soap_in_PointerTons1__XPathExpression(soap, NULL, NULL, "ns1:XPathExpression");
	case SOAP_TYPE_PointerTons1__PageRange:
		return soap_in_PointerTons1__PageRange(soap, NULL, NULL, "ns1:PageRange");
	case SOAP_TYPE_PointerTons6__DocumentRightRef:
		return soap_in_PointerTons6__DocumentRightRef(soap, NULL, NULL, "ns6:DocumentRightRef");
	case SOAP_TYPE_PointerTons6__DocumentRight:
		return soap_in_PointerTons6__DocumentRight(soap, NULL, NULL, "ns6:DocumentRight");
	case SOAP_TYPE_PointerTons6__ContextInstanceRef:
		return soap_in_PointerTons6__ContextInstanceRef(soap, NULL, NULL, "ns6:ContextInstanceRef");
	case SOAP_TYPE_PointerTons6__DocumentRole:
		return soap_in_PointerTons6__DocumentRole(soap, NULL, NULL, "ns6:DocumentRole");
	case SOAP_TYPE_PointerTons1__AccountRef:
		return soap_in_PointerTons1__AccountRef(soap, NULL, NULL, "ns1:AccountRef");
	case SOAP_TYPE_PointerTons6__DomainRef:
		return soap_in_PointerTons6__DomainRef(soap, NULL, NULL, "ns6:DomainRef");
	case SOAP_TYPE_PointerTons6__DocumentRoleRef:
		return soap_in_PointerTons6__DocumentRoleRef(soap, NULL, NULL, "ns6:DocumentRoleRef");
	case SOAP_TYPE_PointerTons5__ItemCode:
		return soap_in_PointerTons5__ItemCode(soap, NULL, NULL, "ns5:ItemCode");
	case SOAP_TYPE_PointerTons2__ContentDescription:
		return soap_in_PointerTons2__ContentDescription(soap, NULL, NULL, "ns2:ContentDescription");
	case SOAP_TYPE_PointerTons2__SealingOptions:
		return soap_in_PointerTons2__SealingOptions(soap, NULL, NULL, "ns2:SealingOptions");
	case SOAP_TYPE_PointerTons2__EncryptionOptions:
		return soap_in_PointerTons2__EncryptionOptions(soap, NULL, NULL, "ns2:EncryptionOptions");
	case SOAP_TYPE_PointerTons2__ContentSchema:
		return soap_in_PointerTons2__ContentSchema(soap, NULL, NULL, "ns2:ContentSchema");
	case SOAP_TYPE_PointerTons2__CustomData:
		return soap_in_PointerTons2__CustomData(soap, NULL, NULL, "ns2:CustomData");
	case SOAP_TYPE_PointerTons1__Classification:
		return soap_in_PointerTons1__Classification(soap, NULL, NULL, "ns1:Classification");
	case SOAP_TYPE_PointerTons2__SchemaVersion:
		return soap_in_PointerTons2__SchemaVersion(soap, NULL, NULL, "ns2:SchemaVersion");
	case SOAP_TYPE_PointerTons2__KeySetExtensions:
		return soap_in_PointerTons2__KeySetExtensions(soap, NULL, NULL, "ns2:KeySetExtensions");
	case SOAP_TYPE_PointerTons2__CryptoSchemaRef:
		return soap_in_PointerTons2__CryptoSchemaRef(soap, NULL, NULL, "ns2:CryptoSchemaRef");
	case SOAP_TYPE_PointerTons1__ClassificationFilter:
		return soap_in_PointerTons1__ClassificationFilter(soap, NULL, NULL, "ns1:ClassificationFilter");
	case SOAP_TYPE_PointerTons1__TimePeriod:
		return soap_in_PointerTons1__TimePeriod(soap, NULL, NULL, "ns1:TimePeriod");
	case SOAP_TYPE_PointerTons1__TimeSpan:
		return soap_in_PointerTons1__TimeSpan(soap, NULL, NULL, "ns1:TimeSpan");
	case SOAP_TYPE_PointerTons1__Feature:
		return soap_in_PointerTons1__Feature(soap, NULL, NULL, "ns1:Feature");
	case SOAP_TYPE_PointerTons1__Label:
		return soap_in_PointerTons1__Label(soap, NULL, NULL, "ns1:Label");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons2__KeySetRef:
		return soap_in_PointerTons2__KeySetRef(soap, NULL, NULL, "ns2:KeySetRef");
	case SOAP_TYPE_PointerTons1__ClassificationSystemRef:
		return soap_in_PointerTons1__ClassificationSystemRef(soap, NULL, NULL, "ns1:ClassificationSystemRef");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns6:UnknownDocumentRightFault"))
		{	*type = SOAP_TYPE_ns6__UnknownDocumentRightFault;
			return soap_in_ns6__UnknownDocumentRightFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:UnknownDocumentRoleFault"))
		{	*type = SOAP_TYPE_ns6__UnknownDocumentRoleFault;
			return soap_in_ns6__UnknownDocumentRoleFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:UnsupportedDocumentRoleFault"))
		{	*type = SOAP_TYPE_ns6__UnsupportedDocumentRoleFault;
			return soap_in_ns6__UnsupportedDocumentRoleFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:AccountAlreadyAssignedFault"))
		{	*type = SOAP_TYPE_ns6__AccountAlreadyAssignedFault;
			return soap_in_ns6__AccountAlreadyAssignedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DocumentRightRef"))
		{	*type = SOAP_TYPE_ns6__DocumentRightRef;
			return soap_in_ns6__DocumentRightRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DocumentRight"))
		{	*type = SOAP_TYPE_ns6__DocumentRight;
			return soap_in_ns6__DocumentRight(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DomainRef"))
		{	*type = SOAP_TYPE_ns6__DomainRef;
			return soap_in_ns6__DomainRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Domain"))
		{	*type = SOAP_TYPE_ns6__Domain;
			return soap_in_ns6__Domain(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DocumentRoleRef"))
		{	*type = SOAP_TYPE_ns6__DocumentRoleRef;
			return soap_in_ns6__DocumentRoleRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DocumentRole"))
		{	*type = SOAP_TYPE_ns6__DocumentRole;
			return soap_in_ns6__DocumentRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ContextTemplateRef"))
		{	*type = SOAP_TYPE_ns6__ContextTemplateRef;
			return soap_in_ns6__ContextTemplateRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ContextTemplate"))
		{	*type = SOAP_TYPE_ns6__ContextTemplate;
			return soap_in_ns6__ContextTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ContextInstanceRef"))
		{	*type = SOAP_TYPE_ns6__ContextInstanceRef;
			return soap_in_ns6__ContextInstanceRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ContextInstance"))
		{	*type = SOAP_TYPE_ns6__ContextInstance;
			return soap_in_ns6__ContextInstance(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:UnknownContextFault"))
		{	*type = SOAP_TYPE_ns5__UnknownContextFault;
			return soap_in_ns5__UnknownContextFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ItemConstraints"))
		{	*type = SOAP_TYPE_ns5__ItemConstraints;
			return soap_in_ns5__ItemConstraints(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ContextRef"))
		{	*type = SOAP_TYPE_ns5__ContextRef;
			return soap_in_ns5__ContextRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:Context"))
		{	*type = SOAP_TYPE_ns5__Context;
			return soap_in_ns5__Context(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ItemCode"))
		{	*type = SOAP_TYPE_ns5__ItemCode;
			return soap_in_ns5__ItemCode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:AuthorizationDeniedFault"))
		{	*type = SOAP_TYPE_ns3__AuthorizationDeniedFault;
			return soap_in_ns3__AuthorizationDeniedFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentParseFault"))
		{	*type = SOAP_TYPE_ns2__ContentParseFault;
			return soap_in_ns2__ContentParseFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:PublicHeaderLengthFault"))
		{	*type = SOAP_TYPE_ns2__PublicHeaderLengthFault;
			return soap_in_ns2__PublicHeaderLengthFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:IllegalEncryptedContentBlockSizeFault"))
		{	*type = SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault;
			return soap_in_ns2__IllegalEncryptedContentBlockSizeFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:UnsupportedContentTypeFault"))
		{	*type = SOAP_TYPE_ns2__UnsupportedContentTypeFault;
			return soap_in_ns2__UnsupportedContentTypeFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentDescription"))
		{	*type = SOAP_TYPE_ns2__ContentDescription;
			return soap_in_ns2__ContentDescription(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SealingOptions"))
		{	*type = SOAP_TYPE_ns2__SealingOptions;
			return soap_in_ns2__SealingOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EncryptionOptions"))
		{	*type = SOAP_TYPE_ns2__EncryptionOptions;
			return soap_in_ns2__EncryptionOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentSchema"))
		{	*type = SOAP_TYPE_ns2__ContentSchema;
			return soap_in_ns2__ContentSchema(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SchemaVersion"))
		{	*type = SOAP_TYPE_ns2__SchemaVersion;
			return soap_in_ns2__SchemaVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CustomData"))
		{	*type = SOAP_TYPE_ns2__CustomData;
			return soap_in_ns2__CustomData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:KeySetRef"))
		{	*type = SOAP_TYPE_ns2__KeySetRef;
			return soap_in_ns2__KeySetRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:KeySet"))
		{	*type = SOAP_TYPE_ns2__KeySet;
			return soap_in_ns2__KeySet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:KeySetExtensions"))
		{	*type = SOAP_TYPE_ns2__KeySetExtensions;
			return soap_in_ns2__KeySetExtensions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:WrappedKeySetExtensions"))
		{	*type = SOAP_TYPE_ns2__WrappedKeySetExtensions;
			return soap_in_ns2__WrappedKeySetExtensions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RawKeySetExtensions"))
		{	*type = SOAP_TYPE_ns2__RawKeySetExtensions;
			return soap_in_ns2__RawKeySetExtensions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CryptoSchemaRef"))
		{	*type = SOAP_TYPE_ns2__CryptoSchemaRef;
			return soap_in_ns2__CryptoSchemaRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CryptoSchema"))
		{	*type = SOAP_TYPE_ns2__CryptoSchema;
			return soap_in_ns2__CryptoSchema(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PageRange"))
		{	*type = SOAP_TYPE_ns1__PageRange;
			return soap_in_ns1__PageRange(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AccountRef"))
		{	*type = SOAP_TYPE_ns1__AccountRef;
			return soap_in_ns1__AccountRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Account"))
		{	*type = SOAP_TYPE_ns1__Account;
			return soap_in_ns1__Account(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:XPathExpression"))
		{	*type = SOAP_TYPE_ns1__XPathExpression;
			return soap_in_ns1__XPathExpression(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:XPathClassificationFilter"))
		{	*type = SOAP_TYPE_ns1__XPathClassificationFilter;
			return soap_in_ns1__XPathClassificationFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AbsoluteTimeSpan"))
		{	*type = SOAP_TYPE_ns1__AbsoluteTimeSpan;
			return soap_in_ns1__AbsoluteTimeSpan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RelativeTimeSpan"))
		{	*type = SOAP_TYPE_ns1__RelativeTimeSpan;
			return soap_in_ns1__RelativeTimeSpan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClassificationFilter"))
		{	*type = SOAP_TYPE_ns1__ClassificationFilter;
			return soap_in_ns1__ClassificationFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TimePeriod"))
		{	*type = SOAP_TYPE_ns1__TimePeriod;
			return soap_in_ns1__TimePeriod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TimeSpan"))
		{	*type = SOAP_TYPE_ns1__TimeSpan;
			return soap_in_ns1__TimeSpan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Feature"))
		{	*type = SOAP_TYPE_ns1__Feature;
			return soap_in_ns1__Feature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LicenseCriteria"))
		{	*type = SOAP_TYPE_ns1__LicenseCriteria;
			return soap_in_ns1__LicenseCriteria(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Classification"))
		{	*type = SOAP_TYPE_ns1__Classification;
			return soap_in_ns1__Classification(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Label"))
		{	*type = SOAP_TYPE_ns1__Label;
			return soap_in_ns1__Label(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DesktopKeySetExtensions"))
		{	*type = SOAP_TYPE_ns1__DesktopKeySetExtensions;
			return soap_in_ns1__DesktopKeySetExtensions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClassificationSystemRef"))
		{	*type = SOAP_TYPE_ns1__ClassificationSystemRef;
			return soap_in_ns1__ClassificationSystemRef(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ClassificationSystem"))
		{	*type = SOAP_TYPE_ns1__ClassificationSystem;
			return soap_in_ns1__ClassificationSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:Domain_Role"))
		{	*type = SOAP_TYPE_ns6__Domain_USCORERole;
			return soap_in_ns6__Domain_USCORERole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DocumentRole_TimeConstraints"))
		{	*type = SOAP_TYPE_ns6__DocumentRole_USCORETimeConstraints;
			return soap_in_ns6__DocumentRole_USCORETimeConstraints(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:DocumentRole_ExportConstraints"))
		{	*type = SOAP_TYPE_ns6__DocumentRole_USCOREExportConstraints;
			return soap_in_ns6__DocumentRole_USCOREExportConstraints(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ContextTemplate_Status"))
		{	*type = SOAP_TYPE_ns6__ContextTemplate_USCOREStatus;
			return soap_in_ns6__ContextTemplate_USCOREStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ContextInstance_Role"))
		{	*type = SOAP_TYPE_ns6__ContextInstance_USCORERole;
			return soap_in_ns6__ContextInstance_USCORERole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:ContextInstance_Visibility"))
		{	*type = SOAP_TYPE_ns6__ContextInstance_USCOREVisibility;
			return soap_in_ns6__ContextInstance_USCOREVisibility(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns5:ItemConstraints_Type"))
		{	*type = SOAP_TYPE_ns5__ItemConstraints_USCOREType;
			return soap_in_ns5__ItemConstraints_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ContentParseFault_Reason"))
		{	*type = SOAP_TYPE_ns2__ContentParseFault_USCOREReason;
			return soap_in_ns2__ContentParseFault_USCOREReason(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Account_Type"))
		{	*type = SOAP_TYPE_ns1__Account_USCOREType;
			return soap_in_ns1__Account_USCOREType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RelativeTimeSpan_TimeBase"))
		{	*type = SOAP_TYPE_ns1__RelativeTimeSpan_USCORETimeBase;
			return soap_in_ns1__RelativeTimeSpan_USCORETimeBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TimePeriod_Units"))
		{	*type = SOAP_TYPE_ns1__TimePeriod_USCOREUnits;
			return soap_in_ns1__TimePeriod_USCOREUnits(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TimeSpan_ReferencePoint"))
		{	*type = SOAP_TYPE_ns1__TimeSpan_USCOREReferencePoint;
			return soap_in_ns1__TimeSpan_USCOREReferencePoint(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Feature_Use"))
		{	*type = SOAP_TYPE_ns1__Feature_USCOREUse;
			return soap_in_ns1__Feature_USCOREUse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Feature_Support"))
		{	*type = SOAP_TYPE_ns1__Feature_USCORESupport;
			return soap_in_ns1__Feature_USCORESupport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LicenseCriteria_Use"))
		{	*type = SOAP_TYPE_ns1__LicenseCriteria_USCOREUse;
			return soap_in_ns1__LicenseCriteria_USCOREUse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LicenseCriteria_Delivery"))
		{	*type = SOAP_TYPE_ns1__LicenseCriteria_USCOREDelivery;
			return soap_in_ns1__LicenseCriteria_USCOREDelivery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LicenseCriteria_Storage"))
		{	*type = SOAP_TYPE_ns1__LicenseCriteria_USCOREStorage;
			return soap_in_ns1__LicenseCriteria_USCOREStorage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns7:ListRightsByAccountResponse"))
		{	*type = SOAP_TYPE__ns7__ListRightsByAccountResponse;
			return soap_in__ns7__ListRightsByAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ListRightsByAccount"))
		{	*type = SOAP_TYPE__ns7__ListRightsByAccount;
			return soap_in__ns7__ListRightsByAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ListRightsByContextResponse"))
		{	*type = SOAP_TYPE__ns7__ListRightsByContextResponse;
			return soap_in__ns7__ListRightsByContextResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ListRightsByContext"))
		{	*type = SOAP_TYPE__ns7__ListRightsByContext;
			return soap_in__ns7__ListRightsByContext(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:UnassignRightsResponse"))
		{	*type = SOAP_TYPE__ns7__UnassignRightsResponse;
			return soap_in__ns7__UnassignRightsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:UnassignRights"))
		{	*type = SOAP_TYPE__ns7__UnassignRights;
			return soap_in__ns7__UnassignRights(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SaveChangesToItemsResponse"))
		{	*type = SOAP_TYPE__ns7__SaveChangesToItemsResponse;
			return soap_in__ns7__SaveChangesToItemsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:SaveChangesToItems"))
		{	*type = SOAP_TYPE__ns7__SaveChangesToItems;
			return soap_in__ns7__SaveChangesToItems(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:CheckInRightsForAccountResponse"))
		{	*type = SOAP_TYPE__ns7__CheckInRightsForAccountResponse;
			return soap_in__ns7__CheckInRightsForAccountResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:CheckInRightsForAccount"))
		{	*type = SOAP_TYPE__ns7__CheckInRightsForAccount;
			return soap_in__ns7__CheckInRightsForAccount(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ReassignRoleResponse"))
		{	*type = SOAP_TYPE__ns7__ReassignRoleResponse;
			return soap_in__ns7__ReassignRoleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:ReassignRole"))
		{	*type = SOAP_TYPE__ns7__ReassignRole;
			return soap_in__ns7__ReassignRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:AssignRoleResponse"))
		{	*type = SOAP_TYPE__ns7__AssignRoleResponse;
			return soap_in__ns7__AssignRoleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns7:AssignRole"))
		{	*type = SOAP_TYPE__ns7__AssignRole;
			return soap_in__ns7__AssignRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ValidatedPeekResponse"))
		{	*type = SOAP_TYPE__ns4__ValidatedPeekResponse;
			return soap_in__ns4__ValidatedPeekResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ValidatedPeek"))
		{	*type = SOAP_TYPE__ns4__ValidatedPeek;
			return soap_in__ns4__ValidatedPeek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PeekResponse"))
		{	*type = SOAP_TYPE__ns4__PeekResponse;
			return soap_in__ns4__PeekResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Peek"))
		{	*type = SOAP_TYPE__ns4__Peek;
			return soap_in__ns4__Peek(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ReclassifyResponse"))
		{	*type = SOAP_TYPE__ns4__ReclassifyResponse;
			return soap_in__ns4__ReclassifyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Reclassify"))
		{	*type = SOAP_TYPE__ns4__Reclassify;
			return soap_in__ns4__Reclassify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ResealResponse"))
		{	*type = SOAP_TYPE__ns4__ResealResponse;
			return soap_in__ns4__ResealResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Reseal"))
		{	*type = SOAP_TYPE__ns4__Reseal;
			return soap_in__ns4__Reseal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UnsealResponse"))
		{	*type = SOAP_TYPE__ns4__UnsealResponse;
			return soap_in__ns4__UnsealResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Unseal"))
		{	*type = SOAP_TYPE__ns4__Unseal;
			return soap_in__ns4__Unseal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:SealResponse"))
		{	*type = SOAP_TYPE__ns4__SealResponse;
			return soap_in__ns4__SealResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:Seal"))
		{	*type = SOAP_TYPE__ns4__Seal;
			return soap_in__ns4__Seal(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns6__Domain_USCORERole:
		return soap_out_ns6__Domain_USCORERole(soap, tag, id, (const enum ns6__Domain_USCORERole *)ptr, "ns6:Domain_Role");
	case SOAP_TYPE_ns6__DocumentRole_USCORETimeConstraints:
		return soap_out_ns6__DocumentRole_USCORETimeConstraints(soap, tag, id, (const enum ns6__DocumentRole_USCORETimeConstraints *)ptr, "ns6:DocumentRole_TimeConstraints");
	case SOAP_TYPE_ns6__DocumentRole_USCOREExportConstraints:
		return soap_out_ns6__DocumentRole_USCOREExportConstraints(soap, tag, id, (const enum ns6__DocumentRole_USCOREExportConstraints *)ptr, "ns6:DocumentRole_ExportConstraints");
	case SOAP_TYPE_ns6__ContextTemplate_USCOREStatus:
		return soap_out_ns6__ContextTemplate_USCOREStatus(soap, tag, id, (const enum ns6__ContextTemplate_USCOREStatus *)ptr, "ns6:ContextTemplate_Status");
	case SOAP_TYPE_ns6__ContextInstance_USCORERole:
		return soap_out_ns6__ContextInstance_USCORERole(soap, tag, id, (const enum ns6__ContextInstance_USCORERole *)ptr, "ns6:ContextInstance_Role");
	case SOAP_TYPE_ns6__ContextInstance_USCOREVisibility:
		return soap_out_ns6__ContextInstance_USCOREVisibility(soap, tag, id, (const enum ns6__ContextInstance_USCOREVisibility *)ptr, "ns6:ContextInstance_Visibility");
	case SOAP_TYPE_ns5__ItemConstraints_USCOREType:
		return soap_out_ns5__ItemConstraints_USCOREType(soap, tag, id, (const enum ns5__ItemConstraints_USCOREType *)ptr, "ns5:ItemConstraints_Type");
	case SOAP_TYPE_ns2__ContentParseFault_USCOREReason:
		return soap_out_ns2__ContentParseFault_USCOREReason(soap, tag, id, (const enum ns2__ContentParseFault_USCOREReason *)ptr, "ns2:ContentParseFault_Reason");
	case SOAP_TYPE_ns1__Account_USCOREType:
		return soap_out_ns1__Account_USCOREType(soap, tag, id, (const enum ns1__Account_USCOREType *)ptr, "ns1:Account_Type");
	case SOAP_TYPE_ns1__RelativeTimeSpan_USCORETimeBase:
		return soap_out_ns1__RelativeTimeSpan_USCORETimeBase(soap, tag, id, (const enum ns1__RelativeTimeSpan_USCORETimeBase *)ptr, "ns1:RelativeTimeSpan_TimeBase");
	case SOAP_TYPE_ns1__TimePeriod_USCOREUnits:
		return soap_out_ns1__TimePeriod_USCOREUnits(soap, tag, id, (const enum ns1__TimePeriod_USCOREUnits *)ptr, "ns1:TimePeriod_Units");
	case SOAP_TYPE_ns1__TimeSpan_USCOREReferencePoint:
		return soap_out_ns1__TimeSpan_USCOREReferencePoint(soap, tag, id, (const enum ns1__TimeSpan_USCOREReferencePoint *)ptr, "ns1:TimeSpan_ReferencePoint");
	case SOAP_TYPE_ns1__Feature_USCOREUse:
		return soap_out_ns1__Feature_USCOREUse(soap, tag, id, (const enum ns1__Feature_USCOREUse *)ptr, "ns1:Feature_Use");
	case SOAP_TYPE_ns1__Feature_USCORESupport:
		return soap_out_ns1__Feature_USCORESupport(soap, tag, id, (const enum ns1__Feature_USCORESupport *)ptr, "ns1:Feature_Support");
	case SOAP_TYPE_ns1__LicenseCriteria_USCOREUse:
		return soap_out_ns1__LicenseCriteria_USCOREUse(soap, tag, id, (const enum ns1__LicenseCriteria_USCOREUse *)ptr, "ns1:LicenseCriteria_Use");
	case SOAP_TYPE_ns1__LicenseCriteria_USCOREDelivery:
		return soap_out_ns1__LicenseCriteria_USCOREDelivery(soap, tag, id, (const enum ns1__LicenseCriteria_USCOREDelivery *)ptr, "ns1:LicenseCriteria_Delivery");
	case SOAP_TYPE_ns1__LicenseCriteria_USCOREStorage:
		return soap_out_ns1__LicenseCriteria_USCOREStorage(soap, tag, id, (const enum ns1__LicenseCriteria_USCOREStorage *)ptr, "ns1:LicenseCriteria_Storage");
	case SOAP_TYPE__ns7__ListRightsByAccountResponse:
		return ((_ns7__ListRightsByAccountResponse *)ptr)->soap_out(soap, "ns7:ListRightsByAccountResponse", id, NULL);
	case SOAP_TYPE__ns7__ListRightsByAccount:
		return ((_ns7__ListRightsByAccount *)ptr)->soap_out(soap, "ns7:ListRightsByAccount", id, NULL);
	case SOAP_TYPE__ns7__ListRightsByContextResponse:
		return ((_ns7__ListRightsByContextResponse *)ptr)->soap_out(soap, "ns7:ListRightsByContextResponse", id, NULL);
	case SOAP_TYPE__ns7__ListRightsByContext:
		return ((_ns7__ListRightsByContext *)ptr)->soap_out(soap, "ns7:ListRightsByContext", id, NULL);
	case SOAP_TYPE__ns7__UnassignRightsResponse:
		return ((_ns7__UnassignRightsResponse *)ptr)->soap_out(soap, "ns7:UnassignRightsResponse", id, NULL);
	case SOAP_TYPE__ns7__UnassignRights:
		return ((_ns7__UnassignRights *)ptr)->soap_out(soap, "ns7:UnassignRights", id, NULL);
	case SOAP_TYPE__ns7__SaveChangesToItemsResponse:
		return ((_ns7__SaveChangesToItemsResponse *)ptr)->soap_out(soap, "ns7:SaveChangesToItemsResponse", id, NULL);
	case SOAP_TYPE__ns7__SaveChangesToItems:
		return ((_ns7__SaveChangesToItems *)ptr)->soap_out(soap, "ns7:SaveChangesToItems", id, NULL);
	case SOAP_TYPE__ns7__CheckInRightsForAccountResponse:
		return ((_ns7__CheckInRightsForAccountResponse *)ptr)->soap_out(soap, "ns7:CheckInRightsForAccountResponse", id, NULL);
	case SOAP_TYPE__ns7__CheckInRightsForAccount:
		return ((_ns7__CheckInRightsForAccount *)ptr)->soap_out(soap, "ns7:CheckInRightsForAccount", id, NULL);
	case SOAP_TYPE__ns7__ReassignRoleResponse:
		return ((_ns7__ReassignRoleResponse *)ptr)->soap_out(soap, "ns7:ReassignRoleResponse", id, NULL);
	case SOAP_TYPE__ns7__ReassignRole:
		return ((_ns7__ReassignRole *)ptr)->soap_out(soap, "ns7:ReassignRole", id, NULL);
	case SOAP_TYPE__ns7__AssignRoleResponse:
		return ((_ns7__AssignRoleResponse *)ptr)->soap_out(soap, "ns7:AssignRoleResponse", id, NULL);
	case SOAP_TYPE__ns7__AssignRole:
		return ((_ns7__AssignRole *)ptr)->soap_out(soap, "ns7:AssignRole", id, NULL);
	case SOAP_TYPE_ns6__UnknownDocumentRightFault:
		return ((ns6__UnknownDocumentRightFault *)ptr)->soap_out(soap, tag, id, "ns6:UnknownDocumentRightFault");
	case SOAP_TYPE_ns6__UnknownDocumentRoleFault:
		return ((ns6__UnknownDocumentRoleFault *)ptr)->soap_out(soap, tag, id, "ns6:UnknownDocumentRoleFault");
	case SOAP_TYPE_ns6__UnsupportedDocumentRoleFault:
		return ((ns6__UnsupportedDocumentRoleFault *)ptr)->soap_out(soap, tag, id, "ns6:UnsupportedDocumentRoleFault");
	case SOAP_TYPE_ns6__AccountAlreadyAssignedFault:
		return ((ns6__AccountAlreadyAssignedFault *)ptr)->soap_out(soap, tag, id, "ns6:AccountAlreadyAssignedFault");
	case SOAP_TYPE_ns6__DocumentRightRef:
		return ((ns6__DocumentRightRef *)ptr)->soap_out(soap, tag, id, "ns6:DocumentRightRef");
	case SOAP_TYPE_ns6__DocumentRight:
		return ((ns6__DocumentRight *)ptr)->soap_out(soap, tag, id, "ns6:DocumentRight");
	case SOAP_TYPE_ns6__DomainRef:
		return ((ns6__DomainRef *)ptr)->soap_out(soap, tag, id, "ns6:DomainRef");
	case SOAP_TYPE_ns6__Domain:
		return ((ns6__Domain *)ptr)->soap_out(soap, tag, id, "ns6:Domain");
	case SOAP_TYPE_ns6__DocumentRoleRef:
		return ((ns6__DocumentRoleRef *)ptr)->soap_out(soap, tag, id, "ns6:DocumentRoleRef");
	case SOAP_TYPE_ns6__DocumentRole:
		return ((ns6__DocumentRole *)ptr)->soap_out(soap, tag, id, "ns6:DocumentRole");
	case SOAP_TYPE_ns6__ContextTemplateRef:
		return ((ns6__ContextTemplateRef *)ptr)->soap_out(soap, tag, id, "ns6:ContextTemplateRef");
	case SOAP_TYPE_ns6__ContextTemplate:
		return ((ns6__ContextTemplate *)ptr)->soap_out(soap, tag, id, "ns6:ContextTemplate");
	case SOAP_TYPE_ns6__ContextInstanceRef:
		return ((ns6__ContextInstanceRef *)ptr)->soap_out(soap, tag, id, "ns6:ContextInstanceRef");
	case SOAP_TYPE_ns6__ContextInstance:
		return ((ns6__ContextInstance *)ptr)->soap_out(soap, tag, id, "ns6:ContextInstance");
	case SOAP_TYPE_ns5__UnknownContextFault:
		return ((ns5__UnknownContextFault *)ptr)->soap_out(soap, tag, id, "ns5:UnknownContextFault");
	case SOAP_TYPE_ns5__ItemConstraints:
		return ((ns5__ItemConstraints *)ptr)->soap_out(soap, tag, id, "ns5:ItemConstraints");
	case SOAP_TYPE_ns5__ContextRef:
		return ((ns5__ContextRef *)ptr)->soap_out(soap, tag, id, "ns5:ContextRef");
	case SOAP_TYPE_ns5__Context:
		return ((ns5__Context *)ptr)->soap_out(soap, tag, id, "ns5:Context");
	case SOAP_TYPE_ns5__ItemCode:
		return ((ns5__ItemCode *)ptr)->soap_out(soap, tag, id, "ns5:ItemCode");
	case SOAP_TYPE__ns4__ValidatedPeekResponse:
		return ((_ns4__ValidatedPeekResponse *)ptr)->soap_out(soap, "ns4:ValidatedPeekResponse", id, NULL);
	case SOAP_TYPE__ns4__ValidatedPeek:
		return ((_ns4__ValidatedPeek *)ptr)->soap_out(soap, "ns4:ValidatedPeek", id, NULL);
	case SOAP_TYPE__ns4__PeekResponse:
		return ((_ns4__PeekResponse *)ptr)->soap_out(soap, "ns4:PeekResponse", id, NULL);
	case SOAP_TYPE__ns4__Peek:
		return ((_ns4__Peek *)ptr)->soap_out(soap, "ns4:Peek", id, NULL);
	case SOAP_TYPE__ns4__ReclassifyResponse:
		return ((_ns4__ReclassifyResponse *)ptr)->soap_out(soap, "ns4:ReclassifyResponse", id, NULL);
	case SOAP_TYPE__ns4__Reclassify:
		return ((_ns4__Reclassify *)ptr)->soap_out(soap, "ns4:Reclassify", id, NULL);
	case SOAP_TYPE__ns4__ResealResponse:
		return ((_ns4__ResealResponse *)ptr)->soap_out(soap, "ns4:ResealResponse", id, NULL);
	case SOAP_TYPE__ns4__Reseal:
		return ((_ns4__Reseal *)ptr)->soap_out(soap, "ns4:Reseal", id, NULL);
	case SOAP_TYPE__ns4__UnsealResponse:
		return ((_ns4__UnsealResponse *)ptr)->soap_out(soap, "ns4:UnsealResponse", id, NULL);
	case SOAP_TYPE__ns4__Unseal:
		return ((_ns4__Unseal *)ptr)->soap_out(soap, "ns4:Unseal", id, NULL);
	case SOAP_TYPE__ns4__SealResponse:
		return ((_ns4__SealResponse *)ptr)->soap_out(soap, "ns4:SealResponse", id, NULL);
	case SOAP_TYPE__ns4__Seal:
		return ((_ns4__Seal *)ptr)->soap_out(soap, "ns4:Seal", id, NULL);
	case SOAP_TYPE_ns3__AuthorizationDeniedFault:
		return ((ns3__AuthorizationDeniedFault *)ptr)->soap_out(soap, tag, id, "ns3:AuthorizationDeniedFault");
	case SOAP_TYPE_ns2__ContentParseFault:
		return ((ns2__ContentParseFault *)ptr)->soap_out(soap, tag, id, "ns2:ContentParseFault");
	case SOAP_TYPE_ns2__PublicHeaderLengthFault:
		return ((ns2__PublicHeaderLengthFault *)ptr)->soap_out(soap, tag, id, "ns2:PublicHeaderLengthFault");
	case SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault:
		return ((ns2__IllegalEncryptedContentBlockSizeFault *)ptr)->soap_out(soap, tag, id, "ns2:IllegalEncryptedContentBlockSizeFault");
	case SOAP_TYPE_ns2__UnsupportedContentTypeFault:
		return ((ns2__UnsupportedContentTypeFault *)ptr)->soap_out(soap, tag, id, "ns2:UnsupportedContentTypeFault");
	case SOAP_TYPE_ns2__ContentDescription:
		return ((ns2__ContentDescription *)ptr)->soap_out(soap, tag, id, "ns2:ContentDescription");
	case SOAP_TYPE_ns2__SealingOptions:
		return ((ns2__SealingOptions *)ptr)->soap_out(soap, tag, id, "ns2:SealingOptions");
	case SOAP_TYPE_ns2__EncryptionOptions:
		return ((ns2__EncryptionOptions *)ptr)->soap_out(soap, tag, id, "ns2:EncryptionOptions");
	case SOAP_TYPE_ns2__ContentSchema:
		return ((ns2__ContentSchema *)ptr)->soap_out(soap, tag, id, "ns2:ContentSchema");
	case SOAP_TYPE_ns2__SchemaVersion:
		return ((ns2__SchemaVersion *)ptr)->soap_out(soap, tag, id, "ns2:SchemaVersion");
	case SOAP_TYPE_ns2__CustomData:
		return ((ns2__CustomData *)ptr)->soap_out(soap, tag, id, "ns2:CustomData");
	case SOAP_TYPE_ns2__KeySetRef:
		return ((ns2__KeySetRef *)ptr)->soap_out(soap, tag, id, "ns2:KeySetRef");
	case SOAP_TYPE_ns2__KeySet:
		return ((ns2__KeySet *)ptr)->soap_out(soap, tag, id, "ns2:KeySet");
	case SOAP_TYPE_ns2__KeySetExtensions:
		return ((ns2__KeySetExtensions *)ptr)->soap_out(soap, tag, id, "ns2:KeySetExtensions");
	case SOAP_TYPE_ns2__WrappedKeySetExtensions:
		return ((ns2__WrappedKeySetExtensions *)ptr)->soap_out(soap, tag, id, "ns2:WrappedKeySetExtensions");
	case SOAP_TYPE_ns2__RawKeySetExtensions:
		return ((ns2__RawKeySetExtensions *)ptr)->soap_out(soap, tag, id, "ns2:RawKeySetExtensions");
	case SOAP_TYPE_ns2__CryptoSchemaRef:
		return ((ns2__CryptoSchemaRef *)ptr)->soap_out(soap, tag, id, "ns2:CryptoSchemaRef");
	case SOAP_TYPE_ns2__CryptoSchema:
		return ((ns2__CryptoSchema *)ptr)->soap_out(soap, tag, id, "ns2:CryptoSchema");
	case SOAP_TYPE_ns1__PageRange:
		return ((ns1__PageRange *)ptr)->soap_out(soap, tag, id, "ns1:PageRange");
	case SOAP_TYPE_ns1__AccountRef:
		return ((ns1__AccountRef *)ptr)->soap_out(soap, tag, id, "ns1:AccountRef");
	case SOAP_TYPE_ns1__Account:
		return ((ns1__Account *)ptr)->soap_out(soap, tag, id, "ns1:Account");
	case SOAP_TYPE_ns1__XPathExpression:
		return ((ns1__XPathExpression *)ptr)->soap_out(soap, tag, id, "ns1:XPathExpression");
	case SOAP_TYPE_ns1__XPathClassificationFilter:
		return ((ns1__XPathClassificationFilter *)ptr)->soap_out(soap, tag, id, "ns1:XPathClassificationFilter");
	case SOAP_TYPE_ns1__AbsoluteTimeSpan:
		return ((ns1__AbsoluteTimeSpan *)ptr)->soap_out(soap, tag, id, "ns1:AbsoluteTimeSpan");
	case SOAP_TYPE_ns1__RelativeTimeSpan:
		return ((ns1__RelativeTimeSpan *)ptr)->soap_out(soap, tag, id, "ns1:RelativeTimeSpan");
	case SOAP_TYPE_ns1__ClassificationFilter:
		return ((ns1__ClassificationFilter *)ptr)->soap_out(soap, tag, id, "ns1:ClassificationFilter");
	case SOAP_TYPE_ns1__TimePeriod:
		return ((ns1__TimePeriod *)ptr)->soap_out(soap, tag, id, "ns1:TimePeriod");
	case SOAP_TYPE_ns1__TimeSpan:
		return ((ns1__TimeSpan *)ptr)->soap_out(soap, tag, id, "ns1:TimeSpan");
	case SOAP_TYPE_ns1__Feature:
		return ((ns1__Feature *)ptr)->soap_out(soap, tag, id, "ns1:Feature");
	case SOAP_TYPE_ns1__LicenseCriteria:
		return ((ns1__LicenseCriteria *)ptr)->soap_out(soap, tag, id, "ns1:LicenseCriteria");
	case SOAP_TYPE_ns1__Classification:
		return ((ns1__Classification *)ptr)->soap_out(soap, tag, id, "ns1:Classification");
	case SOAP_TYPE_ns1__Label:
		return ((ns1__Label *)ptr)->soap_out(soap, tag, id, "ns1:Label");
	case SOAP_TYPE_ns1__DesktopKeySetExtensions:
		return ((ns1__DesktopKeySetExtensions *)ptr)->soap_out(soap, tag, id, "ns1:DesktopKeySetExtensions");
	case SOAP_TYPE_ns1__ClassificationSystemRef:
		return ((ns1__ClassificationSystemRef *)ptr)->soap_out(soap, tag, id, "ns1:ClassificationSystemRef");
	case SOAP_TYPE_ns1__ClassificationSystem:
		return ((ns1__ClassificationSystem *)ptr)->soap_out(soap, tag, id, "ns1:ClassificationSystem");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const xsd__QName *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_ns7__ListRightsByAccountResponse:
		return soap_out_PointerTo_ns7__ListRightsByAccountResponse(soap, tag, id, (_ns7__ListRightsByAccountResponse *const*)ptr, "ns7:ListRightsByAccountResponse");
	case SOAP_TYPE_PointerTo_ns7__ListRightsByAccount:
		return soap_out_PointerTo_ns7__ListRightsByAccount(soap, tag, id, (_ns7__ListRightsByAccount *const*)ptr, "ns7:ListRightsByAccount");
	case SOAP_TYPE_PointerTo_ns7__ListRightsByContextResponse:
		return soap_out_PointerTo_ns7__ListRightsByContextResponse(soap, tag, id, (_ns7__ListRightsByContextResponse *const*)ptr, "ns7:ListRightsByContextResponse");
	case SOAP_TYPE_PointerTo_ns7__ListRightsByContext:
		return soap_out_PointerTo_ns7__ListRightsByContext(soap, tag, id, (_ns7__ListRightsByContext *const*)ptr, "ns7:ListRightsByContext");
	case SOAP_TYPE_PointerTo_ns7__UnassignRightsResponse:
		return soap_out_PointerTo_ns7__UnassignRightsResponse(soap, tag, id, (_ns7__UnassignRightsResponse *const*)ptr, "ns7:UnassignRightsResponse");
	case SOAP_TYPE_PointerTo_ns7__UnassignRights:
		return soap_out_PointerTo_ns7__UnassignRights(soap, tag, id, (_ns7__UnassignRights *const*)ptr, "ns7:UnassignRights");
	case SOAP_TYPE_PointerTo_ns7__SaveChangesToItemsResponse:
		return soap_out_PointerTo_ns7__SaveChangesToItemsResponse(soap, tag, id, (_ns7__SaveChangesToItemsResponse *const*)ptr, "ns7:SaveChangesToItemsResponse");
	case SOAP_TYPE_PointerTo_ns7__SaveChangesToItems:
		return soap_out_PointerTo_ns7__SaveChangesToItems(soap, tag, id, (_ns7__SaveChangesToItems *const*)ptr, "ns7:SaveChangesToItems");
	case SOAP_TYPE_PointerTo_ns7__CheckInRightsForAccountResponse:
		return soap_out_PointerTo_ns7__CheckInRightsForAccountResponse(soap, tag, id, (_ns7__CheckInRightsForAccountResponse *const*)ptr, "ns7:CheckInRightsForAccountResponse");
	case SOAP_TYPE_PointerTo_ns7__CheckInRightsForAccount:
		return soap_out_PointerTo_ns7__CheckInRightsForAccount(soap, tag, id, (_ns7__CheckInRightsForAccount *const*)ptr, "ns7:CheckInRightsForAccount");
	case SOAP_TYPE_PointerTo_ns7__ReassignRoleResponse:
		return soap_out_PointerTo_ns7__ReassignRoleResponse(soap, tag, id, (_ns7__ReassignRoleResponse *const*)ptr, "ns7:ReassignRoleResponse");
	case SOAP_TYPE_PointerTo_ns7__ReassignRole:
		return soap_out_PointerTo_ns7__ReassignRole(soap, tag, id, (_ns7__ReassignRole *const*)ptr, "ns7:ReassignRole");
	case SOAP_TYPE_PointerTo_ns7__AssignRoleResponse:
		return soap_out_PointerTo_ns7__AssignRoleResponse(soap, tag, id, (_ns7__AssignRoleResponse *const*)ptr, "ns7:AssignRoleResponse");
	case SOAP_TYPE_PointerTo_ns7__AssignRole:
		return soap_out_PointerTo_ns7__AssignRole(soap, tag, id, (_ns7__AssignRole *const*)ptr, "ns7:AssignRole");
	case SOAP_TYPE_PointerTo_ns4__ValidatedPeekResponse:
		return soap_out_PointerTo_ns4__ValidatedPeekResponse(soap, tag, id, (_ns4__ValidatedPeekResponse *const*)ptr, "ns4:ValidatedPeekResponse");
	case SOAP_TYPE_PointerTo_ns4__ValidatedPeek:
		return soap_out_PointerTo_ns4__ValidatedPeek(soap, tag, id, (_ns4__ValidatedPeek *const*)ptr, "ns4:ValidatedPeek");
	case SOAP_TYPE_PointerTo_ns4__PeekResponse:
		return soap_out_PointerTo_ns4__PeekResponse(soap, tag, id, (_ns4__PeekResponse *const*)ptr, "ns4:PeekResponse");
	case SOAP_TYPE_PointerTo_ns4__Peek:
		return soap_out_PointerTo_ns4__Peek(soap, tag, id, (_ns4__Peek *const*)ptr, "ns4:Peek");
	case SOAP_TYPE_PointerTo_ns4__ReclassifyResponse:
		return soap_out_PointerTo_ns4__ReclassifyResponse(soap, tag, id, (_ns4__ReclassifyResponse *const*)ptr, "ns4:ReclassifyResponse");
	case SOAP_TYPE_PointerTo_ns4__Reclassify:
		return soap_out_PointerTo_ns4__Reclassify(soap, tag, id, (_ns4__Reclassify *const*)ptr, "ns4:Reclassify");
	case SOAP_TYPE_PointerTo_ns4__ResealResponse:
		return soap_out_PointerTo_ns4__ResealResponse(soap, tag, id, (_ns4__ResealResponse *const*)ptr, "ns4:ResealResponse");
	case SOAP_TYPE_PointerTo_ns4__Reseal:
		return soap_out_PointerTo_ns4__Reseal(soap, tag, id, (_ns4__Reseal *const*)ptr, "ns4:Reseal");
	case SOAP_TYPE_PointerTo_ns4__UnsealResponse:
		return soap_out_PointerTo_ns4__UnsealResponse(soap, tag, id, (_ns4__UnsealResponse *const*)ptr, "ns4:UnsealResponse");
	case SOAP_TYPE_PointerTo_ns4__Unseal:
		return soap_out_PointerTo_ns4__Unseal(soap, tag, id, (_ns4__Unseal *const*)ptr, "ns4:Unseal");
	case SOAP_TYPE_PointerTo_ns4__SealResponse:
		return soap_out_PointerTo_ns4__SealResponse(soap, tag, id, (_ns4__SealResponse *const*)ptr, "ns4:SealResponse");
	case SOAP_TYPE_PointerTo_ns4__Seal:
		return soap_out_PointerTo_ns4__Seal(soap, tag, id, (_ns4__Seal *const*)ptr, "ns4:Seal");
	case SOAP_TYPE_PointerTons6__UnsupportedDocumentRoleFault:
		return soap_out_PointerTons6__UnsupportedDocumentRoleFault(soap, tag, id, (ns6__UnsupportedDocumentRoleFault *const*)ptr, "ns6:UnsupportedDocumentRoleFault");
	case SOAP_TYPE_PointerTons6__UnknownDocumentRoleFault:
		return soap_out_PointerTons6__UnknownDocumentRoleFault(soap, tag, id, (ns6__UnknownDocumentRoleFault *const*)ptr, "ns6:UnknownDocumentRoleFault");
	case SOAP_TYPE_PointerTons6__UnknownDocumentRightFault:
		return soap_out_PointerTons6__UnknownDocumentRightFault(soap, tag, id, (ns6__UnknownDocumentRightFault *const*)ptr, "ns6:UnknownDocumentRightFault");
	case SOAP_TYPE_PointerTons5__UnknownContextFault:
		return soap_out_PointerTons5__UnknownContextFault(soap, tag, id, (ns5__UnknownContextFault *const*)ptr, "ns5:UnknownContextFault");
	case SOAP_TYPE_PointerTons6__AccountAlreadyAssignedFault:
		return soap_out_PointerTons6__AccountAlreadyAssignedFault(soap, tag, id, (ns6__AccountAlreadyAssignedFault *const*)ptr, "ns6:AccountAlreadyAssignedFault");
	case SOAP_TYPE_PointerTons2__UnsupportedContentTypeFault:
		return soap_out_PointerTons2__UnsupportedContentTypeFault(soap, tag, id, (ns2__UnsupportedContentTypeFault *const*)ptr, "ns2:UnsupportedContentTypeFault");
	case SOAP_TYPE_PointerTons2__PublicHeaderLengthFault:
		return soap_out_PointerTons2__PublicHeaderLengthFault(soap, tag, id, (ns2__PublicHeaderLengthFault *const*)ptr, "ns2:PublicHeaderLengthFault");
	case SOAP_TYPE_PointerTons2__IllegalEncryptedContentBlockSizeFault:
		return soap_out_PointerTons2__IllegalEncryptedContentBlockSizeFault(soap, tag, id, (ns2__IllegalEncryptedContentBlockSizeFault *const*)ptr, "ns2:IllegalEncryptedContentBlockSizeFault");
	case SOAP_TYPE_PointerTons2__ContentParseFault:
		return soap_out_PointerTons2__ContentParseFault(soap, tag, id, (ns2__ContentParseFault *const*)ptr, "ns2:ContentParseFault");
	case SOAP_TYPE_PointerTons3__AuthorizationDeniedFault:
		return soap_out_PointerTons3__AuthorizationDeniedFault(soap, tag, id, (ns3__AuthorizationDeniedFault *const*)ptr, "ns3:AuthorizationDeniedFault");
	case SOAP_TYPE_PointerTons6__ContextTemplateRef:
		return soap_out_PointerTons6__ContextTemplateRef(soap, tag, id, (ns6__ContextTemplateRef *const*)ptr, "ns6:ContextTemplateRef");
	case SOAP_TYPE_PointerTons1__XPathExpression:
		return soap_out_PointerTons1__XPathExpression(soap, tag, id, (ns1__XPathExpression *const*)ptr, "ns1:XPathExpression");
	case SOAP_TYPE_PointerTons1__PageRange:
		return soap_out_PointerTons1__PageRange(soap, tag, id, (ns1__PageRange *const*)ptr, "ns1:PageRange");
	case SOAP_TYPE_PointerTons6__DocumentRightRef:
		return soap_out_PointerTons6__DocumentRightRef(soap, tag, id, (ns6__DocumentRightRef *const*)ptr, "ns6:DocumentRightRef");
	case SOAP_TYPE_PointerTons6__DocumentRight:
		return soap_out_PointerTons6__DocumentRight(soap, tag, id, (ns6__DocumentRight *const*)ptr, "ns6:DocumentRight");
	case SOAP_TYPE_PointerTons6__ContextInstanceRef:
		return soap_out_PointerTons6__ContextInstanceRef(soap, tag, id, (ns6__ContextInstanceRef *const*)ptr, "ns6:ContextInstanceRef");
	case SOAP_TYPE_PointerTons6__DocumentRole:
		return soap_out_PointerTons6__DocumentRole(soap, tag, id, (ns6__DocumentRole *const*)ptr, "ns6:DocumentRole");
	case SOAP_TYPE_PointerTons1__AccountRef:
		return soap_out_PointerTons1__AccountRef(soap, tag, id, (ns1__AccountRef *const*)ptr, "ns1:AccountRef");
	case SOAP_TYPE_PointerTons6__DomainRef:
		return soap_out_PointerTons6__DomainRef(soap, tag, id, (ns6__DomainRef *const*)ptr, "ns6:DomainRef");
	case SOAP_TYPE_PointerTons6__DocumentRoleRef:
		return soap_out_PointerTons6__DocumentRoleRef(soap, tag, id, (ns6__DocumentRoleRef *const*)ptr, "ns6:DocumentRoleRef");
	case SOAP_TYPE_PointerTons5__ItemCode:
		return soap_out_PointerTons5__ItemCode(soap, tag, id, (ns5__ItemCode *const*)ptr, "ns5:ItemCode");
	case SOAP_TYPE_PointerTons2__ContentDescription:
		return soap_out_PointerTons2__ContentDescription(soap, tag, id, (ns2__ContentDescription *const*)ptr, "ns2:ContentDescription");
	case SOAP_TYPE_PointerTons2__SealingOptions:
		return soap_out_PointerTons2__SealingOptions(soap, tag, id, (ns2__SealingOptions *const*)ptr, "ns2:SealingOptions");
	case SOAP_TYPE_PointerTons2__EncryptionOptions:
		return soap_out_PointerTons2__EncryptionOptions(soap, tag, id, (ns2__EncryptionOptions *const*)ptr, "ns2:EncryptionOptions");
	case SOAP_TYPE_PointerTons2__ContentSchema:
		return soap_out_PointerTons2__ContentSchema(soap, tag, id, (ns2__ContentSchema *const*)ptr, "ns2:ContentSchema");
	case SOAP_TYPE_PointerTons2__CustomData:
		return soap_out_PointerTons2__CustomData(soap, tag, id, (ns2__CustomData *const*)ptr, "ns2:CustomData");
	case SOAP_TYPE_PointerTons1__Classification:
		return soap_out_PointerTons1__Classification(soap, tag, id, (ns1__Classification *const*)ptr, "ns1:Classification");
	case SOAP_TYPE_PointerTons2__SchemaVersion:
		return soap_out_PointerTons2__SchemaVersion(soap, tag, id, (ns2__SchemaVersion *const*)ptr, "ns2:SchemaVersion");
	case SOAP_TYPE_PointerTons2__KeySetExtensions:
		return soap_out_PointerTons2__KeySetExtensions(soap, tag, id, (ns2__KeySetExtensions *const*)ptr, "ns2:KeySetExtensions");
	case SOAP_TYPE_PointerTons2__CryptoSchemaRef:
		return soap_out_PointerTons2__CryptoSchemaRef(soap, tag, id, (ns2__CryptoSchemaRef *const*)ptr, "ns2:CryptoSchemaRef");
	case SOAP_TYPE_PointerTons1__ClassificationFilter:
		return soap_out_PointerTons1__ClassificationFilter(soap, tag, id, (ns1__ClassificationFilter *const*)ptr, "ns1:ClassificationFilter");
	case SOAP_TYPE_PointerTons1__TimePeriod:
		return soap_out_PointerTons1__TimePeriod(soap, tag, id, (ns1__TimePeriod *const*)ptr, "ns1:TimePeriod");
	case SOAP_TYPE_PointerTons1__TimeSpan:
		return soap_out_PointerTons1__TimeSpan(soap, tag, id, (ns1__TimeSpan *const*)ptr, "ns1:TimeSpan");
	case SOAP_TYPE_PointerTons1__Feature:
		return soap_out_PointerTons1__Feature(soap, tag, id, (ns1__Feature *const*)ptr, "ns1:Feature");
	case SOAP_TYPE_PointerTons1__Label:
		return soap_out_PointerTons1__Label(soap, tag, id, (ns1__Label *const*)ptr, "ns1:Label");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons2__KeySetRef:
		return soap_out_PointerTons2__KeySetRef(soap, tag, id, (ns2__KeySetRef *const*)ptr, "ns2:KeySetRef");
	case SOAP_TYPE_PointerTons1__ClassificationSystemRef:
		return soap_out_PointerTons1__ClassificationSystemRef(soap, tag, id, (ns1__ClassificationSystemRef *const*)ptr, "ns1:ClassificationSystemRef");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns7__ListRightsByAccountResponse:
		((_ns7__ListRightsByAccountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__ListRightsByAccount:
		((_ns7__ListRightsByAccount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__ListRightsByContextResponse:
		((_ns7__ListRightsByContextResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__ListRightsByContext:
		((_ns7__ListRightsByContext *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__UnassignRightsResponse:
		((_ns7__UnassignRightsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__UnassignRights:
		((_ns7__UnassignRights *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__SaveChangesToItemsResponse:
		((_ns7__SaveChangesToItemsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__SaveChangesToItems:
		((_ns7__SaveChangesToItems *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__CheckInRightsForAccountResponse:
		((_ns7__CheckInRightsForAccountResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__CheckInRightsForAccount:
		((_ns7__CheckInRightsForAccount *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__ReassignRoleResponse:
		((_ns7__ReassignRoleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__ReassignRole:
		((_ns7__ReassignRole *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__AssignRoleResponse:
		((_ns7__AssignRoleResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns7__AssignRole:
		((_ns7__AssignRole *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__UnknownDocumentRightFault:
		((ns6__UnknownDocumentRightFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__UnknownDocumentRoleFault:
		((ns6__UnknownDocumentRoleFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__UnsupportedDocumentRoleFault:
		((ns6__UnsupportedDocumentRoleFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__AccountAlreadyAssignedFault:
		((ns6__AccountAlreadyAssignedFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__DocumentRightRef:
		((ns6__DocumentRightRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__DocumentRight:
		((ns6__DocumentRight *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__DomainRef:
		((ns6__DomainRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__Domain:
		((ns6__Domain *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__DocumentRoleRef:
		((ns6__DocumentRoleRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__DocumentRole:
		((ns6__DocumentRole *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ContextTemplateRef:
		((ns6__ContextTemplateRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ContextTemplate:
		((ns6__ContextTemplate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ContextInstanceRef:
		((ns6__ContextInstanceRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__ContextInstance:
		((ns6__ContextInstance *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__UnknownContextFault:
		((ns5__UnknownContextFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ItemConstraints:
		((ns5__ItemConstraints *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ContextRef:
		((ns5__ContextRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__Context:
		((ns5__Context *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__ItemCode:
		((ns5__ItemCode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__ValidatedPeekResponse:
		((_ns4__ValidatedPeekResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__ValidatedPeek:
		((_ns4__ValidatedPeek *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__PeekResponse:
		((_ns4__PeekResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__Peek:
		((_ns4__Peek *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__ReclassifyResponse:
		((_ns4__ReclassifyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__Reclassify:
		((_ns4__Reclassify *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__ResealResponse:
		((_ns4__ResealResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__Reseal:
		((_ns4__Reseal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__UnsealResponse:
		((_ns4__UnsealResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__Unseal:
		((_ns4__Unseal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__SealResponse:
		((_ns4__SealResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns4__Seal:
		((_ns4__Seal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__AuthorizationDeniedFault:
		((ns3__AuthorizationDeniedFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentParseFault:
		((ns2__ContentParseFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__PublicHeaderLengthFault:
		((ns2__PublicHeaderLengthFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault:
		((ns2__IllegalEncryptedContentBlockSizeFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__UnsupportedContentTypeFault:
		((ns2__UnsupportedContentTypeFault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentDescription:
		((ns2__ContentDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SealingOptions:
		((ns2__SealingOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EncryptionOptions:
		((ns2__EncryptionOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ContentSchema:
		((ns2__ContentSchema *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SchemaVersion:
		((ns2__SchemaVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CustomData:
		((ns2__CustomData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__KeySetRef:
		((ns2__KeySetRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__KeySet:
		((ns2__KeySet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__KeySetExtensions:
		((ns2__KeySetExtensions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__WrappedKeySetExtensions:
		((ns2__WrappedKeySetExtensions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RawKeySetExtensions:
		((ns2__RawKeySetExtensions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CryptoSchemaRef:
		((ns2__CryptoSchemaRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__CryptoSchema:
		((ns2__CryptoSchema *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PageRange:
		((ns1__PageRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AccountRef:
		((ns1__AccountRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Account:
		((ns1__Account *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__XPathExpression:
		((ns1__XPathExpression *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__XPathClassificationFilter:
		((ns1__XPathClassificationFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AbsoluteTimeSpan:
		((ns1__AbsoluteTimeSpan *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RelativeTimeSpan:
		((ns1__RelativeTimeSpan *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ClassificationFilter:
		((ns1__ClassificationFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TimePeriod:
		((ns1__TimePeriod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TimeSpan:
		((ns1__TimeSpan *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Feature:
		((ns1__Feature *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LicenseCriteria:
		((ns1__LicenseCriteria *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Classification:
		((ns1__Classification *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Label:
		((ns1__Label *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DesktopKeySetExtensions:
		((ns1__DesktopKeySetExtensions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ClassificationSystemRef:
		((ns1__ClassificationSystemRef *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ClassificationSystem:
		((ns1__ClassificationSystem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const xsd__QName *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE___ns7__ListRightsByAccount:
		soap_serialize___ns7__ListRightsByAccount(soap, (const struct __ns7__ListRightsByAccount *)ptr);
		break;
	case SOAP_TYPE___ns7__ListRightsByContext:
		soap_serialize___ns7__ListRightsByContext(soap, (const struct __ns7__ListRightsByContext *)ptr);
		break;
	case SOAP_TYPE___ns7__UnassignRights:
		soap_serialize___ns7__UnassignRights(soap, (const struct __ns7__UnassignRights *)ptr);
		break;
	case SOAP_TYPE___ns7__SaveChangesToItems:
		soap_serialize___ns7__SaveChangesToItems(soap, (const struct __ns7__SaveChangesToItems *)ptr);
		break;
	case SOAP_TYPE___ns7__CheckInRightsForAccount:
		soap_serialize___ns7__CheckInRightsForAccount(soap, (const struct __ns7__CheckInRightsForAccount *)ptr);
		break;
	case SOAP_TYPE___ns7__ReassignRole:
		soap_serialize___ns7__ReassignRole(soap, (const struct __ns7__ReassignRole *)ptr);
		break;
	case SOAP_TYPE___ns7__AssignRole:
		soap_serialize___ns7__AssignRole(soap, (const struct __ns7__AssignRole *)ptr);
		break;
	case SOAP_TYPE___ns4__ValidatedPeek:
		soap_serialize___ns4__ValidatedPeek(soap, (const struct __ns4__ValidatedPeek *)ptr);
		break;
	case SOAP_TYPE___ns4__Peek:
		soap_serialize___ns4__Peek(soap, (const struct __ns4__Peek *)ptr);
		break;
	case SOAP_TYPE___ns4__Reclassify:
		soap_serialize___ns4__Reclassify(soap, (const struct __ns4__Reclassify *)ptr);
		break;
	case SOAP_TYPE___ns4__Reseal:
		soap_serialize___ns4__Reseal(soap, (const struct __ns4__Reseal *)ptr);
		break;
	case SOAP_TYPE___ns4__Unseal:
		soap_serialize___ns4__Unseal(soap, (const struct __ns4__Unseal *)ptr);
		break;
	case SOAP_TYPE___ns4__Seal:
		soap_serialize___ns4__Seal(soap, (const struct __ns4__Seal *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__ListRightsByAccountResponse:
		soap_serialize_PointerTo_ns7__ListRightsByAccountResponse(soap, (_ns7__ListRightsByAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__ListRightsByAccount:
		soap_serialize_PointerTo_ns7__ListRightsByAccount(soap, (_ns7__ListRightsByAccount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__ListRightsByContextResponse:
		soap_serialize_PointerTo_ns7__ListRightsByContextResponse(soap, (_ns7__ListRightsByContextResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__ListRightsByContext:
		soap_serialize_PointerTo_ns7__ListRightsByContext(soap, (_ns7__ListRightsByContext *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__UnassignRightsResponse:
		soap_serialize_PointerTo_ns7__UnassignRightsResponse(soap, (_ns7__UnassignRightsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__UnassignRights:
		soap_serialize_PointerTo_ns7__UnassignRights(soap, (_ns7__UnassignRights *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__SaveChangesToItemsResponse:
		soap_serialize_PointerTo_ns7__SaveChangesToItemsResponse(soap, (_ns7__SaveChangesToItemsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__SaveChangesToItems:
		soap_serialize_PointerTo_ns7__SaveChangesToItems(soap, (_ns7__SaveChangesToItems *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__CheckInRightsForAccountResponse:
		soap_serialize_PointerTo_ns7__CheckInRightsForAccountResponse(soap, (_ns7__CheckInRightsForAccountResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__CheckInRightsForAccount:
		soap_serialize_PointerTo_ns7__CheckInRightsForAccount(soap, (_ns7__CheckInRightsForAccount *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__ReassignRoleResponse:
		soap_serialize_PointerTo_ns7__ReassignRoleResponse(soap, (_ns7__ReassignRoleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__ReassignRole:
		soap_serialize_PointerTo_ns7__ReassignRole(soap, (_ns7__ReassignRole *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__AssignRoleResponse:
		soap_serialize_PointerTo_ns7__AssignRoleResponse(soap, (_ns7__AssignRoleResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns7__AssignRole:
		soap_serialize_PointerTo_ns7__AssignRole(soap, (_ns7__AssignRole *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__ValidatedPeekResponse:
		soap_serialize_PointerTo_ns4__ValidatedPeekResponse(soap, (_ns4__ValidatedPeekResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__ValidatedPeek:
		soap_serialize_PointerTo_ns4__ValidatedPeek(soap, (_ns4__ValidatedPeek *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__PeekResponse:
		soap_serialize_PointerTo_ns4__PeekResponse(soap, (_ns4__PeekResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__Peek:
		soap_serialize_PointerTo_ns4__Peek(soap, (_ns4__Peek *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__ReclassifyResponse:
		soap_serialize_PointerTo_ns4__ReclassifyResponse(soap, (_ns4__ReclassifyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__Reclassify:
		soap_serialize_PointerTo_ns4__Reclassify(soap, (_ns4__Reclassify *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__ResealResponse:
		soap_serialize_PointerTo_ns4__ResealResponse(soap, (_ns4__ResealResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__Reseal:
		soap_serialize_PointerTo_ns4__Reseal(soap, (_ns4__Reseal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__UnsealResponse:
		soap_serialize_PointerTo_ns4__UnsealResponse(soap, (_ns4__UnsealResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__Unseal:
		soap_serialize_PointerTo_ns4__Unseal(soap, (_ns4__Unseal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__SealResponse:
		soap_serialize_PointerTo_ns4__SealResponse(soap, (_ns4__SealResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns4__Seal:
		soap_serialize_PointerTo_ns4__Seal(soap, (_ns4__Seal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__UnsupportedDocumentRoleFault:
		soap_serialize_PointerTons6__UnsupportedDocumentRoleFault(soap, (ns6__UnsupportedDocumentRoleFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__UnknownDocumentRoleFault:
		soap_serialize_PointerTons6__UnknownDocumentRoleFault(soap, (ns6__UnknownDocumentRoleFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__UnknownDocumentRightFault:
		soap_serialize_PointerTons6__UnknownDocumentRightFault(soap, (ns6__UnknownDocumentRightFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__UnknownContextFault:
		soap_serialize_PointerTons5__UnknownContextFault(soap, (ns5__UnknownContextFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__AccountAlreadyAssignedFault:
		soap_serialize_PointerTons6__AccountAlreadyAssignedFault(soap, (ns6__AccountAlreadyAssignedFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__UnsupportedContentTypeFault:
		soap_serialize_PointerTons2__UnsupportedContentTypeFault(soap, (ns2__UnsupportedContentTypeFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__PublicHeaderLengthFault:
		soap_serialize_PointerTons2__PublicHeaderLengthFault(soap, (ns2__PublicHeaderLengthFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__IllegalEncryptedContentBlockSizeFault:
		soap_serialize_PointerTons2__IllegalEncryptedContentBlockSizeFault(soap, (ns2__IllegalEncryptedContentBlockSizeFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentParseFault:
		soap_serialize_PointerTons2__ContentParseFault(soap, (ns2__ContentParseFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons3__AuthorizationDeniedFault:
		soap_serialize_PointerTons3__AuthorizationDeniedFault(soap, (ns3__AuthorizationDeniedFault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ContextTemplateRef:
		soap_serialize_PointerTons6__ContextTemplateRef(soap, (ns6__ContextTemplateRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__XPathExpression:
		soap_serialize_PointerTons1__XPathExpression(soap, (ns1__XPathExpression *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PageRange:
		soap_serialize_PointerTons1__PageRange(soap, (ns1__PageRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__DocumentRightRef:
		soap_serialize_PointerTons6__DocumentRightRef(soap, (ns6__DocumentRightRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__DocumentRight:
		soap_serialize_PointerTons6__DocumentRight(soap, (ns6__DocumentRight *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__ContextInstanceRef:
		soap_serialize_PointerTons6__ContextInstanceRef(soap, (ns6__ContextInstanceRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__DocumentRole:
		soap_serialize_PointerTons6__DocumentRole(soap, (ns6__DocumentRole *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AccountRef:
		soap_serialize_PointerTons1__AccountRef(soap, (ns1__AccountRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__DomainRef:
		soap_serialize_PointerTons6__DomainRef(soap, (ns6__DomainRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons6__DocumentRoleRef:
		soap_serialize_PointerTons6__DocumentRoleRef(soap, (ns6__DocumentRoleRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__ItemCode:
		soap_serialize_PointerTons5__ItemCode(soap, (ns5__ItemCode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentDescription:
		soap_serialize_PointerTons2__ContentDescription(soap, (ns2__ContentDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SealingOptions:
		soap_serialize_PointerTons2__SealingOptions(soap, (ns2__SealingOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EncryptionOptions:
		soap_serialize_PointerTons2__EncryptionOptions(soap, (ns2__EncryptionOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ContentSchema:
		soap_serialize_PointerTons2__ContentSchema(soap, (ns2__ContentSchema *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CustomData:
		soap_serialize_PointerTons2__CustomData(soap, (ns2__CustomData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Classification:
		soap_serialize_PointerTons1__Classification(soap, (ns1__Classification *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SchemaVersion:
		soap_serialize_PointerTons2__SchemaVersion(soap, (ns2__SchemaVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__KeySetExtensions:
		soap_serialize_PointerTons2__KeySetExtensions(soap, (ns2__KeySetExtensions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__CryptoSchemaRef:
		soap_serialize_PointerTons2__CryptoSchemaRef(soap, (ns2__CryptoSchemaRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ClassificationFilter:
		soap_serialize_PointerTons1__ClassificationFilter(soap, (ns1__ClassificationFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TimePeriod:
		soap_serialize_PointerTons1__TimePeriod(soap, (ns1__TimePeriod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TimeSpan:
		soap_serialize_PointerTons1__TimeSpan(soap, (ns1__TimeSpan *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Feature:
		soap_serialize_PointerTons1__Feature(soap, (ns1__Feature *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Label:
		soap_serialize_PointerTons1__Label(soap, (ns1__Label *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__KeySetRef:
		soap_serialize_PointerTons2__KeySetRef(soap, (ns2__KeySetRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ClassificationSystemRef:
		soap_serialize_PointerTons1__ClassificationSystemRef(soap, (ns1__ClassificationSystemRef *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClassificationSystem:
		return (void*)soap_instantiate_ns1__ClassificationSystem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClassificationSystemRef:
		return (void*)soap_instantiate_ns1__ClassificationSystemRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Label:
		return (void*)soap_instantiate_ns1__Label(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Classification:
		return (void*)soap_instantiate_ns1__Classification(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LicenseCriteria:
		return (void*)soap_instantiate_ns1__LicenseCriteria(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Feature:
		return (void*)soap_instantiate_ns1__Feature(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TimeSpan:
		return (void*)soap_instantiate_ns1__TimeSpan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TimePeriod:
		return (void*)soap_instantiate_ns1__TimePeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ClassificationFilter:
		return (void*)soap_instantiate_ns1__ClassificationFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__XPathExpression:
		return (void*)soap_instantiate_ns1__XPathExpression(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Account:
		return (void*)soap_instantiate_ns1__Account(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AccountRef:
		return (void*)soap_instantiate_ns1__AccountRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PageRange:
		return (void*)soap_instantiate_ns1__PageRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CryptoSchema:
		return (void*)soap_instantiate_ns2__CryptoSchema(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CryptoSchemaRef:
		return (void*)soap_instantiate_ns2__CryptoSchemaRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__KeySetExtensions:
		return (void*)soap_instantiate_ns2__KeySetExtensions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__KeySet:
		return (void*)soap_instantiate_ns2__KeySet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__KeySetRef:
		return (void*)soap_instantiate_ns2__KeySetRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CustomData:
		return (void*)soap_instantiate_ns2__CustomData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SchemaVersion:
		return (void*)soap_instantiate_ns2__SchemaVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentSchema:
		return (void*)soap_instantiate_ns2__ContentSchema(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__EncryptionOptions:
		return (void*)soap_instantiate_ns2__EncryptionOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SealingOptions:
		return (void*)soap_instantiate_ns2__SealingOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentDescription:
		return (void*)soap_instantiate_ns2__ContentDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__UnsupportedContentTypeFault:
		return (void*)soap_instantiate_ns2__UnsupportedContentTypeFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault:
		return (void*)soap_instantiate_ns2__IllegalEncryptedContentBlockSizeFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__PublicHeaderLengthFault:
		return (void*)soap_instantiate_ns2__PublicHeaderLengthFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ContentParseFault:
		return (void*)soap_instantiate_ns2__ContentParseFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__AuthorizationDeniedFault:
		return (void*)soap_instantiate_ns3__AuthorizationDeniedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__Seal:
		return (void*)soap_instantiate__ns4__Seal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__SealResponse:
		return (void*)soap_instantiate__ns4__SealResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__Unseal:
		return (void*)soap_instantiate__ns4__Unseal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__UnsealResponse:
		return (void*)soap_instantiate__ns4__UnsealResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__Reseal:
		return (void*)soap_instantiate__ns4__Reseal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__ResealResponse:
		return (void*)soap_instantiate__ns4__ResealResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__Reclassify:
		return (void*)soap_instantiate__ns4__Reclassify(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__ReclassifyResponse:
		return (void*)soap_instantiate__ns4__ReclassifyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__Peek:
		return (void*)soap_instantiate__ns4__Peek(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__PeekResponse:
		return (void*)soap_instantiate__ns4__PeekResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__ValidatedPeek:
		return (void*)soap_instantiate__ns4__ValidatedPeek(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns4__ValidatedPeekResponse:
		return (void*)soap_instantiate__ns4__ValidatedPeekResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ItemCode:
		return (void*)soap_instantiate_ns5__ItemCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__Context:
		return (void*)soap_instantiate_ns5__Context(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ContextRef:
		return (void*)soap_instantiate_ns5__ContextRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__ItemConstraints:
		return (void*)soap_instantiate_ns5__ItemConstraints(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__UnknownContextFault:
		return (void*)soap_instantiate_ns5__UnknownContextFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ContextTemplate:
		return (void*)soap_instantiate_ns6__ContextTemplate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ContextTemplateRef:
		return (void*)soap_instantiate_ns6__ContextTemplateRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__DocumentRole:
		return (void*)soap_instantiate_ns6__DocumentRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__DocumentRoleRef:
		return (void*)soap_instantiate_ns6__DocumentRoleRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__Domain:
		return (void*)soap_instantiate_ns6__Domain(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__DomainRef:
		return (void*)soap_instantiate_ns6__DomainRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__DocumentRight:
		return (void*)soap_instantiate_ns6__DocumentRight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__DocumentRightRef:
		return (void*)soap_instantiate_ns6__DocumentRightRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__AccountAlreadyAssignedFault:
		return (void*)soap_instantiate_ns6__AccountAlreadyAssignedFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__UnsupportedDocumentRoleFault:
		return (void*)soap_instantiate_ns6__UnsupportedDocumentRoleFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__UnknownDocumentRoleFault:
		return (void*)soap_instantiate_ns6__UnknownDocumentRoleFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__UnknownDocumentRightFault:
		return (void*)soap_instantiate_ns6__UnknownDocumentRightFault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__AssignRole:
		return (void*)soap_instantiate__ns7__AssignRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__AssignRoleResponse:
		return (void*)soap_instantiate__ns7__AssignRoleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__ReassignRole:
		return (void*)soap_instantiate__ns7__ReassignRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__ReassignRoleResponse:
		return (void*)soap_instantiate__ns7__ReassignRoleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__CheckInRightsForAccount:
		return (void*)soap_instantiate__ns7__CheckInRightsForAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__CheckInRightsForAccountResponse:
		return (void*)soap_instantiate__ns7__CheckInRightsForAccountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__SaveChangesToItems:
		return (void*)soap_instantiate__ns7__SaveChangesToItems(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__SaveChangesToItemsResponse:
		return (void*)soap_instantiate__ns7__SaveChangesToItemsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__UnassignRights:
		return (void*)soap_instantiate__ns7__UnassignRights(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__UnassignRightsResponse:
		return (void*)soap_instantiate__ns7__UnassignRightsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__ListRightsByContext:
		return (void*)soap_instantiate__ns7__ListRightsByContext(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__ListRightsByContextResponse:
		return (void*)soap_instantiate__ns7__ListRightsByContextResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__ListRightsByAccount:
		return (void*)soap_instantiate__ns7__ListRightsByAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns7__ListRightsByAccountResponse:
		return (void*)soap_instantiate__ns7__ListRightsByAccountResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DesktopKeySetExtensions:
		return (void*)soap_instantiate_ns1__DesktopKeySetExtensions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RelativeTimeSpan:
		return (void*)soap_instantiate_ns1__RelativeTimeSpan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AbsoluteTimeSpan:
		return (void*)soap_instantiate_ns1__AbsoluteTimeSpan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__XPathClassificationFilter:
		return (void*)soap_instantiate_ns1__XPathClassificationFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RawKeySetExtensions:
		return (void*)soap_instantiate_ns2__RawKeySetExtensions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__WrappedKeySetExtensions:
		return (void*)soap_instantiate_ns2__WrappedKeySetExtensions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ContextInstance:
		return (void*)soap_instantiate_ns6__ContextInstance(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__ContextInstanceRef:
		return (void*)soap_instantiate_ns6__ContextInstanceRef(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns4__Seal:
		return (void*)soap_instantiate___ns4__Seal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__Unseal:
		return (void*)soap_instantiate___ns4__Unseal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__Reseal:
		return (void*)soap_instantiate___ns4__Reseal(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__Reclassify:
		return (void*)soap_instantiate___ns4__Reclassify(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__Peek:
		return (void*)soap_instantiate___ns4__Peek(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns4__ValidatedPeek:
		return (void*)soap_instantiate___ns4__ValidatedPeek(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__AssignRole:
		return (void*)soap_instantiate___ns7__AssignRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__ReassignRole:
		return (void*)soap_instantiate___ns7__ReassignRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__CheckInRightsForAccount:
		return (void*)soap_instantiate___ns7__CheckInRightsForAccount(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__SaveChangesToItems:
		return (void*)soap_instantiate___ns7__SaveChangesToItems(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__UnassignRights:
		return (void*)soap_instantiate___ns7__UnassignRights(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__ListRightsByContext:
		return (void*)soap_instantiate___ns7__ListRightsByContext(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns7__ListRightsByAccount:
		return (void*)soap_instantiate___ns7__ListRightsByAccount(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__ContextInstanceRef:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons6__ContextInstanceRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRightRef:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRight:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons6__DocumentRight(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccountRef:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__AccountRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRoleRef:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons6__DocumentRoleRef(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ItemCode:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons5__ItemCode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__CustomData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons2__CustomData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TimeSpan:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__TimeSpan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Feature:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Feature(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Label:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Label(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ClassificationSystem:
		if (p->size < 0)
			SOAP_DELETE((ns1__ClassificationSystem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ClassificationSystem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ClassificationSystemRef:
		if (p->size < 0)
			SOAP_DELETE((ns1__ClassificationSystemRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ClassificationSystemRef*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Label:
		if (p->size < 0)
			SOAP_DELETE((ns1__Label*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Label*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Classification:
		if (p->size < 0)
			SOAP_DELETE((ns1__Classification*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Classification*)p->ptr);
		break;
	case SOAP_TYPE_ns1__LicenseCriteria:
		if (p->size < 0)
			SOAP_DELETE((ns1__LicenseCriteria*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__LicenseCriteria*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Feature:
		if (p->size < 0)
			SOAP_DELETE((ns1__Feature*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Feature*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TimeSpan:
		if (p->size < 0)
			SOAP_DELETE((ns1__TimeSpan*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TimeSpan*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TimePeriod:
		if (p->size < 0)
			SOAP_DELETE((ns1__TimePeriod*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TimePeriod*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ClassificationFilter:
		if (p->size < 0)
			SOAP_DELETE((ns1__ClassificationFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__ClassificationFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__XPathExpression:
		if (p->size < 0)
			SOAP_DELETE((ns1__XPathExpression*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__XPathExpression*)p->ptr);
		break;
	case SOAP_TYPE_ns1__Account:
		if (p->size < 0)
			SOAP_DELETE((ns1__Account*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__Account*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AccountRef:
		if (p->size < 0)
			SOAP_DELETE((ns1__AccountRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AccountRef*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PageRange:
		if (p->size < 0)
			SOAP_DELETE((ns1__PageRange*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PageRange*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CryptoSchema:
		if (p->size < 0)
			SOAP_DELETE((ns2__CryptoSchema*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CryptoSchema*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CryptoSchemaRef:
		if (p->size < 0)
			SOAP_DELETE((ns2__CryptoSchemaRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CryptoSchemaRef*)p->ptr);
		break;
	case SOAP_TYPE_ns2__KeySetExtensions:
		if (p->size < 0)
			SOAP_DELETE((ns2__KeySetExtensions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__KeySetExtensions*)p->ptr);
		break;
	case SOAP_TYPE_ns2__KeySet:
		if (p->size < 0)
			SOAP_DELETE((ns2__KeySet*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__KeySet*)p->ptr);
		break;
	case SOAP_TYPE_ns2__KeySetRef:
		if (p->size < 0)
			SOAP_DELETE((ns2__KeySetRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__KeySetRef*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CustomData:
		if (p->size < 0)
			SOAP_DELETE((ns2__CustomData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__CustomData*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SchemaVersion:
		if (p->size < 0)
			SOAP_DELETE((ns2__SchemaVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SchemaVersion*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentSchema:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentSchema*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentSchema*)p->ptr);
		break;
	case SOAP_TYPE_ns2__EncryptionOptions:
		if (p->size < 0)
			SOAP_DELETE((ns2__EncryptionOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__EncryptionOptions*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SealingOptions:
		if (p->size < 0)
			SOAP_DELETE((ns2__SealingOptions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SealingOptions*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentDescription:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentDescription*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentDescription*)p->ptr);
		break;
	case SOAP_TYPE_ns2__UnsupportedContentTypeFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__UnsupportedContentTypeFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__UnsupportedContentTypeFault*)p->ptr);
		break;
	case SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__IllegalEncryptedContentBlockSizeFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__IllegalEncryptedContentBlockSizeFault*)p->ptr);
		break;
	case SOAP_TYPE_ns2__PublicHeaderLengthFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__PublicHeaderLengthFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__PublicHeaderLengthFault*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ContentParseFault:
		if (p->size < 0)
			SOAP_DELETE((ns2__ContentParseFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ContentParseFault*)p->ptr);
		break;
	case SOAP_TYPE_ns3__AuthorizationDeniedFault:
		if (p->size < 0)
			SOAP_DELETE((ns3__AuthorizationDeniedFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns3__AuthorizationDeniedFault*)p->ptr);
		break;
	case SOAP_TYPE__ns4__Seal:
		if (p->size < 0)
			SOAP_DELETE((_ns4__Seal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__Seal*)p->ptr);
		break;
	case SOAP_TYPE__ns4__SealResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__SealResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__SealResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__Unseal:
		if (p->size < 0)
			SOAP_DELETE((_ns4__Unseal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__Unseal*)p->ptr);
		break;
	case SOAP_TYPE__ns4__UnsealResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__UnsealResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__UnsealResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__Reseal:
		if (p->size < 0)
			SOAP_DELETE((_ns4__Reseal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__Reseal*)p->ptr);
		break;
	case SOAP_TYPE__ns4__ResealResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__ResealResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__ResealResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__Reclassify:
		if (p->size < 0)
			SOAP_DELETE((_ns4__Reclassify*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__Reclassify*)p->ptr);
		break;
	case SOAP_TYPE__ns4__ReclassifyResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__ReclassifyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__ReclassifyResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__Peek:
		if (p->size < 0)
			SOAP_DELETE((_ns4__Peek*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__Peek*)p->ptr);
		break;
	case SOAP_TYPE__ns4__PeekResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__PeekResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__PeekResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns4__ValidatedPeek:
		if (p->size < 0)
			SOAP_DELETE((_ns4__ValidatedPeek*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__ValidatedPeek*)p->ptr);
		break;
	case SOAP_TYPE__ns4__ValidatedPeekResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns4__ValidatedPeekResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns4__ValidatedPeekResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ItemCode:
		if (p->size < 0)
			SOAP_DELETE((ns5__ItemCode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ItemCode*)p->ptr);
		break;
	case SOAP_TYPE_ns5__Context:
		if (p->size < 0)
			SOAP_DELETE((ns5__Context*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__Context*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ContextRef:
		if (p->size < 0)
			SOAP_DELETE((ns5__ContextRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ContextRef*)p->ptr);
		break;
	case SOAP_TYPE_ns5__ItemConstraints:
		if (p->size < 0)
			SOAP_DELETE((ns5__ItemConstraints*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__ItemConstraints*)p->ptr);
		break;
	case SOAP_TYPE_ns5__UnknownContextFault:
		if (p->size < 0)
			SOAP_DELETE((ns5__UnknownContextFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns5__UnknownContextFault*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ContextTemplate:
		if (p->size < 0)
			SOAP_DELETE((ns6__ContextTemplate*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__ContextTemplate*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ContextTemplateRef:
		if (p->size < 0)
			SOAP_DELETE((ns6__ContextTemplateRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__ContextTemplateRef*)p->ptr);
		break;
	case SOAP_TYPE_ns6__DocumentRole:
		if (p->size < 0)
			SOAP_DELETE((ns6__DocumentRole*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__DocumentRole*)p->ptr);
		break;
	case SOAP_TYPE_ns6__DocumentRoleRef:
		if (p->size < 0)
			SOAP_DELETE((ns6__DocumentRoleRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__DocumentRoleRef*)p->ptr);
		break;
	case SOAP_TYPE_ns6__Domain:
		if (p->size < 0)
			SOAP_DELETE((ns6__Domain*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__Domain*)p->ptr);
		break;
	case SOAP_TYPE_ns6__DomainRef:
		if (p->size < 0)
			SOAP_DELETE((ns6__DomainRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__DomainRef*)p->ptr);
		break;
	case SOAP_TYPE_ns6__DocumentRight:
		if (p->size < 0)
			SOAP_DELETE((ns6__DocumentRight*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__DocumentRight*)p->ptr);
		break;
	case SOAP_TYPE_ns6__DocumentRightRef:
		if (p->size < 0)
			SOAP_DELETE((ns6__DocumentRightRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__DocumentRightRef*)p->ptr);
		break;
	case SOAP_TYPE_ns6__AccountAlreadyAssignedFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__AccountAlreadyAssignedFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__AccountAlreadyAssignedFault*)p->ptr);
		break;
	case SOAP_TYPE_ns6__UnsupportedDocumentRoleFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__UnsupportedDocumentRoleFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__UnsupportedDocumentRoleFault*)p->ptr);
		break;
	case SOAP_TYPE_ns6__UnknownDocumentRoleFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__UnknownDocumentRoleFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__UnknownDocumentRoleFault*)p->ptr);
		break;
	case SOAP_TYPE_ns6__UnknownDocumentRightFault:
		if (p->size < 0)
			SOAP_DELETE((ns6__UnknownDocumentRightFault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__UnknownDocumentRightFault*)p->ptr);
		break;
	case SOAP_TYPE__ns7__AssignRole:
		if (p->size < 0)
			SOAP_DELETE((_ns7__AssignRole*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__AssignRole*)p->ptr);
		break;
	case SOAP_TYPE__ns7__AssignRoleResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns7__AssignRoleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__AssignRoleResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns7__ReassignRole:
		if (p->size < 0)
			SOAP_DELETE((_ns7__ReassignRole*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__ReassignRole*)p->ptr);
		break;
	case SOAP_TYPE__ns7__ReassignRoleResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns7__ReassignRoleResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__ReassignRoleResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns7__CheckInRightsForAccount:
		if (p->size < 0)
			SOAP_DELETE((_ns7__CheckInRightsForAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__CheckInRightsForAccount*)p->ptr);
		break;
	case SOAP_TYPE__ns7__CheckInRightsForAccountResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns7__CheckInRightsForAccountResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__CheckInRightsForAccountResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns7__SaveChangesToItems:
		if (p->size < 0)
			SOAP_DELETE((_ns7__SaveChangesToItems*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__SaveChangesToItems*)p->ptr);
		break;
	case SOAP_TYPE__ns7__SaveChangesToItemsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns7__SaveChangesToItemsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__SaveChangesToItemsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns7__UnassignRights:
		if (p->size < 0)
			SOAP_DELETE((_ns7__UnassignRights*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__UnassignRights*)p->ptr);
		break;
	case SOAP_TYPE__ns7__UnassignRightsResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns7__UnassignRightsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__UnassignRightsResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns7__ListRightsByContext:
		if (p->size < 0)
			SOAP_DELETE((_ns7__ListRightsByContext*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__ListRightsByContext*)p->ptr);
		break;
	case SOAP_TYPE__ns7__ListRightsByContextResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns7__ListRightsByContextResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__ListRightsByContextResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns7__ListRightsByAccount:
		if (p->size < 0)
			SOAP_DELETE((_ns7__ListRightsByAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__ListRightsByAccount*)p->ptr);
		break;
	case SOAP_TYPE__ns7__ListRightsByAccountResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns7__ListRightsByAccountResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns7__ListRightsByAccountResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DesktopKeySetExtensions:
		if (p->size < 0)
			SOAP_DELETE((ns1__DesktopKeySetExtensions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__DesktopKeySetExtensions*)p->ptr);
		break;
	case SOAP_TYPE_ns1__RelativeTimeSpan:
		if (p->size < 0)
			SOAP_DELETE((ns1__RelativeTimeSpan*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__RelativeTimeSpan*)p->ptr);
		break;
	case SOAP_TYPE_ns1__AbsoluteTimeSpan:
		if (p->size < 0)
			SOAP_DELETE((ns1__AbsoluteTimeSpan*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__AbsoluteTimeSpan*)p->ptr);
		break;
	case SOAP_TYPE_ns1__XPathClassificationFilter:
		if (p->size < 0)
			SOAP_DELETE((ns1__XPathClassificationFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__XPathClassificationFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RawKeySetExtensions:
		if (p->size < 0)
			SOAP_DELETE((ns2__RawKeySetExtensions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RawKeySetExtensions*)p->ptr);
		break;
	case SOAP_TYPE_ns2__WrappedKeySetExtensions:
		if (p->size < 0)
			SOAP_DELETE((ns2__WrappedKeySetExtensions*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__WrappedKeySetExtensions*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ContextInstance:
		if (p->size < 0)
			SOAP_DELETE((ns6__ContextInstance*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__ContextInstance*)p->ptr);
		break;
	case SOAP_TYPE_ns6__ContextInstanceRef:
		if (p->size < 0)
			SOAP_DELETE((ns6__ContextInstanceRef*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns6__ContextInstanceRef*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
	case SOAP_TYPE___ns4__Seal:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__Seal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__Seal*)p->ptr);
		break;
	case SOAP_TYPE___ns4__Unseal:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__Unseal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__Unseal*)p->ptr);
		break;
	case SOAP_TYPE___ns4__Reseal:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__Reseal*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__Reseal*)p->ptr);
		break;
	case SOAP_TYPE___ns4__Reclassify:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__Reclassify*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__Reclassify*)p->ptr);
		break;
	case SOAP_TYPE___ns4__Peek:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__Peek*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__Peek*)p->ptr);
		break;
	case SOAP_TYPE___ns4__ValidatedPeek:
		if (p->size < 0)
			SOAP_DELETE((struct __ns4__ValidatedPeek*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns4__ValidatedPeek*)p->ptr);
		break;
	case SOAP_TYPE___ns7__AssignRole:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__AssignRole*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__AssignRole*)p->ptr);
		break;
	case SOAP_TYPE___ns7__ReassignRole:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__ReassignRole*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__ReassignRole*)p->ptr);
		break;
	case SOAP_TYPE___ns7__CheckInRightsForAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__CheckInRightsForAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__CheckInRightsForAccount*)p->ptr);
		break;
	case SOAP_TYPE___ns7__SaveChangesToItems:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__SaveChangesToItems*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__SaveChangesToItems*)p->ptr);
		break;
	case SOAP_TYPE___ns7__UnassignRights:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__UnassignRights*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__UnassignRights*)p->ptr);
		break;
	case SOAP_TYPE___ns7__ListRightsByContext:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__ListRightsByContext*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__ListRightsByContext*)p->ptr);
		break;
	case SOAP_TYPE___ns7__ListRightsByAccount:
		if (p->size < 0)
			SOAP_DELETE((struct __ns7__ListRightsByAccount*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns7__ListRightsByAccount*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE((xsd__QName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__QName*)p->ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__ContextInstanceRef:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns6__ContextInstanceRef * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns6__ContextInstanceRef * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRightRef:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns6__DocumentRightRef * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns6__DocumentRightRef * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRight:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns6__DocumentRight * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns6__DocumentRight * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccountRef:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__AccountRef * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__AccountRef * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRoleRef:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns6__DocumentRoleRef * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns6__DocumentRoleRef * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ItemCode:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns5__ItemCode * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns5__ItemCode * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__CustomData:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns2__CustomData * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns2__CustomData * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (p->size < 0)
			SOAP_DELETE((std::vector<xsd__QName >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<xsd__QName >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TimeSpan:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__TimeSpan * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__TimeSpan * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Feature:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__Feature * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__Feature * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Label:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__Label * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__Label * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__ContextInstanceRef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns6__ContextInstanceRef * >*)p)[len] = *(ns6__ContextInstanceRef **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRightRef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns6__DocumentRightRef * >*)p)[len] = *(ns6__DocumentRightRef **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRight:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns6__DocumentRight * >*)p)[len] = *(ns6__DocumentRight **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccountRef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__AccountRef * >*)p)[len] = *(ns1__AccountRef **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRoleRef:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns6__DocumentRoleRef * >*)p)[len] = *(ns6__DocumentRoleRef **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons5__ItemCode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns5__ItemCode * >*)p)[len] = *(ns5__ItemCode **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons2__CustomData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns2__CustomData * >*)p)[len] = *(ns2__CustomData **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<xsd__QName >*)p)[len] = *(xsd__QName *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TimeSpan:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__TimeSpan * >*)p)[len] = *(ns1__TimeSpan **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Feature:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__Feature * >*)p)[len] = *(ns1__Feature **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Label:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__Label * >*)p)[len] = *(ns1__Label **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__Domain_USCORERole(struct soap *soap, enum ns6__Domain_USCORERole *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__Domain_USCORERole
	*a = SOAP_DEFAULT_ns6__Domain_USCORERole;
#else
	*a = (enum ns6__Domain_USCORERole)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__Domain_USCORERole[] =
{	{ (long)ns6__Domain_USCORERole__NONE, "NONE" },
	{ (long)ns6__Domain_USCORERole__ADMINISTRATOR, "ADMINISTRATOR" },
	{ (long)ns6__Domain_USCORERole__MANAGER, "MANAGER" },
	{ (long)ns6__Domain_USCORERole__INSPECTOR, "INSPECTOR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__Domain_USCORERole2s(struct soap *soap, enum ns6__Domain_USCORERole n)
{	const char *s = soap_code_str(soap_codes_ns6__Domain_USCORERole, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Domain_USCORERole(struct soap *soap, const char *tag, int id, const enum ns6__Domain_USCORERole *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Domain_USCORERole), type) || soap_send(soap, soap_ns6__Domain_USCORERole2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__Domain_USCORERole(struct soap *soap, const char *s, enum ns6__Domain_USCORERole *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__Domain_USCORERole, s);
	if (map)
		*a = (enum ns6__Domain_USCORERole)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__Domain_USCORERole)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__Domain_USCORERole * SOAP_FMAC4 soap_in_ns6__Domain_USCORERole(struct soap *soap, const char *tag, enum ns6__Domain_USCORERole *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__Domain_USCORERole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Domain_USCORERole, sizeof(enum ns6__Domain_USCORERole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__Domain_USCORERole(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__Domain_USCORERole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Domain_USCORERole, 0, sizeof(enum ns6__Domain_USCORERole), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__Domain_USCORERole(struct soap *soap, const enum ns6__Domain_USCORERole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__Domain_USCORERole);
	if (soap_out_ns6__Domain_USCORERole(soap, tag?tag:"ns6:Domain_Role", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__Domain_USCORERole * SOAP_FMAC4 soap_get_ns6__Domain_USCORERole(struct soap *soap, enum ns6__Domain_USCORERole *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Domain_USCORERole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__DocumentRole_USCORETimeConstraints(struct soap *soap, enum ns6__DocumentRole_USCORETimeConstraints *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__DocumentRole_USCORETimeConstraints
	*a = SOAP_DEFAULT_ns6__DocumentRole_USCORETimeConstraints;
#else
	*a = (enum ns6__DocumentRole_USCORETimeConstraints)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__DocumentRole_USCORETimeConstraints[] =
{	{ (long)ns6__DocumentRole_USCORETimeConstraints__NONE, "NONE" },
	{ (long)ns6__DocumentRole_USCORETimeConstraints__ABSOLUTE, "ABSOLUTE" },
	{ (long)ns6__DocumentRole_USCORETimeConstraints__RELATIVE_USCOREASSIGNMENT, "RELATIVE_ASSIGNMENT" },
	{ (long)ns6__DocumentRole_USCORETimeConstraints__RELATIVE_USCORECLASSIFICATION, "RELATIVE_CLASSIFICATION" },
	{ (long)ns6__DocumentRole_USCORETimeConstraints__OTHER, "OTHER" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__DocumentRole_USCORETimeConstraints2s(struct soap *soap, enum ns6__DocumentRole_USCORETimeConstraints n)
{	const char *s = soap_code_str(soap_codes_ns6__DocumentRole_USCORETimeConstraints, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__DocumentRole_USCORETimeConstraints(struct soap *soap, const char *tag, int id, const enum ns6__DocumentRole_USCORETimeConstraints *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DocumentRole_USCORETimeConstraints), type) || soap_send(soap, soap_ns6__DocumentRole_USCORETimeConstraints2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__DocumentRole_USCORETimeConstraints(struct soap *soap, const char *s, enum ns6__DocumentRole_USCORETimeConstraints *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__DocumentRole_USCORETimeConstraints, s);
	if (map)
		*a = (enum ns6__DocumentRole_USCORETimeConstraints)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__DocumentRole_USCORETimeConstraints)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__DocumentRole_USCORETimeConstraints * SOAP_FMAC4 soap_in_ns6__DocumentRole_USCORETimeConstraints(struct soap *soap, const char *tag, enum ns6__DocumentRole_USCORETimeConstraints *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__DocumentRole_USCORETimeConstraints *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DocumentRole_USCORETimeConstraints, sizeof(enum ns6__DocumentRole_USCORETimeConstraints), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__DocumentRole_USCORETimeConstraints(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__DocumentRole_USCORETimeConstraints *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DocumentRole_USCORETimeConstraints, 0, sizeof(enum ns6__DocumentRole_USCORETimeConstraints), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__DocumentRole_USCORETimeConstraints(struct soap *soap, const enum ns6__DocumentRole_USCORETimeConstraints *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__DocumentRole_USCORETimeConstraints);
	if (soap_out_ns6__DocumentRole_USCORETimeConstraints(soap, tag?tag:"ns6:DocumentRole_TimeConstraints", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__DocumentRole_USCORETimeConstraints * SOAP_FMAC4 soap_get_ns6__DocumentRole_USCORETimeConstraints(struct soap *soap, enum ns6__DocumentRole_USCORETimeConstraints *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__DocumentRole_USCORETimeConstraints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__DocumentRole_USCOREExportConstraints(struct soap *soap, enum ns6__DocumentRole_USCOREExportConstraints *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__DocumentRole_USCOREExportConstraints
	*a = SOAP_DEFAULT_ns6__DocumentRole_USCOREExportConstraints;
#else
	*a = (enum ns6__DocumentRole_USCOREExportConstraints)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__DocumentRole_USCOREExportConstraints[] =
{	{ (long)ns6__DocumentRole_USCOREExportConstraints__FULL, "FULL" },
	{ (long)ns6__DocumentRole_USCOREExportConstraints__TRUSTED, "TRUSTED" },
	{ (long)ns6__DocumentRole_USCOREExportConstraints__NONE, "NONE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__DocumentRole_USCOREExportConstraints2s(struct soap *soap, enum ns6__DocumentRole_USCOREExportConstraints n)
{	const char *s = soap_code_str(soap_codes_ns6__DocumentRole_USCOREExportConstraints, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__DocumentRole_USCOREExportConstraints(struct soap *soap, const char *tag, int id, const enum ns6__DocumentRole_USCOREExportConstraints *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DocumentRole_USCOREExportConstraints), type) || soap_send(soap, soap_ns6__DocumentRole_USCOREExportConstraints2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__DocumentRole_USCOREExportConstraints(struct soap *soap, const char *s, enum ns6__DocumentRole_USCOREExportConstraints *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__DocumentRole_USCOREExportConstraints, s);
	if (map)
		*a = (enum ns6__DocumentRole_USCOREExportConstraints)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__DocumentRole_USCOREExportConstraints)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__DocumentRole_USCOREExportConstraints * SOAP_FMAC4 soap_in_ns6__DocumentRole_USCOREExportConstraints(struct soap *soap, const char *tag, enum ns6__DocumentRole_USCOREExportConstraints *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__DocumentRole_USCOREExportConstraints *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DocumentRole_USCOREExportConstraints, sizeof(enum ns6__DocumentRole_USCOREExportConstraints), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__DocumentRole_USCOREExportConstraints(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__DocumentRole_USCOREExportConstraints *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DocumentRole_USCOREExportConstraints, 0, sizeof(enum ns6__DocumentRole_USCOREExportConstraints), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__DocumentRole_USCOREExportConstraints(struct soap *soap, const enum ns6__DocumentRole_USCOREExportConstraints *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__DocumentRole_USCOREExportConstraints);
	if (soap_out_ns6__DocumentRole_USCOREExportConstraints(soap, tag?tag:"ns6:DocumentRole_ExportConstraints", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__DocumentRole_USCOREExportConstraints * SOAP_FMAC4 soap_get_ns6__DocumentRole_USCOREExportConstraints(struct soap *soap, enum ns6__DocumentRole_USCOREExportConstraints *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__DocumentRole_USCOREExportConstraints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ContextTemplate_USCOREStatus(struct soap *soap, enum ns6__ContextTemplate_USCOREStatus *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ContextTemplate_USCOREStatus
	*a = SOAP_DEFAULT_ns6__ContextTemplate_USCOREStatus;
#else
	*a = (enum ns6__ContextTemplate_USCOREStatus)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__ContextTemplate_USCOREStatus[] =
{	{ (long)ns6__ContextTemplate_USCOREStatus__INACTIVE, "INACTIVE" },
	{ (long)ns6__ContextTemplate_USCOREStatus__ACTIVE, "ACTIVE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ContextTemplate_USCOREStatus2s(struct soap *soap, enum ns6__ContextTemplate_USCOREStatus n)
{	const char *s = soap_code_str(soap_codes_ns6__ContextTemplate_USCOREStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ContextTemplate_USCOREStatus(struct soap *soap, const char *tag, int id, const enum ns6__ContextTemplate_USCOREStatus *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ContextTemplate_USCOREStatus), type) || soap_send(soap, soap_ns6__ContextTemplate_USCOREStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ContextTemplate_USCOREStatus(struct soap *soap, const char *s, enum ns6__ContextTemplate_USCOREStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__ContextTemplate_USCOREStatus, s);
	if (map)
		*a = (enum ns6__ContextTemplate_USCOREStatus)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ContextTemplate_USCOREStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ContextTemplate_USCOREStatus * SOAP_FMAC4 soap_in_ns6__ContextTemplate_USCOREStatus(struct soap *soap, const char *tag, enum ns6__ContextTemplate_USCOREStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ContextTemplate_USCOREStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ContextTemplate_USCOREStatus, sizeof(enum ns6__ContextTemplate_USCOREStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__ContextTemplate_USCOREStatus(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__ContextTemplate_USCOREStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ContextTemplate_USCOREStatus, 0, sizeof(enum ns6__ContextTemplate_USCOREStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ContextTemplate_USCOREStatus(struct soap *soap, const enum ns6__ContextTemplate_USCOREStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ContextTemplate_USCOREStatus);
	if (soap_out_ns6__ContextTemplate_USCOREStatus(soap, tag?tag:"ns6:ContextTemplate_Status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ContextTemplate_USCOREStatus * SOAP_FMAC4 soap_get_ns6__ContextTemplate_USCOREStatus(struct soap *soap, enum ns6__ContextTemplate_USCOREStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ContextTemplate_USCOREStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ContextInstance_USCORERole(struct soap *soap, enum ns6__ContextInstance_USCORERole *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ContextInstance_USCORERole
	*a = SOAP_DEFAULT_ns6__ContextInstance_USCORERole;
#else
	*a = (enum ns6__ContextInstance_USCORERole)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__ContextInstance_USCORERole[] =
{	{ (long)ns6__ContextInstance_USCORERole__NONE, "NONE" },
	{ (long)ns6__ContextInstance_USCORERole__MANAGER, "MANAGER" },
	{ (long)ns6__ContextInstance_USCORERole__INSPECTOR, "INSPECTOR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ContextInstance_USCORERole2s(struct soap *soap, enum ns6__ContextInstance_USCORERole n)
{	const char *s = soap_code_str(soap_codes_ns6__ContextInstance_USCORERole, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ContextInstance_USCORERole(struct soap *soap, const char *tag, int id, const enum ns6__ContextInstance_USCORERole *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ContextInstance_USCORERole), type) || soap_send(soap, soap_ns6__ContextInstance_USCORERole2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ContextInstance_USCORERole(struct soap *soap, const char *s, enum ns6__ContextInstance_USCORERole *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__ContextInstance_USCORERole, s);
	if (map)
		*a = (enum ns6__ContextInstance_USCORERole)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ContextInstance_USCORERole)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ContextInstance_USCORERole * SOAP_FMAC4 soap_in_ns6__ContextInstance_USCORERole(struct soap *soap, const char *tag, enum ns6__ContextInstance_USCORERole *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ContextInstance_USCORERole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ContextInstance_USCORERole, sizeof(enum ns6__ContextInstance_USCORERole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__ContextInstance_USCORERole(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__ContextInstance_USCORERole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ContextInstance_USCORERole, 0, sizeof(enum ns6__ContextInstance_USCORERole), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ContextInstance_USCORERole(struct soap *soap, const enum ns6__ContextInstance_USCORERole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ContextInstance_USCORERole);
	if (soap_out_ns6__ContextInstance_USCORERole(soap, tag?tag:"ns6:ContextInstance_Role", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ContextInstance_USCORERole * SOAP_FMAC4 soap_get_ns6__ContextInstance_USCORERole(struct soap *soap, enum ns6__ContextInstance_USCORERole *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ContextInstance_USCORERole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ContextInstance_USCOREVisibility(struct soap *soap, enum ns6__ContextInstance_USCOREVisibility *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns6__ContextInstance_USCOREVisibility
	*a = SOAP_DEFAULT_ns6__ContextInstance_USCOREVisibility;
#else
	*a = (enum ns6__ContextInstance_USCOREVisibility)0;
#endif
}

static const struct soap_code_map soap_codes_ns6__ContextInstance_USCOREVisibility[] =
{	{ (long)ns6__ContextInstance_USCOREVisibility__DOMAIN, "DOMAIN" },
	{ (long)ns6__ContextInstance_USCOREVisibility__CONTEXT, "CONTEXT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns6__ContextInstance_USCOREVisibility2s(struct soap *soap, enum ns6__ContextInstance_USCOREVisibility n)
{	const char *s = soap_code_str(soap_codes_ns6__ContextInstance_USCOREVisibility, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ContextInstance_USCOREVisibility(struct soap *soap, const char *tag, int id, const enum ns6__ContextInstance_USCOREVisibility *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ContextInstance_USCOREVisibility), type) || soap_send(soap, soap_ns6__ContextInstance_USCOREVisibility2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns6__ContextInstance_USCOREVisibility(struct soap *soap, const char *s, enum ns6__ContextInstance_USCOREVisibility *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns6__ContextInstance_USCOREVisibility, s);
	if (map)
		*a = (enum ns6__ContextInstance_USCOREVisibility)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns6__ContextInstance_USCOREVisibility)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns6__ContextInstance_USCOREVisibility * SOAP_FMAC4 soap_in_ns6__ContextInstance_USCOREVisibility(struct soap *soap, const char *tag, enum ns6__ContextInstance_USCOREVisibility *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns6__ContextInstance_USCOREVisibility *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ContextInstance_USCOREVisibility, sizeof(enum ns6__ContextInstance_USCOREVisibility), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns6__ContextInstance_USCOREVisibility(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns6__ContextInstance_USCOREVisibility *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ContextInstance_USCOREVisibility, 0, sizeof(enum ns6__ContextInstance_USCOREVisibility), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ContextInstance_USCOREVisibility(struct soap *soap, const enum ns6__ContextInstance_USCOREVisibility *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__ContextInstance_USCOREVisibility);
	if (soap_out_ns6__ContextInstance_USCOREVisibility(soap, tag?tag:"ns6:ContextInstance_Visibility", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns6__ContextInstance_USCOREVisibility * SOAP_FMAC4 soap_get_ns6__ContextInstance_USCOREVisibility(struct soap *soap, enum ns6__ContextInstance_USCOREVisibility *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ContextInstance_USCOREVisibility(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__ItemConstraints_USCOREType(struct soap *soap, enum ns5__ItemConstraints_USCOREType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns5__ItemConstraints_USCOREType
	*a = SOAP_DEFAULT_ns5__ItemConstraints_USCOREType;
#else
	*a = (enum ns5__ItemConstraints_USCOREType)0;
#endif
}

static const struct soap_code_map soap_codes_ns5__ItemConstraints_USCOREType[] =
{	{ (long)ns5__ItemConstraints_USCOREType__LOCKS, "LOCKS" },
	{ (long)ns5__ItemConstraints_USCOREType__EXCLUSIONS, "EXCLUSIONS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns5__ItemConstraints_USCOREType2s(struct soap *soap, enum ns5__ItemConstraints_USCOREType n)
{	const char *s = soap_code_str(soap_codes_ns5__ItemConstraints_USCOREType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ItemConstraints_USCOREType(struct soap *soap, const char *tag, int id, const enum ns5__ItemConstraints_USCOREType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ItemConstraints_USCOREType), type) || soap_send(soap, soap_ns5__ItemConstraints_USCOREType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns5__ItemConstraints_USCOREType(struct soap *soap, const char *s, enum ns5__ItemConstraints_USCOREType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns5__ItemConstraints_USCOREType, s);
	if (map)
		*a = (enum ns5__ItemConstraints_USCOREType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns5__ItemConstraints_USCOREType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns5__ItemConstraints_USCOREType * SOAP_FMAC4 soap_in_ns5__ItemConstraints_USCOREType(struct soap *soap, const char *tag, enum ns5__ItemConstraints_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns5__ItemConstraints_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ItemConstraints_USCOREType, sizeof(enum ns5__ItemConstraints_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns5__ItemConstraints_USCOREType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns5__ItemConstraints_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ItemConstraints_USCOREType, 0, sizeof(enum ns5__ItemConstraints_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__ItemConstraints_USCOREType(struct soap *soap, const enum ns5__ItemConstraints_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns5__ItemConstraints_USCOREType);
	if (soap_out_ns5__ItemConstraints_USCOREType(soap, tag?tag:"ns5:ItemConstraints_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns5__ItemConstraints_USCOREType * SOAP_FMAC4 soap_get_ns5__ItemConstraints_USCOREType(struct soap *soap, enum ns5__ItemConstraints_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ItemConstraints_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ContentParseFault_USCOREReason(struct soap *soap, enum ns2__ContentParseFault_USCOREReason *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ContentParseFault_USCOREReason
	*a = SOAP_DEFAULT_ns2__ContentParseFault_USCOREReason;
#else
	*a = (enum ns2__ContentParseFault_USCOREReason)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ContentParseFault_USCOREReason[] =
{	{ (long)ns2__ContentParseFault_USCOREReason__CONTENT_USCORETRUNCATED, "CONTENT_TRUNCATED" },
	{ (long)ns2__ContentParseFault_USCOREReason__XML_USCOREBLOCK_USCOREINVALID_USCORESIZE, "XML_BLOCK_INVALID_SIZE" },
	{ (long)ns2__ContentParseFault_USCOREReason__XML_USCOREBLOCK_USCOREEMPTY, "XML_BLOCK_EMPTY" },
	{ (long)ns2__ContentParseFault_USCOREReason__XML_USCOREBLOCK_USCORETRUNCATED, "XML_BLOCK_TRUNCATED" },
	{ (long)ns2__ContentParseFault_USCOREReason__PREAMBLE_USCORENOT_USCOREFOUND, "PREAMBLE_NOT_FOUND" },
	{ (long)ns2__ContentParseFault_USCOREReason__MAGIC_USCORENOT_USCOREFOUND, "MAGIC_NOT_FOUND" },
	{ (long)ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCOREMISSING, "PUBLIC_HEADER_MISSING" },
	{ (long)ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORECORRUPT, "PUBLIC_HEADER_CORRUPT" },
	{ (long)ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORESIGNATURE_USCOREMISMATCH, "PUBLIC_HEADER_SIGNATURE_MISMATCH" },
	{ (long)ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORESIGNATURE_USCOREMISSING, "PUBLIC_HEADER_SIGNATURE_MISSING" },
	{ (long)ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORESIGNATURE_USCORECORRUPT, "PUBLIC_HEADER_SIGNATURE_CORRUPT" },
	{ (long)ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCOREDATA_USCOREDIGEST_USCOREMISMATCH, "PUBLIC_HEADER_DATA_DIGEST_MISMATCH" },
	{ (long)ns2__ContentParseFault_USCOREReason__PRIVATE_USCOREBLOCK_USCOREDIGEST_USCOREMISMATCH, "PRIVATE_BLOCK_DIGEST_MISMATCH" },
	{ (long)ns2__ContentParseFault_USCOREReason__PRIVATE_USCOREHEADER_USCORECORRUPT, "PRIVATE_HEADER_CORRUPT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ContentParseFault_USCOREReason2s(struct soap *soap, enum ns2__ContentParseFault_USCOREReason n)
{	const char *s = soap_code_str(soap_codes_ns2__ContentParseFault_USCOREReason, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentParseFault_USCOREReason(struct soap *soap, const char *tag, int id, const enum ns2__ContentParseFault_USCOREReason *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentParseFault_USCOREReason), type) || soap_send(soap, soap_ns2__ContentParseFault_USCOREReason2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ContentParseFault_USCOREReason(struct soap *soap, const char *s, enum ns2__ContentParseFault_USCOREReason *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ContentParseFault_USCOREReason, s);
	if (map)
		*a = (enum ns2__ContentParseFault_USCOREReason)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 13)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ContentParseFault_USCOREReason)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ContentParseFault_USCOREReason * SOAP_FMAC4 soap_in_ns2__ContentParseFault_USCOREReason(struct soap *soap, const char *tag, enum ns2__ContentParseFault_USCOREReason *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ContentParseFault_USCOREReason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentParseFault_USCOREReason, sizeof(enum ns2__ContentParseFault_USCOREReason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ContentParseFault_USCOREReason(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ContentParseFault_USCOREReason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentParseFault_USCOREReason, 0, sizeof(enum ns2__ContentParseFault_USCOREReason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ContentParseFault_USCOREReason(struct soap *soap, const enum ns2__ContentParseFault_USCOREReason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ContentParseFault_USCOREReason);
	if (soap_out_ns2__ContentParseFault_USCOREReason(soap, tag?tag:"ns2:ContentParseFault_Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ContentParseFault_USCOREReason * SOAP_FMAC4 soap_get_ns2__ContentParseFault_USCOREReason(struct soap *soap, enum ns2__ContentParseFault_USCOREReason *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentParseFault_USCOREReason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Account_USCOREType(struct soap *soap, enum ns1__Account_USCOREType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__Account_USCOREType
	*a = SOAP_DEFAULT_ns1__Account_USCOREType;
#else
	*a = (enum ns1__Account_USCOREType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__Account_USCOREType[] =
{	{ (long)ns1__Account_USCOREType__USER, "USER" },
	{ (long)ns1__Account_USCOREType__GROUP, "GROUP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Account_USCOREType2s(struct soap *soap, enum ns1__Account_USCOREType n)
{	const char *s = soap_code_str(soap_codes_ns1__Account_USCOREType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Account_USCOREType(struct soap *soap, const char *tag, int id, const enum ns1__Account_USCOREType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Account_USCOREType), type) || soap_send(soap, soap_ns1__Account_USCOREType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Account_USCOREType(struct soap *soap, const char *s, enum ns1__Account_USCOREType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Account_USCOREType, s);
	if (map)
		*a = (enum ns1__Account_USCOREType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Account_USCOREType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Account_USCOREType * SOAP_FMAC4 soap_in_ns1__Account_USCOREType(struct soap *soap, const char *tag, enum ns1__Account_USCOREType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Account_USCOREType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Account_USCOREType, sizeof(enum ns1__Account_USCOREType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__Account_USCOREType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__Account_USCOREType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Account_USCOREType, 0, sizeof(enum ns1__Account_USCOREType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Account_USCOREType(struct soap *soap, const enum ns1__Account_USCOREType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Account_USCOREType);
	if (soap_out_ns1__Account_USCOREType(soap, tag?tag:"ns1:Account_Type", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Account_USCOREType * SOAP_FMAC4 soap_get_ns1__Account_USCOREType(struct soap *soap, enum ns1__Account_USCOREType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Account_USCOREType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__RelativeTimeSpan_USCORETimeBase(struct soap *soap, enum ns1__RelativeTimeSpan_USCORETimeBase *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__RelativeTimeSpan_USCORETimeBase
	*a = SOAP_DEFAULT_ns1__RelativeTimeSpan_USCORETimeBase;
#else
	*a = (enum ns1__RelativeTimeSpan_USCORETimeBase)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__RelativeTimeSpan_USCORETimeBase[] =
{	{ (long)ns1__RelativeTimeSpan_USCORETimeBase__CLASSIFICATION, "CLASSIFICATION" },
	{ (long)ns1__RelativeTimeSpan_USCORETimeBase__LICENSE, "LICENSE" },
	{ (long)ns1__RelativeTimeSpan_USCORETimeBase__REQUEST, "REQUEST" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__RelativeTimeSpan_USCORETimeBase2s(struct soap *soap, enum ns1__RelativeTimeSpan_USCORETimeBase n)
{	const char *s = soap_code_str(soap_codes_ns1__RelativeTimeSpan_USCORETimeBase, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RelativeTimeSpan_USCORETimeBase(struct soap *soap, const char *tag, int id, const enum ns1__RelativeTimeSpan_USCORETimeBase *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RelativeTimeSpan_USCORETimeBase), type) || soap_send(soap, soap_ns1__RelativeTimeSpan_USCORETimeBase2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__RelativeTimeSpan_USCORETimeBase(struct soap *soap, const char *s, enum ns1__RelativeTimeSpan_USCORETimeBase *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__RelativeTimeSpan_USCORETimeBase, s);
	if (map)
		*a = (enum ns1__RelativeTimeSpan_USCORETimeBase)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__RelativeTimeSpan_USCORETimeBase)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__RelativeTimeSpan_USCORETimeBase * SOAP_FMAC4 soap_in_ns1__RelativeTimeSpan_USCORETimeBase(struct soap *soap, const char *tag, enum ns1__RelativeTimeSpan_USCORETimeBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__RelativeTimeSpan_USCORETimeBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RelativeTimeSpan_USCORETimeBase, sizeof(enum ns1__RelativeTimeSpan_USCORETimeBase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__RelativeTimeSpan_USCORETimeBase(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__RelativeTimeSpan_USCORETimeBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RelativeTimeSpan_USCORETimeBase, 0, sizeof(enum ns1__RelativeTimeSpan_USCORETimeBase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__RelativeTimeSpan_USCORETimeBase(struct soap *soap, const enum ns1__RelativeTimeSpan_USCORETimeBase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__RelativeTimeSpan_USCORETimeBase);
	if (soap_out_ns1__RelativeTimeSpan_USCORETimeBase(soap, tag?tag:"ns1:RelativeTimeSpan_TimeBase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__RelativeTimeSpan_USCORETimeBase * SOAP_FMAC4 soap_get_ns1__RelativeTimeSpan_USCORETimeBase(struct soap *soap, enum ns1__RelativeTimeSpan_USCORETimeBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RelativeTimeSpan_USCORETimeBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TimePeriod_USCOREUnits(struct soap *soap, enum ns1__TimePeriod_USCOREUnits *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TimePeriod_USCOREUnits
	*a = SOAP_DEFAULT_ns1__TimePeriod_USCOREUnits;
#else
	*a = (enum ns1__TimePeriod_USCOREUnits)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TimePeriod_USCOREUnits[] =
{	{ (long)ns1__TimePeriod_USCOREUnits__SECONDS, "SECONDS" },
	{ (long)ns1__TimePeriod_USCOREUnits__MINUTES, "MINUTES" },
	{ (long)ns1__TimePeriod_USCOREUnits__HOURS, "HOURS" },
	{ (long)ns1__TimePeriod_USCOREUnits__DAYS, "DAYS" },
	{ (long)ns1__TimePeriod_USCOREUnits__MONTHS, "MONTHS" },
	{ (long)ns1__TimePeriod_USCOREUnits__YEARS, "YEARS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TimePeriod_USCOREUnits2s(struct soap *soap, enum ns1__TimePeriod_USCOREUnits n)
{	const char *s = soap_code_str(soap_codes_ns1__TimePeriod_USCOREUnits, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TimePeriod_USCOREUnits(struct soap *soap, const char *tag, int id, const enum ns1__TimePeriod_USCOREUnits *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TimePeriod_USCOREUnits), type) || soap_send(soap, soap_ns1__TimePeriod_USCOREUnits2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TimePeriod_USCOREUnits(struct soap *soap, const char *s, enum ns1__TimePeriod_USCOREUnits *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TimePeriod_USCOREUnits, s);
	if (map)
		*a = (enum ns1__TimePeriod_USCOREUnits)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TimePeriod_USCOREUnits)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TimePeriod_USCOREUnits * SOAP_FMAC4 soap_in_ns1__TimePeriod_USCOREUnits(struct soap *soap, const char *tag, enum ns1__TimePeriod_USCOREUnits *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TimePeriod_USCOREUnits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TimePeriod_USCOREUnits, sizeof(enum ns1__TimePeriod_USCOREUnits), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TimePeriod_USCOREUnits(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TimePeriod_USCOREUnits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TimePeriod_USCOREUnits, 0, sizeof(enum ns1__TimePeriod_USCOREUnits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TimePeriod_USCOREUnits(struct soap *soap, const enum ns1__TimePeriod_USCOREUnits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TimePeriod_USCOREUnits);
	if (soap_out_ns1__TimePeriod_USCOREUnits(soap, tag?tag:"ns1:TimePeriod_Units", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TimePeriod_USCOREUnits * SOAP_FMAC4 soap_get_ns1__TimePeriod_USCOREUnits(struct soap *soap, enum ns1__TimePeriod_USCOREUnits *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TimePeriod_USCOREUnits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__TimeSpan_USCOREReferencePoint(struct soap *soap, enum ns1__TimeSpan_USCOREReferencePoint *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__TimeSpan_USCOREReferencePoint
	*a = SOAP_DEFAULT_ns1__TimeSpan_USCOREReferencePoint;
#else
	*a = (enum ns1__TimeSpan_USCOREReferencePoint)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__TimeSpan_USCOREReferencePoint[] =
{	{ (long)ns1__TimeSpan_USCOREReferencePoint__CURRENT, "CURRENT" },
	{ (long)ns1__TimeSpan_USCOREReferencePoint__CLASSIFICATION, "CLASSIFICATION" },
	{ (long)ns1__TimeSpan_USCOREReferencePoint__LICENSE, "LICENSE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__TimeSpan_USCOREReferencePoint2s(struct soap *soap, enum ns1__TimeSpan_USCOREReferencePoint n)
{	const char *s = soap_code_str(soap_codes_ns1__TimeSpan_USCOREReferencePoint, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TimeSpan_USCOREReferencePoint(struct soap *soap, const char *tag, int id, const enum ns1__TimeSpan_USCOREReferencePoint *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TimeSpan_USCOREReferencePoint), type) || soap_send(soap, soap_ns1__TimeSpan_USCOREReferencePoint2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__TimeSpan_USCOREReferencePoint(struct soap *soap, const char *s, enum ns1__TimeSpan_USCOREReferencePoint *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__TimeSpan_USCOREReferencePoint, s);
	if (map)
		*a = (enum ns1__TimeSpan_USCOREReferencePoint)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__TimeSpan_USCOREReferencePoint)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__TimeSpan_USCOREReferencePoint * SOAP_FMAC4 soap_in_ns1__TimeSpan_USCOREReferencePoint(struct soap *soap, const char *tag, enum ns1__TimeSpan_USCOREReferencePoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__TimeSpan_USCOREReferencePoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TimeSpan_USCOREReferencePoint, sizeof(enum ns1__TimeSpan_USCOREReferencePoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__TimeSpan_USCOREReferencePoint(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__TimeSpan_USCOREReferencePoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TimeSpan_USCOREReferencePoint, 0, sizeof(enum ns1__TimeSpan_USCOREReferencePoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__TimeSpan_USCOREReferencePoint(struct soap *soap, const enum ns1__TimeSpan_USCOREReferencePoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__TimeSpan_USCOREReferencePoint);
	if (soap_out_ns1__TimeSpan_USCOREReferencePoint(soap, tag?tag:"ns1:TimeSpan_ReferencePoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__TimeSpan_USCOREReferencePoint * SOAP_FMAC4 soap_get_ns1__TimeSpan_USCOREReferencePoint(struct soap *soap, enum ns1__TimeSpan_USCOREReferencePoint *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TimeSpan_USCOREReferencePoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Feature_USCOREUse(struct soap *soap, enum ns1__Feature_USCOREUse *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__Feature_USCOREUse
	*a = SOAP_DEFAULT_ns1__Feature_USCOREUse;
#else
	*a = (enum ns1__Feature_USCOREUse)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__Feature_USCOREUse[] =
{	{ (long)ns1__Feature_USCOREUse__IMMEDIATE, "IMMEDIATE" },
	{ (long)ns1__Feature_USCOREUse__DEMAND, "DEMAND" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Feature_USCOREUse2s(struct soap *soap, enum ns1__Feature_USCOREUse n)
{	const char *s = soap_code_str(soap_codes_ns1__Feature_USCOREUse, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Feature_USCOREUse(struct soap *soap, const char *tag, int id, const enum ns1__Feature_USCOREUse *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Feature_USCOREUse), type) || soap_send(soap, soap_ns1__Feature_USCOREUse2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Feature_USCOREUse(struct soap *soap, const char *s, enum ns1__Feature_USCOREUse *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Feature_USCOREUse, s);
	if (map)
		*a = (enum ns1__Feature_USCOREUse)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Feature_USCOREUse)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Feature_USCOREUse * SOAP_FMAC4 soap_in_ns1__Feature_USCOREUse(struct soap *soap, const char *tag, enum ns1__Feature_USCOREUse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Feature_USCOREUse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Feature_USCOREUse, sizeof(enum ns1__Feature_USCOREUse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__Feature_USCOREUse(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__Feature_USCOREUse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Feature_USCOREUse, 0, sizeof(enum ns1__Feature_USCOREUse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Feature_USCOREUse(struct soap *soap, const enum ns1__Feature_USCOREUse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Feature_USCOREUse);
	if (soap_out_ns1__Feature_USCOREUse(soap, tag?tag:"ns1:Feature_Use", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Feature_USCOREUse * SOAP_FMAC4 soap_get_ns1__Feature_USCOREUse(struct soap *soap, enum ns1__Feature_USCOREUse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Feature_USCOREUse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Feature_USCORESupport(struct soap *soap, enum ns1__Feature_USCORESupport *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__Feature_USCORESupport
	*a = SOAP_DEFAULT_ns1__Feature_USCORESupport;
#else
	*a = (enum ns1__Feature_USCORESupport)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__Feature_USCORESupport[] =
{	{ (long)ns1__Feature_USCORESupport__AVAILABLE, "AVAILABLE" },
	{ (long)ns1__Feature_USCORESupport__ON_USCOREDEMAND, "ON_DEMAND" },
	{ (long)ns1__Feature_USCORESupport__UNAVAILABLE, "UNAVAILABLE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__Feature_USCORESupport2s(struct soap *soap, enum ns1__Feature_USCORESupport n)
{	const char *s = soap_code_str(soap_codes_ns1__Feature_USCORESupport, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Feature_USCORESupport(struct soap *soap, const char *tag, int id, const enum ns1__Feature_USCORESupport *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Feature_USCORESupport), type) || soap_send(soap, soap_ns1__Feature_USCORESupport2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__Feature_USCORESupport(struct soap *soap, const char *s, enum ns1__Feature_USCORESupport *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__Feature_USCORESupport, s);
	if (map)
		*a = (enum ns1__Feature_USCORESupport)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__Feature_USCORESupport)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__Feature_USCORESupport * SOAP_FMAC4 soap_in_ns1__Feature_USCORESupport(struct soap *soap, const char *tag, enum ns1__Feature_USCORESupport *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__Feature_USCORESupport *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Feature_USCORESupport, sizeof(enum ns1__Feature_USCORESupport), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__Feature_USCORESupport(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__Feature_USCORESupport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Feature_USCORESupport, 0, sizeof(enum ns1__Feature_USCORESupport), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Feature_USCORESupport(struct soap *soap, const enum ns1__Feature_USCORESupport *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__Feature_USCORESupport);
	if (soap_out_ns1__Feature_USCORESupport(soap, tag?tag:"ns1:Feature_Support", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__Feature_USCORESupport * SOAP_FMAC4 soap_get_ns1__Feature_USCORESupport(struct soap *soap, enum ns1__Feature_USCORESupport *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Feature_USCORESupport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__LicenseCriteria_USCOREUse(struct soap *soap, enum ns1__LicenseCriteria_USCOREUse *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__LicenseCriteria_USCOREUse
	*a = SOAP_DEFAULT_ns1__LicenseCriteria_USCOREUse;
#else
	*a = (enum ns1__LicenseCriteria_USCOREUse)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__LicenseCriteria_USCOREUse[] =
{	{ (long)ns1__LicenseCriteria_USCOREUse__PRIMARY, "PRIMARY" },
	{ (long)ns1__LicenseCriteria_USCOREUse__SECONDARY, "SECONDARY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__LicenseCriteria_USCOREUse2s(struct soap *soap, enum ns1__LicenseCriteria_USCOREUse n)
{	const char *s = soap_code_str(soap_codes_ns1__LicenseCriteria_USCOREUse, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LicenseCriteria_USCOREUse(struct soap *soap, const char *tag, int id, const enum ns1__LicenseCriteria_USCOREUse *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LicenseCriteria_USCOREUse), type) || soap_send(soap, soap_ns1__LicenseCriteria_USCOREUse2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__LicenseCriteria_USCOREUse(struct soap *soap, const char *s, enum ns1__LicenseCriteria_USCOREUse *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__LicenseCriteria_USCOREUse, s);
	if (map)
		*a = (enum ns1__LicenseCriteria_USCOREUse)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__LicenseCriteria_USCOREUse)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__LicenseCriteria_USCOREUse * SOAP_FMAC4 soap_in_ns1__LicenseCriteria_USCOREUse(struct soap *soap, const char *tag, enum ns1__LicenseCriteria_USCOREUse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__LicenseCriteria_USCOREUse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LicenseCriteria_USCOREUse, sizeof(enum ns1__LicenseCriteria_USCOREUse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__LicenseCriteria_USCOREUse(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__LicenseCriteria_USCOREUse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LicenseCriteria_USCOREUse, 0, sizeof(enum ns1__LicenseCriteria_USCOREUse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__LicenseCriteria_USCOREUse(struct soap *soap, const enum ns1__LicenseCriteria_USCOREUse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__LicenseCriteria_USCOREUse);
	if (soap_out_ns1__LicenseCriteria_USCOREUse(soap, tag?tag:"ns1:LicenseCriteria_Use", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__LicenseCriteria_USCOREUse * SOAP_FMAC4 soap_get_ns1__LicenseCriteria_USCOREUse(struct soap *soap, enum ns1__LicenseCriteria_USCOREUse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LicenseCriteria_USCOREUse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__LicenseCriteria_USCOREDelivery(struct soap *soap, enum ns1__LicenseCriteria_USCOREDelivery *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__LicenseCriteria_USCOREDelivery
	*a = SOAP_DEFAULT_ns1__LicenseCriteria_USCOREDelivery;
#else
	*a = (enum ns1__LicenseCriteria_USCOREDelivery)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__LicenseCriteria_USCOREDelivery[] =
{	{ (long)ns1__LicenseCriteria_USCOREDelivery__SYNCHRONIZATION, "SYNCHRONIZATION" },
	{ (long)ns1__LicenseCriteria_USCOREDelivery__ON_USCOREDEMAND, "ON_DEMAND" },
	{ (long)ns1__LicenseCriteria_USCOREDelivery__CLIENT, "CLIENT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__LicenseCriteria_USCOREDelivery2s(struct soap *soap, enum ns1__LicenseCriteria_USCOREDelivery n)
{	const char *s = soap_code_str(soap_codes_ns1__LicenseCriteria_USCOREDelivery, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LicenseCriteria_USCOREDelivery(struct soap *soap, const char *tag, int id, const enum ns1__LicenseCriteria_USCOREDelivery *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LicenseCriteria_USCOREDelivery), type) || soap_send(soap, soap_ns1__LicenseCriteria_USCOREDelivery2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__LicenseCriteria_USCOREDelivery(struct soap *soap, const char *s, enum ns1__LicenseCriteria_USCOREDelivery *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__LicenseCriteria_USCOREDelivery, s);
	if (map)
		*a = (enum ns1__LicenseCriteria_USCOREDelivery)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__LicenseCriteria_USCOREDelivery)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__LicenseCriteria_USCOREDelivery * SOAP_FMAC4 soap_in_ns1__LicenseCriteria_USCOREDelivery(struct soap *soap, const char *tag, enum ns1__LicenseCriteria_USCOREDelivery *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__LicenseCriteria_USCOREDelivery *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LicenseCriteria_USCOREDelivery, sizeof(enum ns1__LicenseCriteria_USCOREDelivery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__LicenseCriteria_USCOREDelivery(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__LicenseCriteria_USCOREDelivery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LicenseCriteria_USCOREDelivery, 0, sizeof(enum ns1__LicenseCriteria_USCOREDelivery), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__LicenseCriteria_USCOREDelivery(struct soap *soap, const enum ns1__LicenseCriteria_USCOREDelivery *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__LicenseCriteria_USCOREDelivery);
	if (soap_out_ns1__LicenseCriteria_USCOREDelivery(soap, tag?tag:"ns1:LicenseCriteria_Delivery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__LicenseCriteria_USCOREDelivery * SOAP_FMAC4 soap_get_ns1__LicenseCriteria_USCOREDelivery(struct soap *soap, enum ns1__LicenseCriteria_USCOREDelivery *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LicenseCriteria_USCOREDelivery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__LicenseCriteria_USCOREStorage(struct soap *soap, enum ns1__LicenseCriteria_USCOREStorage *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__LicenseCriteria_USCOREStorage
	*a = SOAP_DEFAULT_ns1__LicenseCriteria_USCOREStorage;
#else
	*a = (enum ns1__LicenseCriteria_USCOREStorage)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__LicenseCriteria_USCOREStorage[] =
{	{ (long)ns1__LicenseCriteria_USCOREStorage__PERSISTENT, "PERSISTENT" },
	{ (long)ns1__LicenseCriteria_USCOREStorage__TRANSIENT, "TRANSIENT" },
	{ (long)ns1__LicenseCriteria_USCOREStorage__ANY, "ANY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__LicenseCriteria_USCOREStorage2s(struct soap *soap, enum ns1__LicenseCriteria_USCOREStorage n)
{	const char *s = soap_code_str(soap_codes_ns1__LicenseCriteria_USCOREStorage, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LicenseCriteria_USCOREStorage(struct soap *soap, const char *tag, int id, const enum ns1__LicenseCriteria_USCOREStorage *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LicenseCriteria_USCOREStorage), type) || soap_send(soap, soap_ns1__LicenseCriteria_USCOREStorage2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__LicenseCriteria_USCOREStorage(struct soap *soap, const char *s, enum ns1__LicenseCriteria_USCOREStorage *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__LicenseCriteria_USCOREStorage, s);
	if (map)
		*a = (enum ns1__LicenseCriteria_USCOREStorage)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__LicenseCriteria_USCOREStorage)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__LicenseCriteria_USCOREStorage * SOAP_FMAC4 soap_in_ns1__LicenseCriteria_USCOREStorage(struct soap *soap, const char *tag, enum ns1__LicenseCriteria_USCOREStorage *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__LicenseCriteria_USCOREStorage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LicenseCriteria_USCOREStorage, sizeof(enum ns1__LicenseCriteria_USCOREStorage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__LicenseCriteria_USCOREStorage(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__LicenseCriteria_USCOREStorage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LicenseCriteria_USCOREStorage, 0, sizeof(enum ns1__LicenseCriteria_USCOREStorage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__LicenseCriteria_USCOREStorage(struct soap *soap, const enum ns1__LicenseCriteria_USCOREStorage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__LicenseCriteria_USCOREStorage);
	if (soap_out_ns1__LicenseCriteria_USCOREStorage(soap, tag?tag:"ns1:LicenseCriteria_Storage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__LicenseCriteria_USCOREStorage * SOAP_FMAC4 soap_get_ns1__LicenseCriteria_USCOREStorage(struct soap *soap, enum ns1__LicenseCriteria_USCOREStorage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LicenseCriteria_USCOREStorage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns7__ListRightsByAccountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__ListRightsByAccountResponse::return_);
	/* transient soap skipped */
}

void _ns7__ListRightsByAccountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__ListRightsByAccountResponse::return_);
	/* transient soap skipped */
}

int _ns7__ListRightsByAccountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__ListRightsByAccountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ListRightsByAccountResponse(struct soap *soap, const char *tag, int id, const _ns7__ListRightsByAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ListRightsByAccountResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", -1, &(a->_ns7__ListRightsByAccountResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__ListRightsByAccountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__ListRightsByAccountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__ListRightsByAccountResponse * SOAP_FMAC4 soap_in__ns7__ListRightsByAccountResponse(struct soap *soap, const char *tag, _ns7__ListRightsByAccountResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__ListRightsByAccountResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ListRightsByAccountResponse, sizeof(_ns7__ListRightsByAccountResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__ListRightsByAccountResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__ListRightsByAccountResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", &(a->_ns7__ListRightsByAccountResponse::return_), "ns6:DocumentRight"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__ListRightsByAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ListRightsByAccountResponse, 0, sizeof(_ns7__ListRightsByAccountResponse), 0, soap_copy__ns7__ListRightsByAccountResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns7__ListRightsByAccountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__ListRightsByAccountResponse);
	if (this->soap_out(soap, tag?tag:"ns7:ListRightsByAccountResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__ListRightsByAccountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__ListRightsByAccountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__ListRightsByAccountResponse * SOAP_FMAC4 soap_get__ns7__ListRightsByAccountResponse(struct soap *soap, _ns7__ListRightsByAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ListRightsByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__ListRightsByAccountResponse * SOAP_FMAC2 soap_instantiate__ns7__ListRightsByAccountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__ListRightsByAccountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__ListRightsByAccountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ListRightsByAccountResponse);
		if (size)
			*size = sizeof(_ns7__ListRightsByAccountResponse);
		((_ns7__ListRightsByAccountResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ListRightsByAccountResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__ListRightsByAccountResponse);
		for (int i = 0; i < n; i++)
			((_ns7__ListRightsByAccountResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__ListRightsByAccountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__ListRightsByAccountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__ListRightsByAccountResponse %p -> %p\n", q, p));
	*(_ns7__ListRightsByAccountResponse*)p = *(_ns7__ListRightsByAccountResponse*)q;
}

void _ns7__ListRightsByAccount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__ListRightsByAccount::account = NULL;
	/* transient soap skipped */
}

void _ns7__ListRightsByAccount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AccountRef(soap, &this->_ns7__ListRightsByAccount::account);
	/* transient soap skipped */
}

int _ns7__ListRightsByAccount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__ListRightsByAccount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ListRightsByAccount(struct soap *soap, const char *tag, int id, const _ns7__ListRightsByAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ListRightsByAccount), type))
		return soap->error;
	if (soap_out_PointerTons1__AccountRef(soap, "account", -1, &(a->_ns7__ListRightsByAccount::account), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__ListRightsByAccount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__ListRightsByAccount(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__ListRightsByAccount * SOAP_FMAC4 soap_in__ns7__ListRightsByAccount(struct soap *soap, const char *tag, _ns7__ListRightsByAccount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__ListRightsByAccount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ListRightsByAccount, sizeof(_ns7__ListRightsByAccount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__ListRightsByAccount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__ListRightsByAccount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_account1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountRef(soap, "account", &(a->_ns7__ListRightsByAccount::account), "ns1:AccountRef"))
				{	soap_flag_account1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__ListRightsByAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ListRightsByAccount, 0, sizeof(_ns7__ListRightsByAccount), 0, soap_copy__ns7__ListRightsByAccount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_account1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns7__ListRightsByAccount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__ListRightsByAccount);
	if (this->soap_out(soap, tag?tag:"ns7:ListRightsByAccount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__ListRightsByAccount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__ListRightsByAccount(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__ListRightsByAccount * SOAP_FMAC4 soap_get__ns7__ListRightsByAccount(struct soap *soap, _ns7__ListRightsByAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ListRightsByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__ListRightsByAccount * SOAP_FMAC2 soap_instantiate__ns7__ListRightsByAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__ListRightsByAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__ListRightsByAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ListRightsByAccount);
		if (size)
			*size = sizeof(_ns7__ListRightsByAccount);
		((_ns7__ListRightsByAccount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ListRightsByAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__ListRightsByAccount);
		for (int i = 0; i < n; i++)
			((_ns7__ListRightsByAccount*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__ListRightsByAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__ListRightsByAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__ListRightsByAccount %p -> %p\n", q, p));
	*(_ns7__ListRightsByAccount*)p = *(_ns7__ListRightsByAccount*)q;
}

void _ns7__ListRightsByContextResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__ListRightsByContextResponse::return_);
	/* transient soap skipped */
}

void _ns7__ListRightsByContextResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__ListRightsByContextResponse::return_);
	/* transient soap skipped */
}

int _ns7__ListRightsByContextResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__ListRightsByContextResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ListRightsByContextResponse(struct soap *soap, const char *tag, int id, const _ns7__ListRightsByContextResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ListRightsByContextResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", -1, &(a->_ns7__ListRightsByContextResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__ListRightsByContextResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__ListRightsByContextResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__ListRightsByContextResponse * SOAP_FMAC4 soap_in__ns7__ListRightsByContextResponse(struct soap *soap, const char *tag, _ns7__ListRightsByContextResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__ListRightsByContextResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ListRightsByContextResponse, sizeof(_ns7__ListRightsByContextResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__ListRightsByContextResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__ListRightsByContextResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", &(a->_ns7__ListRightsByContextResponse::return_), "ns6:DocumentRight"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__ListRightsByContextResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ListRightsByContextResponse, 0, sizeof(_ns7__ListRightsByContextResponse), 0, soap_copy__ns7__ListRightsByContextResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns7__ListRightsByContextResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__ListRightsByContextResponse);
	if (this->soap_out(soap, tag?tag:"ns7:ListRightsByContextResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__ListRightsByContextResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__ListRightsByContextResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__ListRightsByContextResponse * SOAP_FMAC4 soap_get__ns7__ListRightsByContextResponse(struct soap *soap, _ns7__ListRightsByContextResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ListRightsByContextResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__ListRightsByContextResponse * SOAP_FMAC2 soap_instantiate__ns7__ListRightsByContextResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__ListRightsByContextResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__ListRightsByContextResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ListRightsByContextResponse);
		if (size)
			*size = sizeof(_ns7__ListRightsByContextResponse);
		((_ns7__ListRightsByContextResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ListRightsByContextResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__ListRightsByContextResponse);
		for (int i = 0; i < n; i++)
			((_ns7__ListRightsByContextResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__ListRightsByContextResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__ListRightsByContextResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__ListRightsByContextResponse %p -> %p\n", q, p));
	*(_ns7__ListRightsByContextResponse*)p = *(_ns7__ListRightsByContextResponse*)q;
}

void _ns7__ListRightsByContext::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__ListRightsByContext::context = NULL;
	this->_ns7__ListRightsByContext::pageRange = NULL;
	/* transient soap skipped */
}

void _ns7__ListRightsByContext::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__ContextInstanceRef(soap, &this->_ns7__ListRightsByContext::context);
	soap_serialize_PointerTons1__PageRange(soap, &this->_ns7__ListRightsByContext::pageRange);
	/* transient soap skipped */
}

int _ns7__ListRightsByContext::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__ListRightsByContext(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ListRightsByContext(struct soap *soap, const char *tag, int id, const _ns7__ListRightsByContext *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ListRightsByContext), type))
		return soap->error;
	if (soap_out_PointerTons6__ContextInstanceRef(soap, "context", -1, &(a->_ns7__ListRightsByContext::context), ""))
		return soap->error;
	if (soap_out_PointerTons1__PageRange(soap, "pageRange", -1, &(a->_ns7__ListRightsByContext::pageRange), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__ListRightsByContext::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__ListRightsByContext(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__ListRightsByContext * SOAP_FMAC4 soap_in__ns7__ListRightsByContext(struct soap *soap, const char *tag, _ns7__ListRightsByContext *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__ListRightsByContext *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ListRightsByContext, sizeof(_ns7__ListRightsByContext), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__ListRightsByContext)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__ListRightsByContext *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_context1 = 1;
	size_t soap_flag_pageRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_context1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ContextInstanceRef(soap, "context", &(a->_ns7__ListRightsByContext::context), "ns6:ContextInstanceRef"))
				{	soap_flag_context1--;
					continue;
				}
			if (soap_flag_pageRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PageRange(soap, "pageRange", &(a->_ns7__ListRightsByContext::pageRange), "ns1:PageRange"))
				{	soap_flag_pageRange1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__ListRightsByContext *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ListRightsByContext, 0, sizeof(_ns7__ListRightsByContext), 0, soap_copy__ns7__ListRightsByContext);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_context1 > 0 || soap_flag_pageRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns7__ListRightsByContext::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__ListRightsByContext);
	if (this->soap_out(soap, tag?tag:"ns7:ListRightsByContext", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__ListRightsByContext::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__ListRightsByContext(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__ListRightsByContext * SOAP_FMAC4 soap_get__ns7__ListRightsByContext(struct soap *soap, _ns7__ListRightsByContext *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ListRightsByContext(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__ListRightsByContext * SOAP_FMAC2 soap_instantiate__ns7__ListRightsByContext(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__ListRightsByContext(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__ListRightsByContext, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ListRightsByContext);
		if (size)
			*size = sizeof(_ns7__ListRightsByContext);
		((_ns7__ListRightsByContext*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ListRightsByContext[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__ListRightsByContext);
		for (int i = 0; i < n; i++)
			((_ns7__ListRightsByContext*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__ListRightsByContext*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__ListRightsByContext(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__ListRightsByContext %p -> %p\n", q, p));
	*(_ns7__ListRightsByContext*)p = *(_ns7__ListRightsByContext*)q;
}

void _ns7__UnassignRightsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns7__UnassignRightsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _ns7__UnassignRightsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__UnassignRightsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__UnassignRightsResponse(struct soap *soap, const char *tag, int id, const _ns7__UnassignRightsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__UnassignRightsResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__UnassignRightsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__UnassignRightsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__UnassignRightsResponse * SOAP_FMAC4 soap_in__ns7__UnassignRightsResponse(struct soap *soap, const char *tag, _ns7__UnassignRightsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__UnassignRightsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__UnassignRightsResponse, sizeof(_ns7__UnassignRightsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__UnassignRightsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__UnassignRightsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__UnassignRightsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__UnassignRightsResponse, 0, sizeof(_ns7__UnassignRightsResponse), 0, soap_copy__ns7__UnassignRightsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns7__UnassignRightsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__UnassignRightsResponse);
	if (this->soap_out(soap, tag?tag:"ns7:UnassignRightsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__UnassignRightsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__UnassignRightsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__UnassignRightsResponse * SOAP_FMAC4 soap_get__ns7__UnassignRightsResponse(struct soap *soap, _ns7__UnassignRightsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__UnassignRightsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__UnassignRightsResponse * SOAP_FMAC2 soap_instantiate__ns7__UnassignRightsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__UnassignRightsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__UnassignRightsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__UnassignRightsResponse);
		if (size)
			*size = sizeof(_ns7__UnassignRightsResponse);
		((_ns7__UnassignRightsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__UnassignRightsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__UnassignRightsResponse);
		for (int i = 0; i < n; i++)
			((_ns7__UnassignRightsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__UnassignRightsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__UnassignRightsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__UnassignRightsResponse %p -> %p\n", q, p));
	*(_ns7__UnassignRightsResponse*)p = *(_ns7__UnassignRightsResponse*)q;
}

void _ns7__UnassignRights::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, &this->_ns7__UnassignRights::rights);
	/* transient soap skipped */
}

void _ns7__UnassignRights::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, &this->_ns7__UnassignRights::rights);
	/* transient soap skipped */
}

int _ns7__UnassignRights::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__UnassignRights(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__UnassignRights(struct soap *soap, const char *tag, int id, const _ns7__UnassignRights *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__UnassignRights), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, "rights", -1, &(a->_ns7__UnassignRights::rights), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__UnassignRights::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__UnassignRights(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__UnassignRights * SOAP_FMAC4 soap_in__ns7__UnassignRights(struct soap *soap, const char *tag, _ns7__UnassignRights *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__UnassignRights *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__UnassignRights, sizeof(_ns7__UnassignRights), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__UnassignRights)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__UnassignRights *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, "rights", &(a->_ns7__UnassignRights::rights), "ns6:DocumentRightRef"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__UnassignRights *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__UnassignRights, 0, sizeof(_ns7__UnassignRights), 0, soap_copy__ns7__UnassignRights);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns7__UnassignRights::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__UnassignRights);
	if (this->soap_out(soap, tag?tag:"ns7:UnassignRights", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__UnassignRights::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__UnassignRights(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__UnassignRights * SOAP_FMAC4 soap_get__ns7__UnassignRights(struct soap *soap, _ns7__UnassignRights *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__UnassignRights(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__UnassignRights * SOAP_FMAC2 soap_instantiate__ns7__UnassignRights(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__UnassignRights(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__UnassignRights, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__UnassignRights);
		if (size)
			*size = sizeof(_ns7__UnassignRights);
		((_ns7__UnassignRights*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__UnassignRights[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__UnassignRights);
		for (int i = 0; i < n; i++)
			((_ns7__UnassignRights*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__UnassignRights*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__UnassignRights(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__UnassignRights %p -> %p\n", q, p));
	*(_ns7__UnassignRights*)p = *(_ns7__UnassignRights*)q;
}

void _ns7__SaveChangesToItemsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__SaveChangesToItemsResponse::return_);
	/* transient soap skipped */
}

void _ns7__SaveChangesToItemsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__SaveChangesToItemsResponse::return_);
	/* transient soap skipped */
}

int _ns7__SaveChangesToItemsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__SaveChangesToItemsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__SaveChangesToItemsResponse(struct soap *soap, const char *tag, int id, const _ns7__SaveChangesToItemsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__SaveChangesToItemsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", -1, &(a->_ns7__SaveChangesToItemsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__SaveChangesToItemsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__SaveChangesToItemsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__SaveChangesToItemsResponse * SOAP_FMAC4 soap_in__ns7__SaveChangesToItemsResponse(struct soap *soap, const char *tag, _ns7__SaveChangesToItemsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__SaveChangesToItemsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__SaveChangesToItemsResponse, sizeof(_ns7__SaveChangesToItemsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__SaveChangesToItemsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__SaveChangesToItemsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", &(a->_ns7__SaveChangesToItemsResponse::return_), "ns6:DocumentRight"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__SaveChangesToItemsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__SaveChangesToItemsResponse, 0, sizeof(_ns7__SaveChangesToItemsResponse), 0, soap_copy__ns7__SaveChangesToItemsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns7__SaveChangesToItemsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__SaveChangesToItemsResponse);
	if (this->soap_out(soap, tag?tag:"ns7:SaveChangesToItemsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__SaveChangesToItemsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__SaveChangesToItemsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__SaveChangesToItemsResponse * SOAP_FMAC4 soap_get__ns7__SaveChangesToItemsResponse(struct soap *soap, _ns7__SaveChangesToItemsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__SaveChangesToItemsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__SaveChangesToItemsResponse * SOAP_FMAC2 soap_instantiate__ns7__SaveChangesToItemsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__SaveChangesToItemsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__SaveChangesToItemsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__SaveChangesToItemsResponse);
		if (size)
			*size = sizeof(_ns7__SaveChangesToItemsResponse);
		((_ns7__SaveChangesToItemsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__SaveChangesToItemsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__SaveChangesToItemsResponse);
		for (int i = 0; i < n; i++)
			((_ns7__SaveChangesToItemsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__SaveChangesToItemsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__SaveChangesToItemsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__SaveChangesToItemsResponse %p -> %p\n", q, p));
	*(_ns7__SaveChangesToItemsResponse*)p = *(_ns7__SaveChangesToItemsResponse*)q;
}

void _ns7__SaveChangesToItems::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, &this->_ns7__SaveChangesToItems::rights);
	soap_default_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->_ns7__SaveChangesToItems::itemCodes);
	soap_default_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->_ns7__SaveChangesToItems::delta);
	/* transient soap skipped */
}

void _ns7__SaveChangesToItems::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, &this->_ns7__SaveChangesToItems::rights);
	soap_serialize_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->_ns7__SaveChangesToItems::itemCodes);
	soap_serialize_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->_ns7__SaveChangesToItems::delta);
	/* transient soap skipped */
}

int _ns7__SaveChangesToItems::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__SaveChangesToItems(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__SaveChangesToItems(struct soap *soap, const char *tag, int id, const _ns7__SaveChangesToItems *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__SaveChangesToItems), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, "rights", -1, &(a->_ns7__SaveChangesToItems::rights), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ItemCode(soap, "itemCodes", -1, &(a->_ns7__SaveChangesToItems::itemCodes), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ItemCode(soap, "delta", -1, &(a->_ns7__SaveChangesToItems::delta), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__SaveChangesToItems::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__SaveChangesToItems(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__SaveChangesToItems * SOAP_FMAC4 soap_in__ns7__SaveChangesToItems(struct soap *soap, const char *tag, _ns7__SaveChangesToItems *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__SaveChangesToItems *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__SaveChangesToItems, sizeof(_ns7__SaveChangesToItems), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__SaveChangesToItems)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__SaveChangesToItems *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, "rights", &(a->_ns7__SaveChangesToItems::rights), "ns6:DocumentRightRef"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__ItemCode(soap, "itemCodes", &(a->_ns7__SaveChangesToItems::itemCodes), "ns5:ItemCode"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__ItemCode(soap, "delta", &(a->_ns7__SaveChangesToItems::delta), "ns5:ItemCode"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__SaveChangesToItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__SaveChangesToItems, 0, sizeof(_ns7__SaveChangesToItems), 0, soap_copy__ns7__SaveChangesToItems);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns7__SaveChangesToItems::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__SaveChangesToItems);
	if (this->soap_out(soap, tag?tag:"ns7:SaveChangesToItems", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__SaveChangesToItems::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__SaveChangesToItems(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__SaveChangesToItems * SOAP_FMAC4 soap_get__ns7__SaveChangesToItems(struct soap *soap, _ns7__SaveChangesToItems *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__SaveChangesToItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__SaveChangesToItems * SOAP_FMAC2 soap_instantiate__ns7__SaveChangesToItems(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__SaveChangesToItems(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__SaveChangesToItems, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__SaveChangesToItems);
		if (size)
			*size = sizeof(_ns7__SaveChangesToItems);
		((_ns7__SaveChangesToItems*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__SaveChangesToItems[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__SaveChangesToItems);
		for (int i = 0; i < n; i++)
			((_ns7__SaveChangesToItems*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__SaveChangesToItems*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__SaveChangesToItems(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__SaveChangesToItems %p -> %p\n", q, p));
	*(_ns7__SaveChangesToItems*)p = *(_ns7__SaveChangesToItems*)q;
}

void _ns7__CheckInRightsForAccountResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__CheckInRightsForAccountResponse::return_);
	/* transient soap skipped */
}

void _ns7__CheckInRightsForAccountResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__CheckInRightsForAccountResponse::return_);
	/* transient soap skipped */
}

int _ns7__CheckInRightsForAccountResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__CheckInRightsForAccountResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__CheckInRightsForAccountResponse(struct soap *soap, const char *tag, int id, const _ns7__CheckInRightsForAccountResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__CheckInRightsForAccountResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", -1, &(a->_ns7__CheckInRightsForAccountResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__CheckInRightsForAccountResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__CheckInRightsForAccountResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__CheckInRightsForAccountResponse * SOAP_FMAC4 soap_in__ns7__CheckInRightsForAccountResponse(struct soap *soap, const char *tag, _ns7__CheckInRightsForAccountResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__CheckInRightsForAccountResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__CheckInRightsForAccountResponse, sizeof(_ns7__CheckInRightsForAccountResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__CheckInRightsForAccountResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__CheckInRightsForAccountResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", &(a->_ns7__CheckInRightsForAccountResponse::return_), "ns6:DocumentRight"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__CheckInRightsForAccountResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__CheckInRightsForAccountResponse, 0, sizeof(_ns7__CheckInRightsForAccountResponse), 0, soap_copy__ns7__CheckInRightsForAccountResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns7__CheckInRightsForAccountResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__CheckInRightsForAccountResponse);
	if (this->soap_out(soap, tag?tag:"ns7:CheckInRightsForAccountResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__CheckInRightsForAccountResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__CheckInRightsForAccountResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__CheckInRightsForAccountResponse * SOAP_FMAC4 soap_get__ns7__CheckInRightsForAccountResponse(struct soap *soap, _ns7__CheckInRightsForAccountResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__CheckInRightsForAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__CheckInRightsForAccountResponse * SOAP_FMAC2 soap_instantiate__ns7__CheckInRightsForAccountResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__CheckInRightsForAccountResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__CheckInRightsForAccountResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__CheckInRightsForAccountResponse);
		if (size)
			*size = sizeof(_ns7__CheckInRightsForAccountResponse);
		((_ns7__CheckInRightsForAccountResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__CheckInRightsForAccountResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__CheckInRightsForAccountResponse);
		for (int i = 0; i < n; i++)
			((_ns7__CheckInRightsForAccountResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__CheckInRightsForAccountResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__CheckInRightsForAccountResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__CheckInRightsForAccountResponse %p -> %p\n", q, p));
	*(_ns7__CheckInRightsForAccountResponse*)p = *(_ns7__CheckInRightsForAccountResponse*)q;
}

void _ns7__CheckInRightsForAccount::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__CheckInRightsForAccount::account = NULL;
	/* transient soap skipped */
}

void _ns7__CheckInRightsForAccount::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AccountRef(soap, &this->_ns7__CheckInRightsForAccount::account);
	/* transient soap skipped */
}

int _ns7__CheckInRightsForAccount::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__CheckInRightsForAccount(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__CheckInRightsForAccount(struct soap *soap, const char *tag, int id, const _ns7__CheckInRightsForAccount *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__CheckInRightsForAccount), type))
		return soap->error;
	if (soap_out_PointerTons1__AccountRef(soap, "account", -1, &(a->_ns7__CheckInRightsForAccount::account), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__CheckInRightsForAccount::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__CheckInRightsForAccount(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__CheckInRightsForAccount * SOAP_FMAC4 soap_in__ns7__CheckInRightsForAccount(struct soap *soap, const char *tag, _ns7__CheckInRightsForAccount *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__CheckInRightsForAccount *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__CheckInRightsForAccount, sizeof(_ns7__CheckInRightsForAccount), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__CheckInRightsForAccount)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__CheckInRightsForAccount *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_account1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountRef(soap, "account", &(a->_ns7__CheckInRightsForAccount::account), "ns1:AccountRef"))
				{	soap_flag_account1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__CheckInRightsForAccount *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__CheckInRightsForAccount, 0, sizeof(_ns7__CheckInRightsForAccount), 0, soap_copy__ns7__CheckInRightsForAccount);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_account1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns7__CheckInRightsForAccount::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__CheckInRightsForAccount);
	if (this->soap_out(soap, tag?tag:"ns7:CheckInRightsForAccount", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__CheckInRightsForAccount::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__CheckInRightsForAccount(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__CheckInRightsForAccount * SOAP_FMAC4 soap_get__ns7__CheckInRightsForAccount(struct soap *soap, _ns7__CheckInRightsForAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__CheckInRightsForAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__CheckInRightsForAccount * SOAP_FMAC2 soap_instantiate__ns7__CheckInRightsForAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__CheckInRightsForAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__CheckInRightsForAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__CheckInRightsForAccount);
		if (size)
			*size = sizeof(_ns7__CheckInRightsForAccount);
		((_ns7__CheckInRightsForAccount*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__CheckInRightsForAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__CheckInRightsForAccount);
		for (int i = 0; i < n; i++)
			((_ns7__CheckInRightsForAccount*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__CheckInRightsForAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__CheckInRightsForAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__CheckInRightsForAccount %p -> %p\n", q, p));
	*(_ns7__CheckInRightsForAccount*)p = *(_ns7__CheckInRightsForAccount*)q;
}

void _ns7__ReassignRoleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__ReassignRoleResponse::return_);
	/* transient soap skipped */
}

void _ns7__ReassignRoleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__ReassignRoleResponse::return_);
	/* transient soap skipped */
}

int _ns7__ReassignRoleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__ReassignRoleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ReassignRoleResponse(struct soap *soap, const char *tag, int id, const _ns7__ReassignRoleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ReassignRoleResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", -1, &(a->_ns7__ReassignRoleResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__ReassignRoleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__ReassignRoleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__ReassignRoleResponse * SOAP_FMAC4 soap_in__ns7__ReassignRoleResponse(struct soap *soap, const char *tag, _ns7__ReassignRoleResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__ReassignRoleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ReassignRoleResponse, sizeof(_ns7__ReassignRoleResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__ReassignRoleResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__ReassignRoleResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", &(a->_ns7__ReassignRoleResponse::return_), "ns6:DocumentRight"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__ReassignRoleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ReassignRoleResponse, 0, sizeof(_ns7__ReassignRoleResponse), 0, soap_copy__ns7__ReassignRoleResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns7__ReassignRoleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__ReassignRoleResponse);
	if (this->soap_out(soap, tag?tag:"ns7:ReassignRoleResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__ReassignRoleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__ReassignRoleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__ReassignRoleResponse * SOAP_FMAC4 soap_get__ns7__ReassignRoleResponse(struct soap *soap, _ns7__ReassignRoleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ReassignRoleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__ReassignRoleResponse * SOAP_FMAC2 soap_instantiate__ns7__ReassignRoleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__ReassignRoleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__ReassignRoleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ReassignRoleResponse);
		if (size)
			*size = sizeof(_ns7__ReassignRoleResponse);
		((_ns7__ReassignRoleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ReassignRoleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__ReassignRoleResponse);
		for (int i = 0; i < n; i++)
			((_ns7__ReassignRoleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__ReassignRoleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__ReassignRoleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__ReassignRoleResponse %p -> %p\n", q, p));
	*(_ns7__ReassignRoleResponse*)p = *(_ns7__ReassignRoleResponse*)q;
}

void _ns7__ReassignRole::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, &this->_ns7__ReassignRole::rights);
	this->_ns7__ReassignRole::role = NULL;
	soap_default_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->_ns7__ReassignRole::items);
	/* transient soap skipped */
}

void _ns7__ReassignRole::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, &this->_ns7__ReassignRole::rights);
	soap_serialize_PointerTons6__DocumentRoleRef(soap, &this->_ns7__ReassignRole::role);
	soap_serialize_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->_ns7__ReassignRole::items);
	/* transient soap skipped */
}

int _ns7__ReassignRole::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__ReassignRole(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ReassignRole(struct soap *soap, const char *tag, int id, const _ns7__ReassignRole *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ReassignRole), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, "rights", -1, &(a->_ns7__ReassignRole::rights), ""))
		return soap->error;
	if (soap_out_PointerTons6__DocumentRoleRef(soap, "role", -1, &(a->_ns7__ReassignRole::role), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ItemCode(soap, "items", -1, &(a->_ns7__ReassignRole::items), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__ReassignRole::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__ReassignRole(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__ReassignRole * SOAP_FMAC4 soap_in__ns7__ReassignRole(struct soap *soap, const char *tag, _ns7__ReassignRole *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__ReassignRole *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ReassignRole, sizeof(_ns7__ReassignRole), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__ReassignRole)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__ReassignRole *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_role1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, "rights", &(a->_ns7__ReassignRole::rights), "ns6:DocumentRightRef"))
					continue;
			if (soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DocumentRoleRef(soap, "role", &(a->_ns7__ReassignRole::role), "ns6:DocumentRoleRef"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__ItemCode(soap, "items", &(a->_ns7__ReassignRole::items), "ns5:ItemCode"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__ReassignRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ReassignRole, 0, sizeof(_ns7__ReassignRole), 0, soap_copy__ns7__ReassignRole);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_role1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns7__ReassignRole::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__ReassignRole);
	if (this->soap_out(soap, tag?tag:"ns7:ReassignRole", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__ReassignRole::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__ReassignRole(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__ReassignRole * SOAP_FMAC4 soap_get__ns7__ReassignRole(struct soap *soap, _ns7__ReassignRole *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ReassignRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__ReassignRole * SOAP_FMAC2 soap_instantiate__ns7__ReassignRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__ReassignRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__ReassignRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ReassignRole);
		if (size)
			*size = sizeof(_ns7__ReassignRole);
		((_ns7__ReassignRole*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__ReassignRole[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__ReassignRole);
		for (int i = 0; i < n; i++)
			((_ns7__ReassignRole*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__ReassignRole*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__ReassignRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__ReassignRole %p -> %p\n", q, p));
	*(_ns7__ReassignRole*)p = *(_ns7__ReassignRole*)q;
}

void _ns7__AssignRoleResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__AssignRoleResponse::return_);
	/* transient soap skipped */
}

void _ns7__AssignRoleResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRight(soap, &this->_ns7__AssignRoleResponse::return_);
	/* transient soap skipped */
}

int _ns7__AssignRoleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__AssignRoleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__AssignRoleResponse(struct soap *soap, const char *tag, int id, const _ns7__AssignRoleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__AssignRoleResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", -1, &(a->_ns7__AssignRoleResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__AssignRoleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__AssignRoleResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__AssignRoleResponse * SOAP_FMAC4 soap_in__ns7__AssignRoleResponse(struct soap *soap, const char *tag, _ns7__AssignRoleResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__AssignRoleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__AssignRoleResponse, sizeof(_ns7__AssignRoleResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__AssignRoleResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__AssignRoleResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRight(soap, "return", &(a->_ns7__AssignRoleResponse::return_), "ns6:DocumentRight"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__AssignRoleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__AssignRoleResponse, 0, sizeof(_ns7__AssignRoleResponse), 0, soap_copy__ns7__AssignRoleResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns7__AssignRoleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__AssignRoleResponse);
	if (this->soap_out(soap, tag?tag:"ns7:AssignRoleResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__AssignRoleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__AssignRoleResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__AssignRoleResponse * SOAP_FMAC4 soap_get__ns7__AssignRoleResponse(struct soap *soap, _ns7__AssignRoleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__AssignRoleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__AssignRoleResponse * SOAP_FMAC2 soap_instantiate__ns7__AssignRoleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__AssignRoleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__AssignRoleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__AssignRoleResponse);
		if (size)
			*size = sizeof(_ns7__AssignRoleResponse);
		((_ns7__AssignRoleResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__AssignRoleResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__AssignRoleResponse);
		for (int i = 0; i < n; i++)
			((_ns7__AssignRoleResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__AssignRoleResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__AssignRoleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__AssignRoleResponse %p -> %p\n", q, p));
	*(_ns7__AssignRoleResponse*)p = *(_ns7__AssignRoleResponse*)q;
}

void _ns7__AssignRole::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns7__AssignRole::context = NULL;
	this->_ns7__AssignRole::role = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__AccountRef(soap, &this->_ns7__AssignRole::accounts);
	soap_default_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->_ns7__AssignRole::items);
	/* transient soap skipped */
}

void _ns7__AssignRole::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__ContextInstanceRef(soap, &this->_ns7__AssignRole::context);
	soap_serialize_PointerTons6__DocumentRoleRef(soap, &this->_ns7__AssignRole::role);
	soap_serialize_std__vectorTemplateOfPointerTons1__AccountRef(soap, &this->_ns7__AssignRole::accounts);
	soap_serialize_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->_ns7__AssignRole::items);
	/* transient soap skipped */
}

int _ns7__AssignRole::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns7__AssignRole(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__AssignRole(struct soap *soap, const char *tag, int id, const _ns7__AssignRole *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__AssignRole), type))
		return soap->error;
	if (soap_out_PointerTons6__ContextInstanceRef(soap, "context", -1, &(a->_ns7__AssignRole::context), ""))
		return soap->error;
	if (soap_out_PointerTons6__DocumentRoleRef(soap, "role", -1, &(a->_ns7__AssignRole::role), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__AccountRef(soap, "accounts", -1, &(a->_ns7__AssignRole::accounts), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ItemCode(soap, "items", -1, &(a->_ns7__AssignRole::items), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns7__AssignRole::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns7__AssignRole(soap, tag, this, type);
}

SOAP_FMAC3 _ns7__AssignRole * SOAP_FMAC4 soap_in__ns7__AssignRole(struct soap *soap, const char *tag, _ns7__AssignRole *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns7__AssignRole *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__AssignRole, sizeof(_ns7__AssignRole), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns7__AssignRole)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns7__AssignRole *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_context1 = 1;
	size_t soap_flag_role1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_context1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ContextInstanceRef(soap, "context", &(a->_ns7__AssignRole::context), "ns6:ContextInstanceRef"))
				{	soap_flag_context1--;
					continue;
				}
			if (soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DocumentRoleRef(soap, "role", &(a->_ns7__AssignRole::role), "ns6:DocumentRoleRef"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__AccountRef(soap, "accounts", &(a->_ns7__AssignRole::accounts), "ns1:AccountRef"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__ItemCode(soap, "items", &(a->_ns7__AssignRole::items), "ns5:ItemCode"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns7__AssignRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__AssignRole, 0, sizeof(_ns7__AssignRole), 0, soap_copy__ns7__AssignRole);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_context1 > 0 || soap_flag_role1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns7__AssignRole::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns7__AssignRole);
	if (this->soap_out(soap, tag?tag:"ns7:AssignRole", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns7__AssignRole::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns7__AssignRole(soap, this, tag, type);
}

SOAP_FMAC3 _ns7__AssignRole * SOAP_FMAC4 soap_get__ns7__AssignRole(struct soap *soap, _ns7__AssignRole *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__AssignRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns7__AssignRole * SOAP_FMAC2 soap_instantiate__ns7__AssignRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns7__AssignRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns7__AssignRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns7__AssignRole);
		if (size)
			*size = sizeof(_ns7__AssignRole);
		((_ns7__AssignRole*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns7__AssignRole[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns7__AssignRole);
		for (int i = 0; i < n; i++)
			((_ns7__AssignRole*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns7__AssignRole*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns7__AssignRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns7__AssignRole %p -> %p\n", q, p));
	*(_ns7__AssignRole*)p = *(_ns7__AssignRole*)q;
}

void ns6__UnknownDocumentRightFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__UnknownDocumentRightFault::uuid);
	/* transient soap skipped */
}

void ns6__UnknownDocumentRightFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__UnknownDocumentRightFault::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__UnknownDocumentRightFault::uuid);
	/* transient soap skipped */
}

int ns6__UnknownDocumentRightFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__UnknownDocumentRightFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__UnknownDocumentRightFault(struct soap *soap, const char *tag, int id, const ns6__UnknownDocumentRightFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__UnknownDocumentRightFault), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__UnknownDocumentRightFault::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__UnknownDocumentRightFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__UnknownDocumentRightFault(soap, tag, this, type);
}

SOAP_FMAC3 ns6__UnknownDocumentRightFault * SOAP_FMAC4 soap_in_ns6__UnknownDocumentRightFault(struct soap *soap, const char *tag, ns6__UnknownDocumentRightFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__UnknownDocumentRightFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__UnknownDocumentRightFault, sizeof(ns6__UnknownDocumentRightFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__UnknownDocumentRightFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__UnknownDocumentRightFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__UnknownDocumentRightFault::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__UnknownDocumentRightFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__UnknownDocumentRightFault, 0, sizeof(ns6__UnknownDocumentRightFault), 0, soap_copy_ns6__UnknownDocumentRightFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__UnknownDocumentRightFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__UnknownDocumentRightFault);
	if (this->soap_out(soap, tag?tag:"ns6:UnknownDocumentRightFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__UnknownDocumentRightFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__UnknownDocumentRightFault(soap, this, tag, type);
}

SOAP_FMAC3 ns6__UnknownDocumentRightFault * SOAP_FMAC4 soap_get_ns6__UnknownDocumentRightFault(struct soap *soap, ns6__UnknownDocumentRightFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__UnknownDocumentRightFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__UnknownDocumentRightFault * SOAP_FMAC2 soap_instantiate_ns6__UnknownDocumentRightFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__UnknownDocumentRightFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__UnknownDocumentRightFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__UnknownDocumentRightFault);
		if (size)
			*size = sizeof(ns6__UnknownDocumentRightFault);
		((ns6__UnknownDocumentRightFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__UnknownDocumentRightFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__UnknownDocumentRightFault);
		for (int i = 0; i < n; i++)
			((ns6__UnknownDocumentRightFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__UnknownDocumentRightFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__UnknownDocumentRightFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__UnknownDocumentRightFault %p -> %p\n", q, p));
	*(ns6__UnknownDocumentRightFault*)p = *(ns6__UnknownDocumentRightFault*)q;
}

void ns6__UnknownDocumentRoleFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__UnknownDocumentRoleFault::uuid);
	this->ns6__UnknownDocumentRoleFault::domain = NULL;
	/* transient soap skipped */
}

void ns6__UnknownDocumentRoleFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__UnknownDocumentRoleFault::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__UnknownDocumentRoleFault::uuid);
	soap_serialize_PointerTons6__DomainRef(soap, &this->ns6__UnknownDocumentRoleFault::domain);
	/* transient soap skipped */
}

int ns6__UnknownDocumentRoleFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__UnknownDocumentRoleFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__UnknownDocumentRoleFault(struct soap *soap, const char *tag, int id, const ns6__UnknownDocumentRoleFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__UnknownDocumentRoleFault), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__UnknownDocumentRoleFault::uuid), ""))
		return soap->error;
	if (soap_out_PointerTons6__DomainRef(soap, "domain", -1, &(a->ns6__UnknownDocumentRoleFault::domain), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__UnknownDocumentRoleFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__UnknownDocumentRoleFault(soap, tag, this, type);
}

SOAP_FMAC3 ns6__UnknownDocumentRoleFault * SOAP_FMAC4 soap_in_ns6__UnknownDocumentRoleFault(struct soap *soap, const char *tag, ns6__UnknownDocumentRoleFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__UnknownDocumentRoleFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__UnknownDocumentRoleFault, sizeof(ns6__UnknownDocumentRoleFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__UnknownDocumentRoleFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__UnknownDocumentRoleFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag_domain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__UnknownDocumentRoleFault::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap_flag_domain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DomainRef(soap, "domain", &(a->ns6__UnknownDocumentRoleFault::domain), "ns6:DomainRef"))
				{	soap_flag_domain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__UnknownDocumentRoleFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__UnknownDocumentRoleFault, 0, sizeof(ns6__UnknownDocumentRoleFault), 0, soap_copy_ns6__UnknownDocumentRoleFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0 || soap_flag_domain1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__UnknownDocumentRoleFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__UnknownDocumentRoleFault);
	if (this->soap_out(soap, tag?tag:"ns6:UnknownDocumentRoleFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__UnknownDocumentRoleFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__UnknownDocumentRoleFault(soap, this, tag, type);
}

SOAP_FMAC3 ns6__UnknownDocumentRoleFault * SOAP_FMAC4 soap_get_ns6__UnknownDocumentRoleFault(struct soap *soap, ns6__UnknownDocumentRoleFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__UnknownDocumentRoleFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__UnknownDocumentRoleFault * SOAP_FMAC2 soap_instantiate_ns6__UnknownDocumentRoleFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__UnknownDocumentRoleFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__UnknownDocumentRoleFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__UnknownDocumentRoleFault);
		if (size)
			*size = sizeof(ns6__UnknownDocumentRoleFault);
		((ns6__UnknownDocumentRoleFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__UnknownDocumentRoleFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__UnknownDocumentRoleFault);
		for (int i = 0; i < n; i++)
			((ns6__UnknownDocumentRoleFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__UnknownDocumentRoleFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__UnknownDocumentRoleFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__UnknownDocumentRoleFault %p -> %p\n", q, p));
	*(ns6__UnknownDocumentRoleFault*)p = *(ns6__UnknownDocumentRoleFault*)q;
}

void ns6__UnsupportedDocumentRoleFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__UnsupportedDocumentRoleFault::role = NULL;
	this->ns6__UnsupportedDocumentRoleFault::context = NULL;
	/* transient soap skipped */
}

void ns6__UnsupportedDocumentRoleFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons6__DocumentRoleRef(soap, &this->ns6__UnsupportedDocumentRoleFault::role);
	soap_serialize_PointerTons6__ContextInstanceRef(soap, &this->ns6__UnsupportedDocumentRoleFault::context);
	/* transient soap skipped */
}

int ns6__UnsupportedDocumentRoleFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__UnsupportedDocumentRoleFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__UnsupportedDocumentRoleFault(struct soap *soap, const char *tag, int id, const ns6__UnsupportedDocumentRoleFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__UnsupportedDocumentRoleFault), type))
		return soap->error;
	if (soap_out_PointerTons6__DocumentRoleRef(soap, "role", -1, &(a->ns6__UnsupportedDocumentRoleFault::role), ""))
		return soap->error;
	if (soap_out_PointerTons6__ContextInstanceRef(soap, "context", -1, &(a->ns6__UnsupportedDocumentRoleFault::context), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__UnsupportedDocumentRoleFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__UnsupportedDocumentRoleFault(soap, tag, this, type);
}

SOAP_FMAC3 ns6__UnsupportedDocumentRoleFault * SOAP_FMAC4 soap_in_ns6__UnsupportedDocumentRoleFault(struct soap *soap, const char *tag, ns6__UnsupportedDocumentRoleFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__UnsupportedDocumentRoleFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__UnsupportedDocumentRoleFault, sizeof(ns6__UnsupportedDocumentRoleFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__UnsupportedDocumentRoleFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__UnsupportedDocumentRoleFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_role1 = 1;
	size_t soap_flag_context1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DocumentRoleRef(soap, "role", &(a->ns6__UnsupportedDocumentRoleFault::role), "ns6:DocumentRoleRef"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap_flag_context1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ContextInstanceRef(soap, "context", &(a->ns6__UnsupportedDocumentRoleFault::context), "ns6:ContextInstanceRef"))
				{	soap_flag_context1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__UnsupportedDocumentRoleFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__UnsupportedDocumentRoleFault, 0, sizeof(ns6__UnsupportedDocumentRoleFault), 0, soap_copy_ns6__UnsupportedDocumentRoleFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_role1 > 0 || soap_flag_context1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__UnsupportedDocumentRoleFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__UnsupportedDocumentRoleFault);
	if (this->soap_out(soap, tag?tag:"ns6:UnsupportedDocumentRoleFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__UnsupportedDocumentRoleFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__UnsupportedDocumentRoleFault(soap, this, tag, type);
}

SOAP_FMAC3 ns6__UnsupportedDocumentRoleFault * SOAP_FMAC4 soap_get_ns6__UnsupportedDocumentRoleFault(struct soap *soap, ns6__UnsupportedDocumentRoleFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__UnsupportedDocumentRoleFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__UnsupportedDocumentRoleFault * SOAP_FMAC2 soap_instantiate_ns6__UnsupportedDocumentRoleFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__UnsupportedDocumentRoleFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__UnsupportedDocumentRoleFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__UnsupportedDocumentRoleFault);
		if (size)
			*size = sizeof(ns6__UnsupportedDocumentRoleFault);
		((ns6__UnsupportedDocumentRoleFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__UnsupportedDocumentRoleFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__UnsupportedDocumentRoleFault);
		for (int i = 0; i < n; i++)
			((ns6__UnsupportedDocumentRoleFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__UnsupportedDocumentRoleFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__UnsupportedDocumentRoleFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__UnsupportedDocumentRoleFault %p -> %p\n", q, p));
	*(ns6__UnsupportedDocumentRoleFault*)p = *(ns6__UnsupportedDocumentRoleFault*)q;
}

void ns6__AccountAlreadyAssignedFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns6__AccountAlreadyAssignedFault::account = NULL;
	this->ns6__AccountAlreadyAssignedFault::role = NULL;
	/* transient soap skipped */
}

void ns6__AccountAlreadyAssignedFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AccountRef(soap, &this->ns6__AccountAlreadyAssignedFault::account);
	soap_serialize_PointerTons6__DocumentRoleRef(soap, &this->ns6__AccountAlreadyAssignedFault::role);
	/* transient soap skipped */
}

int ns6__AccountAlreadyAssignedFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__AccountAlreadyAssignedFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__AccountAlreadyAssignedFault(struct soap *soap, const char *tag, int id, const ns6__AccountAlreadyAssignedFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__AccountAlreadyAssignedFault), type))
		return soap->error;
	if (soap_out_PointerTons1__AccountRef(soap, "account", -1, &(a->ns6__AccountAlreadyAssignedFault::account), ""))
		return soap->error;
	if (soap_out_PointerTons6__DocumentRoleRef(soap, "role", -1, &(a->ns6__AccountAlreadyAssignedFault::role), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__AccountAlreadyAssignedFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__AccountAlreadyAssignedFault(soap, tag, this, type);
}

SOAP_FMAC3 ns6__AccountAlreadyAssignedFault * SOAP_FMAC4 soap_in_ns6__AccountAlreadyAssignedFault(struct soap *soap, const char *tag, ns6__AccountAlreadyAssignedFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__AccountAlreadyAssignedFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__AccountAlreadyAssignedFault, sizeof(ns6__AccountAlreadyAssignedFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__AccountAlreadyAssignedFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__AccountAlreadyAssignedFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_account1 = 1;
	size_t soap_flag_role1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_account1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountRef(soap, "account", &(a->ns6__AccountAlreadyAssignedFault::account), "ns1:AccountRef"))
				{	soap_flag_account1--;
					continue;
				}
			if (soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DocumentRoleRef(soap, "role", &(a->ns6__AccountAlreadyAssignedFault::role), "ns6:DocumentRoleRef"))
				{	soap_flag_role1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__AccountAlreadyAssignedFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__AccountAlreadyAssignedFault, 0, sizeof(ns6__AccountAlreadyAssignedFault), 0, soap_copy_ns6__AccountAlreadyAssignedFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_account1 > 0 || soap_flag_role1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__AccountAlreadyAssignedFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__AccountAlreadyAssignedFault);
	if (this->soap_out(soap, tag?tag:"ns6:AccountAlreadyAssignedFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__AccountAlreadyAssignedFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__AccountAlreadyAssignedFault(soap, this, tag, type);
}

SOAP_FMAC3 ns6__AccountAlreadyAssignedFault * SOAP_FMAC4 soap_get_ns6__AccountAlreadyAssignedFault(struct soap *soap, ns6__AccountAlreadyAssignedFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__AccountAlreadyAssignedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__AccountAlreadyAssignedFault * SOAP_FMAC2 soap_instantiate_ns6__AccountAlreadyAssignedFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__AccountAlreadyAssignedFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__AccountAlreadyAssignedFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__AccountAlreadyAssignedFault);
		if (size)
			*size = sizeof(ns6__AccountAlreadyAssignedFault);
		((ns6__AccountAlreadyAssignedFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__AccountAlreadyAssignedFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__AccountAlreadyAssignedFault);
		for (int i = 0; i < n; i++)
			((ns6__AccountAlreadyAssignedFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__AccountAlreadyAssignedFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__AccountAlreadyAssignedFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__AccountAlreadyAssignedFault %p -> %p\n", q, p));
	*(ns6__AccountAlreadyAssignedFault*)p = *(ns6__AccountAlreadyAssignedFault*)q;
}

void ns6__DocumentRightRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__DocumentRightRef::uuid);
	/* transient soap skipped */
}

void ns6__DocumentRightRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__DocumentRightRef::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__DocumentRightRef::uuid);
	/* transient soap skipped */
}

int ns6__DocumentRightRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__DocumentRightRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__DocumentRightRef(struct soap *soap, const char *tag, int id, const ns6__DocumentRightRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DocumentRightRef), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__DocumentRightRef::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__DocumentRightRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__DocumentRightRef(soap, tag, this, type);
}

SOAP_FMAC3 ns6__DocumentRightRef * SOAP_FMAC4 soap_in_ns6__DocumentRightRef(struct soap *soap, const char *tag, ns6__DocumentRightRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__DocumentRightRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DocumentRightRef, sizeof(ns6__DocumentRightRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__DocumentRightRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__DocumentRightRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__DocumentRightRef::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__DocumentRightRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DocumentRightRef, 0, sizeof(ns6__DocumentRightRef), 0, soap_copy_ns6__DocumentRightRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__DocumentRightRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__DocumentRightRef);
	if (this->soap_out(soap, tag?tag:"ns6:DocumentRightRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__DocumentRightRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__DocumentRightRef(soap, this, tag, type);
}

SOAP_FMAC3 ns6__DocumentRightRef * SOAP_FMAC4 soap_get_ns6__DocumentRightRef(struct soap *soap, ns6__DocumentRightRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__DocumentRightRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__DocumentRightRef * SOAP_FMAC2 soap_instantiate_ns6__DocumentRightRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__DocumentRightRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__DocumentRightRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__DocumentRightRef);
		if (size)
			*size = sizeof(ns6__DocumentRightRef);
		((ns6__DocumentRightRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__DocumentRightRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__DocumentRightRef);
		for (int i = 0; i < n; i++)
			((ns6__DocumentRightRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__DocumentRightRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__DocumentRightRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__DocumentRightRef %p -> %p\n", q, p));
	*(ns6__DocumentRightRef*)p = *(ns6__DocumentRightRef*)q;
}

void ns6__DocumentRight::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__DocumentRight::uuid);
	this->ns6__DocumentRight::account = NULL;
	this->ns6__DocumentRight::role = NULL;
	soap_default_time(soap, &this->ns6__DocumentRight::assignedTime);
	soap_default_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->ns6__DocumentRight::itemCodes);
	this->ns6__DocumentRight::context = NULL;
	/* transient soap skipped */
}

void ns6__DocumentRight::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__DocumentRight::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__DocumentRight::uuid);
	soap_serialize_PointerTons1__AccountRef(soap, &this->ns6__DocumentRight::account);
	soap_serialize_PointerTons6__DocumentRole(soap, &this->ns6__DocumentRight::role);
	soap_embedded(soap, &this->ns6__DocumentRight::assignedTime, SOAP_TYPE_time);
	soap_serialize_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->ns6__DocumentRight::itemCodes);
	soap_serialize_PointerTons6__ContextInstanceRef(soap, &this->ns6__DocumentRight::context);
	/* transient soap skipped */
}

int ns6__DocumentRight::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__DocumentRight(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__DocumentRight(struct soap *soap, const char *tag, int id, const ns6__DocumentRight *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DocumentRight), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__DocumentRight::uuid), ""))
		return soap->error;
	if (soap_out_PointerTons1__AccountRef(soap, "account", -1, &(a->ns6__DocumentRight::account), ""))
		return soap->error;
	if (soap_out_PointerTons6__DocumentRole(soap, "role", -1, &(a->ns6__DocumentRight::role), ""))
		return soap->error;
	if (soap_out_time(soap, "assignedTime", -1, &(a->ns6__DocumentRight::assignedTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ItemCode(soap, "itemCodes", -1, &(a->ns6__DocumentRight::itemCodes), ""))
		return soap->error;
	if (soap_out_PointerTons6__ContextInstanceRef(soap, "context", -1, &(a->ns6__DocumentRight::context), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__DocumentRight::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__DocumentRight(soap, tag, this, type);
}

SOAP_FMAC3 ns6__DocumentRight * SOAP_FMAC4 soap_in_ns6__DocumentRight(struct soap *soap, const char *tag, ns6__DocumentRight *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__DocumentRight *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DocumentRight, sizeof(ns6__DocumentRight), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__DocumentRight)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__DocumentRight *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag_account1 = 1;
	size_t soap_flag_role1 = 1;
	size_t soap_flag_assignedTime1 = 1;
	size_t soap_flag_context1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__DocumentRight::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap_flag_account1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AccountRef(soap, "account", &(a->ns6__DocumentRight::account), "ns1:AccountRef"))
				{	soap_flag_account1--;
					continue;
				}
			if (soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DocumentRole(soap, "role", &(a->ns6__DocumentRight::role), "ns6:DocumentRole"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap_flag_assignedTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "assignedTime", &(a->ns6__DocumentRight::assignedTime), "xsd:dateTime"))
				{	soap_flag_assignedTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__ItemCode(soap, "itemCodes", &(a->ns6__DocumentRight::itemCodes), "ns5:ItemCode"))
					continue;
			if (soap_flag_context1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ContextInstanceRef(soap, "context", &(a->ns6__DocumentRight::context), "ns6:ContextInstanceRef"))
				{	soap_flag_context1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__DocumentRight *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DocumentRight, 0, sizeof(ns6__DocumentRight), 0, soap_copy_ns6__DocumentRight);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0 || soap_flag_account1 > 0 || soap_flag_role1 > 0 || soap_flag_assignedTime1 > 0 || soap_flag_context1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__DocumentRight::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__DocumentRight);
	if (this->soap_out(soap, tag?tag:"ns6:DocumentRight", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__DocumentRight::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__DocumentRight(soap, this, tag, type);
}

SOAP_FMAC3 ns6__DocumentRight * SOAP_FMAC4 soap_get_ns6__DocumentRight(struct soap *soap, ns6__DocumentRight *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__DocumentRight(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__DocumentRight * SOAP_FMAC2 soap_instantiate_ns6__DocumentRight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__DocumentRight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__DocumentRight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__DocumentRight);
		if (size)
			*size = sizeof(ns6__DocumentRight);
		((ns6__DocumentRight*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__DocumentRight[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__DocumentRight);
		for (int i = 0; i < n; i++)
			((ns6__DocumentRight*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__DocumentRight*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__DocumentRight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__DocumentRight %p -> %p\n", q, p));
	*(ns6__DocumentRight*)p = *(ns6__DocumentRight*)q;
}

void ns6__DomainRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__DomainRef::uuid);
	/* transient soap skipped */
}

void ns6__DomainRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__DomainRef::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__DomainRef::uuid);
	/* transient soap skipped */
}

int ns6__DomainRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__DomainRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__DomainRef(struct soap *soap, const char *tag, int id, const ns6__DomainRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DomainRef), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__DomainRef::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__DomainRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__DomainRef(soap, tag, this, type);
}

SOAP_FMAC3 ns6__DomainRef * SOAP_FMAC4 soap_in_ns6__DomainRef(struct soap *soap, const char *tag, ns6__DomainRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__DomainRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DomainRef, sizeof(ns6__DomainRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__DomainRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__DomainRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__DomainRef::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__DomainRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DomainRef, 0, sizeof(ns6__DomainRef), 0, soap_copy_ns6__DomainRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__DomainRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__DomainRef);
	if (this->soap_out(soap, tag?tag:"ns6:DomainRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__DomainRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__DomainRef(soap, this, tag, type);
}

SOAP_FMAC3 ns6__DomainRef * SOAP_FMAC4 soap_get_ns6__DomainRef(struct soap *soap, ns6__DomainRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__DomainRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__DomainRef * SOAP_FMAC2 soap_instantiate_ns6__DomainRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__DomainRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__DomainRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__DomainRef);
		if (size)
			*size = sizeof(ns6__DomainRef);
		((ns6__DomainRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__DomainRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__DomainRef);
		for (int i = 0; i < n; i++)
			((ns6__DomainRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__DomainRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__DomainRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__DomainRef %p -> %p\n", q, p));
	*(ns6__DomainRef*)p = *(ns6__DomainRef*)q;
}

void ns6__Domain::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__Domain::uuid);
	soap_default_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns6__Domain::labels);
	/* transient soap skipped */
}

void ns6__Domain::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__Domain::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__Domain::uuid);
	soap_serialize_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns6__Domain::labels);
	/* transient soap skipped */
}

int ns6__Domain::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__Domain(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Domain(struct soap *soap, const char *tag, int id, const ns6__Domain *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Domain), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__Domain::uuid), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Label(soap, "labels", -1, &(a->ns6__Domain::labels), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__Domain::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__Domain(soap, tag, this, type);
}

SOAP_FMAC3 ns6__Domain * SOAP_FMAC4 soap_in_ns6__Domain(struct soap *soap, const char *tag, ns6__Domain *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__Domain *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Domain, sizeof(ns6__Domain), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__Domain)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__Domain *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__Domain::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Label(soap, "labels", &(a->ns6__Domain::labels), "ns1:Label"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__Domain *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Domain, 0, sizeof(ns6__Domain), 0, soap_copy_ns6__Domain);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__Domain::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__Domain);
	if (this->soap_out(soap, tag?tag:"ns6:Domain", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__Domain::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__Domain(soap, this, tag, type);
}

SOAP_FMAC3 ns6__Domain * SOAP_FMAC4 soap_get_ns6__Domain(struct soap *soap, ns6__Domain *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Domain(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__Domain * SOAP_FMAC2 soap_instantiate_ns6__Domain(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__Domain(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__Domain, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__Domain);
		if (size)
			*size = sizeof(ns6__Domain);
		((ns6__Domain*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__Domain[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__Domain);
		for (int i = 0; i < n; i++)
			((ns6__Domain*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__Domain*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__Domain(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__Domain %p -> %p\n", q, p));
	*(ns6__Domain*)p = *(ns6__Domain*)q;
}

void ns6__DocumentRoleRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__DocumentRoleRef::uuid);
	this->ns6__DocumentRoleRef::domain = NULL;
	/* transient soap skipped */
}

void ns6__DocumentRoleRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__DocumentRoleRef::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__DocumentRoleRef::uuid);
	soap_serialize_PointerTons6__DomainRef(soap, &this->ns6__DocumentRoleRef::domain);
	/* transient soap skipped */
}

int ns6__DocumentRoleRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__DocumentRoleRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__DocumentRoleRef(struct soap *soap, const char *tag, int id, const ns6__DocumentRoleRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DocumentRoleRef), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__DocumentRoleRef::uuid), ""))
		return soap->error;
	if (soap_out_PointerTons6__DomainRef(soap, "domain", -1, &(a->ns6__DocumentRoleRef::domain), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__DocumentRoleRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__DocumentRoleRef(soap, tag, this, type);
}

SOAP_FMAC3 ns6__DocumentRoleRef * SOAP_FMAC4 soap_in_ns6__DocumentRoleRef(struct soap *soap, const char *tag, ns6__DocumentRoleRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__DocumentRoleRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DocumentRoleRef, sizeof(ns6__DocumentRoleRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__DocumentRoleRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__DocumentRoleRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag_domain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__DocumentRoleRef::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap_flag_domain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DomainRef(soap, "domain", &(a->ns6__DocumentRoleRef::domain), "ns6:DomainRef"))
				{	soap_flag_domain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__DocumentRoleRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DocumentRoleRef, 0, sizeof(ns6__DocumentRoleRef), 0, soap_copy_ns6__DocumentRoleRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0 || soap_flag_domain1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__DocumentRoleRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__DocumentRoleRef);
	if (this->soap_out(soap, tag?tag:"ns6:DocumentRoleRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__DocumentRoleRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__DocumentRoleRef(soap, this, tag, type);
}

SOAP_FMAC3 ns6__DocumentRoleRef * SOAP_FMAC4 soap_get_ns6__DocumentRoleRef(struct soap *soap, ns6__DocumentRoleRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__DocumentRoleRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__DocumentRoleRef * SOAP_FMAC2 soap_instantiate_ns6__DocumentRoleRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__DocumentRoleRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__DocumentRoleRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__DocumentRoleRef);
		if (size)
			*size = sizeof(ns6__DocumentRoleRef);
		((ns6__DocumentRoleRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__DocumentRoleRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__DocumentRoleRef);
		for (int i = 0; i < n; i++)
			((ns6__DocumentRoleRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__DocumentRoleRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__DocumentRoleRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__DocumentRoleRef %p -> %p\n", q, p));
	*(ns6__DocumentRoleRef*)p = *(ns6__DocumentRoleRef*)q;
}

void ns6__DocumentRole::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__DocumentRole::uuid);
	soap_default_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns6__DocumentRole::labels);
	soap_default_ns1__LicenseCriteria_USCOREStorage(soap, &this->ns6__DocumentRole::storage);
	soap_default_std__vectorTemplateOfPointerTons1__Feature(soap, &this->ns6__DocumentRole::features);
	soap_default_std__vectorTemplateOfPointerTons1__TimeSpan(soap, &this->ns6__DocumentRole::timeSpans);
	this->ns6__DocumentRole::refreshPeriod = NULL;
	soap_default_ns5__ItemConstraints_USCOREType(soap, &this->ns6__DocumentRole::itemConstraints);
	soap_default_ns6__DocumentRole_USCOREExportConstraints(soap, &this->ns6__DocumentRole::exportConstraints);
	this->ns6__DocumentRole::domain = NULL;
	/* transient soap skipped */
}

void ns6__DocumentRole::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__DocumentRole::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__DocumentRole::uuid);
	soap_serialize_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns6__DocumentRole::labels);
	soap_serialize_std__vectorTemplateOfPointerTons1__Feature(soap, &this->ns6__DocumentRole::features);
	soap_serialize_std__vectorTemplateOfPointerTons1__TimeSpan(soap, &this->ns6__DocumentRole::timeSpans);
	soap_serialize_PointerTons1__TimePeriod(soap, &this->ns6__DocumentRole::refreshPeriod);
	soap_serialize_PointerTons6__DomainRef(soap, &this->ns6__DocumentRole::domain);
	/* transient soap skipped */
}

int ns6__DocumentRole::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__DocumentRole(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__DocumentRole(struct soap *soap, const char *tag, int id, const ns6__DocumentRole *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__DocumentRole), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__DocumentRole::uuid), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Label(soap, "labels", -1, &(a->ns6__DocumentRole::labels), ""))
		return soap->error;
	if (soap_out_ns1__LicenseCriteria_USCOREStorage(soap, "storage", -1, &(a->ns6__DocumentRole::storage), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Feature(soap, "features", -1, &(a->ns6__DocumentRole::features), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TimeSpan(soap, "timeSpans", -1, &(a->ns6__DocumentRole::timeSpans), ""))
		return soap->error;
	if (soap_out_PointerTons1__TimePeriod(soap, "refreshPeriod", -1, &(a->ns6__DocumentRole::refreshPeriod), ""))
		return soap->error;
	if (soap_out_ns5__ItemConstraints_USCOREType(soap, "itemConstraints", -1, &(a->ns6__DocumentRole::itemConstraints), ""))
		return soap->error;
	if (soap_out_ns6__DocumentRole_USCOREExportConstraints(soap, "exportConstraints", -1, &(a->ns6__DocumentRole::exportConstraints), ""))
		return soap->error;
	if (soap_out_PointerTons6__DomainRef(soap, "domain", -1, &(a->ns6__DocumentRole::domain), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__DocumentRole::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__DocumentRole(soap, tag, this, type);
}

SOAP_FMAC3 ns6__DocumentRole * SOAP_FMAC4 soap_in_ns6__DocumentRole(struct soap *soap, const char *tag, ns6__DocumentRole *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__DocumentRole *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__DocumentRole, sizeof(ns6__DocumentRole), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__DocumentRole)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__DocumentRole *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag_storage1 = 1;
	size_t soap_flag_refreshPeriod1 = 1;
	size_t soap_flag_itemConstraints1 = 1;
	size_t soap_flag_exportConstraints1 = 1;
	size_t soap_flag_domain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__DocumentRole::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Label(soap, "labels", &(a->ns6__DocumentRole::labels), "ns1:Label"))
					continue;
			if (soap_flag_storage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__LicenseCriteria_USCOREStorage(soap, "storage", &(a->ns6__DocumentRole::storage), "ns1:LicenseCriteria_Storage"))
				{	soap_flag_storage1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Feature(soap, "features", &(a->ns6__DocumentRole::features), "ns1:Feature"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__TimeSpan(soap, "timeSpans", &(a->ns6__DocumentRole::timeSpans), "ns1:TimeSpan"))
					continue;
			if (soap_flag_refreshPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TimePeriod(soap, "refreshPeriod", &(a->ns6__DocumentRole::refreshPeriod), "ns1:TimePeriod"))
				{	soap_flag_refreshPeriod1--;
					continue;
				}
			if (soap_flag_itemConstraints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns5__ItemConstraints_USCOREType(soap, "itemConstraints", &(a->ns6__DocumentRole::itemConstraints), "ns5:ItemConstraints_Type"))
				{	soap_flag_itemConstraints1--;
					continue;
				}
			if (soap_flag_exportConstraints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__DocumentRole_USCOREExportConstraints(soap, "exportConstraints", &(a->ns6__DocumentRole::exportConstraints), "ns6:DocumentRole_ExportConstraints"))
				{	soap_flag_exportConstraints1--;
					continue;
				}
			if (soap_flag_domain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DomainRef(soap, "domain", &(a->ns6__DocumentRole::domain), "ns6:DomainRef"))
				{	soap_flag_domain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__DocumentRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__DocumentRole, 0, sizeof(ns6__DocumentRole), 0, soap_copy_ns6__DocumentRole);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0 || soap_flag_storage1 > 0 || soap_flag_itemConstraints1 > 0 || soap_flag_exportConstraints1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__DocumentRole::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__DocumentRole);
	if (this->soap_out(soap, tag?tag:"ns6:DocumentRole", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__DocumentRole::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__DocumentRole(soap, this, tag, type);
}

SOAP_FMAC3 ns6__DocumentRole * SOAP_FMAC4 soap_get_ns6__DocumentRole(struct soap *soap, ns6__DocumentRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__DocumentRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__DocumentRole * SOAP_FMAC2 soap_instantiate_ns6__DocumentRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__DocumentRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__DocumentRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__DocumentRole);
		if (size)
			*size = sizeof(ns6__DocumentRole);
		((ns6__DocumentRole*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__DocumentRole[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__DocumentRole);
		for (int i = 0; i < n; i++)
			((ns6__DocumentRole*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__DocumentRole*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__DocumentRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__DocumentRole %p -> %p\n", q, p));
	*(ns6__DocumentRole*)p = *(ns6__DocumentRole*)q;
}

void ns6__ContextTemplateRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__ContextTemplateRef::uuid);
	this->ns6__ContextTemplateRef::domain = NULL;
	/* transient soap skipped */
}

void ns6__ContextTemplateRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__ContextTemplateRef::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__ContextTemplateRef::uuid);
	soap_serialize_PointerTons6__DomainRef(soap, &this->ns6__ContextTemplateRef::domain);
	/* transient soap skipped */
}

int ns6__ContextTemplateRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ContextTemplateRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ContextTemplateRef(struct soap *soap, const char *tag, int id, const ns6__ContextTemplateRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ContextTemplateRef), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__ContextTemplateRef::uuid), ""))
		return soap->error;
	if (soap_out_PointerTons6__DomainRef(soap, "domain", -1, &(a->ns6__ContextTemplateRef::domain), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__ContextTemplateRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ContextTemplateRef(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ContextTemplateRef * SOAP_FMAC4 soap_in_ns6__ContextTemplateRef(struct soap *soap, const char *tag, ns6__ContextTemplateRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ContextTemplateRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ContextTemplateRef, sizeof(ns6__ContextTemplateRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ContextTemplateRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ContextTemplateRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag_domain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__ContextTemplateRef::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap_flag_domain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DomainRef(soap, "domain", &(a->ns6__ContextTemplateRef::domain), "ns6:DomainRef"))
				{	soap_flag_domain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ContextTemplateRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ContextTemplateRef, 0, sizeof(ns6__ContextTemplateRef), 0, soap_copy_ns6__ContextTemplateRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0 || soap_flag_domain1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__ContextTemplateRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ContextTemplateRef);
	if (this->soap_out(soap, tag?tag:"ns6:ContextTemplateRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ContextTemplateRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ContextTemplateRef(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ContextTemplateRef * SOAP_FMAC4 soap_get_ns6__ContextTemplateRef(struct soap *soap, ns6__ContextTemplateRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ContextTemplateRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ContextTemplateRef * SOAP_FMAC2 soap_instantiate_ns6__ContextTemplateRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ContextTemplateRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ContextTemplateRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__ContextTemplateRef);
		if (size)
			*size = sizeof(ns6__ContextTemplateRef);
		((ns6__ContextTemplateRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__ContextTemplateRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ContextTemplateRef);
		for (int i = 0; i < n; i++)
			((ns6__ContextTemplateRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ContextTemplateRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ContextTemplateRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ContextTemplateRef %p -> %p\n", q, p));
	*(ns6__ContextTemplateRef*)p = *(ns6__ContextTemplateRef*)q;
}

void ns6__ContextTemplate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns6__ContextTemplate::uuid);
	soap_default_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns6__ContextTemplate::labels);
	soap_default_ns6__ContextTemplate_USCOREStatus(soap, &this->ns6__ContextTemplate::status);
	soap_default_std__vectorTemplateOfPointerTons6__DocumentRoleRef(soap, &this->ns6__ContextTemplate::roles);
	this->ns6__ContextTemplate::domain = NULL;
	/* transient soap skipped */
}

void ns6__ContextTemplate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns6__ContextTemplate::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns6__ContextTemplate::uuid);
	soap_serialize_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns6__ContextTemplate::labels);
	soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRoleRef(soap, &this->ns6__ContextTemplate::roles);
	soap_serialize_PointerTons6__DomainRef(soap, &this->ns6__ContextTemplate::domain);
	/* transient soap skipped */
}

int ns6__ContextTemplate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ContextTemplate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ContextTemplate(struct soap *soap, const char *tag, int id, const ns6__ContextTemplate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ContextTemplate), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns6__ContextTemplate::uuid), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Label(soap, "labels", -1, &(a->ns6__ContextTemplate::labels), ""))
		return soap->error;
	if (soap_out_ns6__ContextTemplate_USCOREStatus(soap, "status", -1, &(a->ns6__ContextTemplate::status), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__DocumentRoleRef(soap, "roles", -1, &(a->ns6__ContextTemplate::roles), ""))
		return soap->error;
	if (soap_out_PointerTons6__DomainRef(soap, "domain", -1, &(a->ns6__ContextTemplate::domain), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__ContextTemplate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ContextTemplate(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ContextTemplate * SOAP_FMAC4 soap_in_ns6__ContextTemplate(struct soap *soap, const char *tag, ns6__ContextTemplate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ContextTemplate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ContextTemplate, sizeof(ns6__ContextTemplate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ContextTemplate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ContextTemplate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_domain1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns6__ContextTemplate::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Label(soap, "labels", &(a->ns6__ContextTemplate::labels), "ns1:Label"))
					continue;
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__ContextTemplate_USCOREStatus(soap, "status", &(a->ns6__ContextTemplate::status), "ns6:ContextTemplate_Status"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__DocumentRoleRef(soap, "roles", &(a->ns6__ContextTemplate::roles), "ns6:DocumentRoleRef"))
					continue;
			if (soap_flag_domain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__DomainRef(soap, "domain", &(a->ns6__ContextTemplate::domain), "ns6:DomainRef"))
				{	soap_flag_domain1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ContextTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ContextTemplate, 0, sizeof(ns6__ContextTemplate), 0, soap_copy_ns6__ContextTemplate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__ContextTemplate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ContextTemplate);
	if (this->soap_out(soap, tag?tag:"ns6:ContextTemplate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ContextTemplate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ContextTemplate(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ContextTemplate * SOAP_FMAC4 soap_get_ns6__ContextTemplate(struct soap *soap, ns6__ContextTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ContextTemplate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ContextTemplate * SOAP_FMAC2 soap_instantiate_ns6__ContextTemplate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ContextTemplate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ContextTemplate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__ContextTemplate);
		if (size)
			*size = sizeof(ns6__ContextTemplate);
		((ns6__ContextTemplate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__ContextTemplate[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ContextTemplate);
		for (int i = 0; i < n; i++)
			((ns6__ContextTemplate*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ContextTemplate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ContextTemplate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ContextTemplate %p -> %p\n", q, p));
	*(ns6__ContextTemplate*)p = *(ns6__ContextTemplate*)q;
}

void ns6__ContextInstanceRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__ContextRef::uuid);
	/* transient soap skipped */
}

void ns6__ContextInstanceRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns5__ContextRef::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__ContextRef::uuid);
	/* transient soap skipped */
}

int ns6__ContextInstanceRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ContextInstanceRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ContextInstanceRef(struct soap *soap, const char *tag, int id, const ns6__ContextInstanceRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ContextInstanceRef), "ns6:ContextInstanceRef"))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns5__ContextRef::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns6__ContextInstanceRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ContextInstanceRef(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ContextInstanceRef * SOAP_FMAC4 soap_in_ns6__ContextInstanceRef(struct soap *soap, const char *tag, ns6__ContextInstanceRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ContextInstanceRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ContextInstanceRef, sizeof(ns6__ContextInstanceRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ContextInstanceRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ContextInstanceRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns5__ContextRef::uuid), "xsd:string"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ContextInstanceRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ContextInstanceRef, 0, sizeof(ns6__ContextInstanceRef), 0, soap_copy_ns6__ContextInstanceRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__ContextInstanceRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ContextInstanceRef);
	if (this->soap_out(soap, tag?tag:"ns6:ContextInstanceRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ContextInstanceRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ContextInstanceRef(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ContextInstanceRef * SOAP_FMAC4 soap_get_ns6__ContextInstanceRef(struct soap *soap, ns6__ContextInstanceRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ContextInstanceRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ContextInstanceRef * SOAP_FMAC2 soap_instantiate_ns6__ContextInstanceRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ContextInstanceRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ContextInstanceRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__ContextInstanceRef);
		if (size)
			*size = sizeof(ns6__ContextInstanceRef);
		((ns6__ContextInstanceRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__ContextInstanceRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ContextInstanceRef);
		for (int i = 0; i < n; i++)
			((ns6__ContextInstanceRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ContextInstanceRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ContextInstanceRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ContextInstanceRef %p -> %p\n", q, p));
	*(ns6__ContextInstanceRef*)p = *(ns6__ContextInstanceRef*)q;
}

void ns6__ContextInstance::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns6__ContextInstance::labels);
	soap_default_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->ns6__ContextInstance::items);
	soap_default_std__vectorTemplateOfPointerTons6__ContextInstanceRef(soap, &this->ns6__ContextInstance::trustedContexts);
	soap_default_ns6__ContextInstance_USCOREVisibility(soap, &this->ns6__ContextInstance::visibility);
	this->ns6__ContextInstance::template_ = NULL;
	soap_default_std__string(soap, &this->ns5__Context::uuid);
	/* transient soap skipped */
}

void ns6__ContextInstance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns6__ContextInstance::labels);
	soap_serialize_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->ns6__ContextInstance::items);
	soap_serialize_std__vectorTemplateOfPointerTons6__ContextInstanceRef(soap, &this->ns6__ContextInstance::trustedContexts);
	soap_serialize_PointerTons6__ContextTemplateRef(soap, &this->ns6__ContextInstance::template_);
	soap_embedded(soap, &this->ns5__Context::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__Context::uuid);
	/* transient soap skipped */
}

int ns6__ContextInstance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns6__ContextInstance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ContextInstance(struct soap *soap, const char *tag, int id, const ns6__ContextInstance *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ContextInstance), "ns6:ContextInstance"))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns5__Context::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__vectorTemplateOfPointerTons1__Label(soap, "labels", -1, &(a->ns6__ContextInstance::labels), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ItemCode(soap, "items", -1, &(a->ns6__ContextInstance::items), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons6__ContextInstanceRef(soap, "trustedContexts", -1, &(a->ns6__ContextInstance::trustedContexts), ""))
		return soap->error;
	if (soap_out_ns6__ContextInstance_USCOREVisibility(soap, "visibility", -1, &(a->ns6__ContextInstance::visibility), ""))
		return soap->error;
	if (soap_out_PointerTons6__ContextTemplateRef(soap, "template", -1, &(a->ns6__ContextInstance::template_), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns6__ContextInstance::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns6__ContextInstance(soap, tag, this, type);
}

SOAP_FMAC3 ns6__ContextInstance * SOAP_FMAC4 soap_in_ns6__ContextInstance(struct soap *soap, const char *tag, ns6__ContextInstance *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns6__ContextInstance *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ContextInstance, sizeof(ns6__ContextInstance), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns6__ContextInstance)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns6__ContextInstance *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid2 = 1;
	size_t soap_flag_visibility1 = 1;
	size_t soap_flag_template_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns5__Context::uuid), "xsd:string"))
				{	soap_flag_uuid2--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Label(soap, "labels", &(a->ns6__ContextInstance::labels), "ns1:Label"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__ItemCode(soap, "items", &(a->ns6__ContextInstance::items), "ns5:ItemCode"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons6__ContextInstanceRef(soap, "trustedContexts", &(a->ns6__ContextInstance::trustedContexts), "ns6:ContextInstanceRef"))
					continue;
			if (soap_flag_visibility1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns6__ContextInstance_USCOREVisibility(soap, "visibility", &(a->ns6__ContextInstance::visibility), "ns6:ContextInstance_Visibility"))
				{	soap_flag_visibility1--;
					continue;
				}
			if (soap_flag_template_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ContextTemplateRef(soap, "template", &(a->ns6__ContextInstance::template_), "ns6:ContextTemplateRef"))
				{	soap_flag_template_1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns6__ContextInstance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ContextInstance, 0, sizeof(ns6__ContextInstance), 0, soap_copy_ns6__ContextInstance);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid2 > 0 || soap_flag_visibility1 > 0 || soap_flag_template_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns6__ContextInstance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns6__ContextInstance);
	if (this->soap_out(soap, tag?tag:"ns6:ContextInstance", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns6__ContextInstance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns6__ContextInstance(soap, this, tag, type);
}

SOAP_FMAC3 ns6__ContextInstance * SOAP_FMAC4 soap_get_ns6__ContextInstance(struct soap *soap, ns6__ContextInstance *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ContextInstance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns6__ContextInstance * SOAP_FMAC2 soap_instantiate_ns6__ContextInstance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__ContextInstance(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__ContextInstance, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns6__ContextInstance);
		if (size)
			*size = sizeof(ns6__ContextInstance);
		((ns6__ContextInstance*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns6__ContextInstance[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns6__ContextInstance);
		for (int i = 0; i < n; i++)
			((ns6__ContextInstance*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns6__ContextInstance*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__ContextInstance(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns6__ContextInstance %p -> %p\n", q, p));
	*(ns6__ContextInstance*)p = *(ns6__ContextInstance*)q;
}

void ns5__UnknownContextFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__UnknownContextFault::uuid);
	/* transient soap skipped */
}

void ns5__UnknownContextFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns5__UnknownContextFault::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__UnknownContextFault::uuid);
	/* transient soap skipped */
}

int ns5__UnknownContextFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__UnknownContextFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__UnknownContextFault(struct soap *soap, const char *tag, int id, const ns5__UnknownContextFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__UnknownContextFault), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns5__UnknownContextFault::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__UnknownContextFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__UnknownContextFault(soap, tag, this, type);
}

SOAP_FMAC3 ns5__UnknownContextFault * SOAP_FMAC4 soap_in_ns5__UnknownContextFault(struct soap *soap, const char *tag, ns5__UnknownContextFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__UnknownContextFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__UnknownContextFault, sizeof(ns5__UnknownContextFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__UnknownContextFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__UnknownContextFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns5__UnknownContextFault::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__UnknownContextFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__UnknownContextFault, 0, sizeof(ns5__UnknownContextFault), 0, soap_copy_ns5__UnknownContextFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__UnknownContextFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__UnknownContextFault);
	if (this->soap_out(soap, tag?tag:"ns5:UnknownContextFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__UnknownContextFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__UnknownContextFault(soap, this, tag, type);
}

SOAP_FMAC3 ns5__UnknownContextFault * SOAP_FMAC4 soap_get_ns5__UnknownContextFault(struct soap *soap, ns5__UnknownContextFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__UnknownContextFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__UnknownContextFault * SOAP_FMAC2 soap_instantiate_ns5__UnknownContextFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__UnknownContextFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__UnknownContextFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__UnknownContextFault);
		if (size)
			*size = sizeof(ns5__UnknownContextFault);
		((ns5__UnknownContextFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns5__UnknownContextFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__UnknownContextFault);
		for (int i = 0; i < n; i++)
			((ns5__UnknownContextFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__UnknownContextFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__UnknownContextFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__UnknownContextFault %p -> %p\n", q, p));
	*(ns5__UnknownContextFault*)p = *(ns5__UnknownContextFault*)q;
}

void ns5__ItemConstraints::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->ns5__ItemConstraints::itemCodes);
	soap_default_ns5__ItemConstraints_USCOREType(soap, &this->ns5__ItemConstraints::type);
	/* transient soap skipped */
}

void ns5__ItemConstraints::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons5__ItemCode(soap, &this->ns5__ItemConstraints::itemCodes);
	/* transient soap skipped */
}

int ns5__ItemConstraints::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ItemConstraints(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ItemConstraints(struct soap *soap, const char *tag, int id, const ns5__ItemConstraints *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ItemConstraints), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons5__ItemCode(soap, "itemCodes", -1, &(a->ns5__ItemConstraints::itemCodes), ""))
		return soap->error;
	if (soap_out_ns5__ItemConstraints_USCOREType(soap, "type", -1, &(a->ns5__ItemConstraints::type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__ItemConstraints::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ItemConstraints(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ItemConstraints * SOAP_FMAC4 soap_in_ns5__ItemConstraints(struct soap *soap, const char *tag, ns5__ItemConstraints *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ItemConstraints *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ItemConstraints, sizeof(ns5__ItemConstraints), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__ItemConstraints)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ItemConstraints *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons5__ItemCode(soap, "itemCodes", &(a->ns5__ItemConstraints::itemCodes), "ns5:ItemCode"))
					continue;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns5__ItemConstraints_USCOREType(soap, "type", &(a->ns5__ItemConstraints::type), "ns5:ItemConstraints_Type"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ItemConstraints *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ItemConstraints, 0, sizeof(ns5__ItemConstraints), 0, soap_copy_ns5__ItemConstraints);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ItemConstraints::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ItemConstraints);
	if (this->soap_out(soap, tag?tag:"ns5:ItemConstraints", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ItemConstraints::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ItemConstraints(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ItemConstraints * SOAP_FMAC4 soap_get_ns5__ItemConstraints(struct soap *soap, ns5__ItemConstraints *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ItemConstraints(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ItemConstraints * SOAP_FMAC2 soap_instantiate_ns5__ItemConstraints(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ItemConstraints(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ItemConstraints, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ItemConstraints);
		if (size)
			*size = sizeof(ns5__ItemConstraints);
		((ns5__ItemConstraints*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns5__ItemConstraints[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__ItemConstraints);
		for (int i = 0; i < n; i++)
			((ns5__ItemConstraints*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ItemConstraints*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ItemConstraints(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ItemConstraints %p -> %p\n", q, p));
	*(ns5__ItemConstraints*)p = *(ns5__ItemConstraints*)q;
}

void ns5__ContextRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__ContextRef::uuid);
	/* transient soap skipped */
}

void ns5__ContextRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns5__ContextRef::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__ContextRef::uuid);
	/* transient soap skipped */
}

int ns5__ContextRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ContextRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ContextRef(struct soap *soap, const char *tag, int id, const ns5__ContextRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ContextRef), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns5__ContextRef::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__ContextRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ContextRef(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ContextRef * SOAP_FMAC4 soap_in_ns5__ContextRef(struct soap *soap, const char *tag, ns5__ContextRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ContextRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ContextRef, sizeof(ns5__ContextRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__ContextRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ContextRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns5__ContextRef::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ContextRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ContextRef, 0, sizeof(ns5__ContextRef), 0, soap_copy_ns5__ContextRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ContextRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ContextRef);
	if (this->soap_out(soap, tag?tag:"ns5:ContextRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ContextRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ContextRef(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ContextRef * SOAP_FMAC4 soap_get_ns5__ContextRef(struct soap *soap, ns5__ContextRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ContextRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ContextRef * SOAP_FMAC2 soap_instantiate_ns5__ContextRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ContextRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ContextRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns6:ContextInstanceRef"))
	{	cp->type = SOAP_TYPE_ns6__ContextInstanceRef;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns6__ContextInstanceRef);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ContextInstanceRef);
			((ns6__ContextInstanceRef*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns6__ContextInstanceRef[n]);
			if (size)
				*size = n * sizeof(ns6__ContextInstanceRef);
			for (int i = 0; i < n; i++)
				((ns6__ContextInstanceRef*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ContextInstanceRef*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ContextRef);
		if (size)
			*size = sizeof(ns5__ContextRef);
		((ns5__ContextRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns5__ContextRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__ContextRef);
		for (int i = 0; i < n; i++)
			((ns5__ContextRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ContextRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ContextRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ContextRef %p -> %p\n", q, p));
	*(ns5__ContextRef*)p = *(ns5__ContextRef*)q;
}

void ns5__Context::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__Context::uuid);
	/* transient soap skipped */
}

void ns5__Context::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns5__Context::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__Context::uuid);
	/* transient soap skipped */
}

int ns5__Context::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__Context(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__Context(struct soap *soap, const char *tag, int id, const ns5__Context *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__Context), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns5__Context::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__Context::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__Context(soap, tag, this, type);
}

SOAP_FMAC3 ns5__Context * SOAP_FMAC4 soap_in_ns5__Context(struct soap *soap, const char *tag, ns5__Context *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__Context *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__Context, sizeof(ns5__Context), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__Context)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__Context *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns5__Context::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__Context *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__Context, 0, sizeof(ns5__Context), 0, soap_copy_ns5__Context);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__Context::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__Context);
	if (this->soap_out(soap, tag?tag:"ns5:Context", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__Context::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__Context(soap, this, tag, type);
}

SOAP_FMAC3 ns5__Context * SOAP_FMAC4 soap_get_ns5__Context(struct soap *soap, ns5__Context *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__Context(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__Context * SOAP_FMAC2 soap_instantiate_ns5__Context(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__Context(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__Context, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns6:ContextInstance"))
	{	cp->type = SOAP_TYPE_ns6__ContextInstance;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns6__ContextInstance);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns6__ContextInstance);
			((ns6__ContextInstance*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns6__ContextInstance[n]);
			if (size)
				*size = n * sizeof(ns6__ContextInstance);
			for (int i = 0; i < n; i++)
				((ns6__ContextInstance*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns6__ContextInstance*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__Context);
		if (size)
			*size = sizeof(ns5__Context);
		((ns5__Context*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns5__Context[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__Context);
		for (int i = 0; i < n; i++)
			((ns5__Context*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__Context*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__Context(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__Context %p -> %p\n", q, p));
	*(ns5__Context*)p = *(ns5__Context*)q;
}

void ns5__ItemCode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns5__ItemCode::value);
	this->ns5__ItemCode::time = NULL;
	/* transient soap skipped */
}

void ns5__ItemCode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns5__ItemCode::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns5__ItemCode::value);
	soap_serialize_PointerTotime(soap, &this->ns5__ItemCode::time);
	/* transient soap skipped */
}

int ns5__ItemCode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__ItemCode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ItemCode(struct soap *soap, const char *tag, int id, const ns5__ItemCode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ItemCode), type))
		return soap->error;
	if (soap_out_std__string(soap, "value", -1, &(a->ns5__ItemCode::value), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "time", -1, &(a->ns5__ItemCode::time), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns5__ItemCode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__ItemCode(soap, tag, this, type);
}

SOAP_FMAC3 ns5__ItemCode * SOAP_FMAC4 soap_in_ns5__ItemCode(struct soap *soap, const char *tag, ns5__ItemCode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns5__ItemCode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ItemCode, sizeof(ns5__ItemCode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__ItemCode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns5__ItemCode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_value1 = 1;
	size_t soap_flag_time1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "value", &(a->ns5__ItemCode::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "time", &(a->ns5__ItemCode::time), "xsd:dateTime"))
				{	soap_flag_time1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns5__ItemCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ItemCode, 0, sizeof(ns5__ItemCode), 0, soap_copy_ns5__ItemCode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns5__ItemCode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__ItemCode);
	if (this->soap_out(soap, tag?tag:"ns5:ItemCode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns5__ItemCode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__ItemCode(soap, this, tag, type);
}

SOAP_FMAC3 ns5__ItemCode * SOAP_FMAC4 soap_get_ns5__ItemCode(struct soap *soap, ns5__ItemCode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ItemCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns5__ItemCode * SOAP_FMAC2 soap_instantiate_ns5__ItemCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__ItemCode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__ItemCode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns5__ItemCode);
		if (size)
			*size = sizeof(ns5__ItemCode);
		((ns5__ItemCode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns5__ItemCode[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__ItemCode);
		for (int i = 0; i < n; i++)
			((ns5__ItemCode*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__ItemCode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__ItemCode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__ItemCode %p -> %p\n", q, p));
	*(ns5__ItemCode*)p = *(ns5__ItemCode*)q;
}

void _ns4__ValidatedPeekResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__ValidatedPeekResponse::return_ = NULL;
	/* transient soap skipped */
}

void _ns4__ValidatedPeekResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ContentDescription(soap, &this->_ns4__ValidatedPeekResponse::return_);
	/* transient soap skipped */
}

int _ns4__ValidatedPeekResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__ValidatedPeekResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ValidatedPeekResponse(struct soap *soap, const char *tag, int id, const _ns4__ValidatedPeekResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ValidatedPeekResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__ContentDescription(soap, "return", -1, &(a->_ns4__ValidatedPeekResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__ValidatedPeekResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__ValidatedPeekResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__ValidatedPeekResponse * SOAP_FMAC4 soap_in__ns4__ValidatedPeekResponse(struct soap *soap, const char *tag, _ns4__ValidatedPeekResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__ValidatedPeekResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ValidatedPeekResponse, sizeof(_ns4__ValidatedPeekResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__ValidatedPeekResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__ValidatedPeekResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentDescription(soap, "return", &(a->_ns4__ValidatedPeekResponse::return_), "ns2:ContentDescription"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__ValidatedPeekResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ValidatedPeekResponse, 0, sizeof(_ns4__ValidatedPeekResponse), 0, soap_copy__ns4__ValidatedPeekResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__ValidatedPeekResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__ValidatedPeekResponse);
	if (this->soap_out(soap, tag?tag:"ns4:ValidatedPeekResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__ValidatedPeekResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__ValidatedPeekResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__ValidatedPeekResponse * SOAP_FMAC4 soap_get__ns4__ValidatedPeekResponse(struct soap *soap, _ns4__ValidatedPeekResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ValidatedPeekResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__ValidatedPeekResponse * SOAP_FMAC2 soap_instantiate__ns4__ValidatedPeekResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__ValidatedPeekResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__ValidatedPeekResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__ValidatedPeekResponse);
		if (size)
			*size = sizeof(_ns4__ValidatedPeekResponse);
		((_ns4__ValidatedPeekResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__ValidatedPeekResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__ValidatedPeekResponse);
		for (int i = 0; i < n; i++)
			((_ns4__ValidatedPeekResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__ValidatedPeekResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__ValidatedPeekResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__ValidatedPeekResponse %p -> %p\n", q, p));
	*(_ns4__ValidatedPeekResponse*)p = *(_ns4__ValidatedPeekResponse*)q;
}

void _ns4__ValidatedPeek::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__ValidatedPeek::input.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns4__ValidatedPeek::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__ValidatedPeek::input.soap_serialize(soap);
	/* transient soap skipped */
}

int _ns4__ValidatedPeek::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__ValidatedPeek(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ValidatedPeek(struct soap *soap, const char *tag, int id, const _ns4__ValidatedPeek *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ValidatedPeek), type))
		return soap->error;
	if ((a->_ns4__ValidatedPeek::input).soap_out(soap, "input", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__ValidatedPeek::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__ValidatedPeek(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__ValidatedPeek * SOAP_FMAC4 soap_in__ns4__ValidatedPeek(struct soap *soap, const char *tag, _ns4__ValidatedPeek *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__ValidatedPeek *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ValidatedPeek, sizeof(_ns4__ValidatedPeek), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__ValidatedPeek)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__ValidatedPeek *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__ValidatedPeek::input).soap_in(soap, "input", "xsd:base64Binary"))
				{	soap_flag_input1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__ValidatedPeek *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ValidatedPeek, 0, sizeof(_ns4__ValidatedPeek), 0, soap_copy__ns4__ValidatedPeek);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_input1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__ValidatedPeek::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__ValidatedPeek);
	if (this->soap_out(soap, tag?tag:"ns4:ValidatedPeek", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__ValidatedPeek::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__ValidatedPeek(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__ValidatedPeek * SOAP_FMAC4 soap_get__ns4__ValidatedPeek(struct soap *soap, _ns4__ValidatedPeek *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ValidatedPeek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__ValidatedPeek * SOAP_FMAC2 soap_instantiate__ns4__ValidatedPeek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__ValidatedPeek(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__ValidatedPeek, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__ValidatedPeek);
		if (size)
			*size = sizeof(_ns4__ValidatedPeek);
		((_ns4__ValidatedPeek*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__ValidatedPeek[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__ValidatedPeek);
		for (int i = 0; i < n; i++)
			((_ns4__ValidatedPeek*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__ValidatedPeek*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__ValidatedPeek(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__ValidatedPeek %p -> %p\n", q, p));
	*(_ns4__ValidatedPeek*)p = *(_ns4__ValidatedPeek*)q;
}

void _ns4__PeekResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__PeekResponse::return_ = NULL;
	/* transient soap skipped */
}

void _ns4__PeekResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ContentDescription(soap, &this->_ns4__PeekResponse::return_);
	/* transient soap skipped */
}

int _ns4__PeekResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__PeekResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__PeekResponse(struct soap *soap, const char *tag, int id, const _ns4__PeekResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__PeekResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__ContentDescription(soap, "return", -1, &(a->_ns4__PeekResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__PeekResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__PeekResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__PeekResponse * SOAP_FMAC4 soap_in__ns4__PeekResponse(struct soap *soap, const char *tag, _ns4__PeekResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__PeekResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__PeekResponse, sizeof(_ns4__PeekResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__PeekResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__PeekResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentDescription(soap, "return", &(a->_ns4__PeekResponse::return_), "ns2:ContentDescription"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__PeekResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__PeekResponse, 0, sizeof(_ns4__PeekResponse), 0, soap_copy__ns4__PeekResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__PeekResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__PeekResponse);
	if (this->soap_out(soap, tag?tag:"ns4:PeekResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__PeekResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__PeekResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__PeekResponse * SOAP_FMAC4 soap_get__ns4__PeekResponse(struct soap *soap, _ns4__PeekResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__PeekResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__PeekResponse * SOAP_FMAC2 soap_instantiate__ns4__PeekResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__PeekResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__PeekResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__PeekResponse);
		if (size)
			*size = sizeof(_ns4__PeekResponse);
		((_ns4__PeekResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__PeekResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__PeekResponse);
		for (int i = 0; i < n; i++)
			((_ns4__PeekResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__PeekResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__PeekResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__PeekResponse %p -> %p\n", q, p));
	*(_ns4__PeekResponse*)p = *(_ns4__PeekResponse*)q;
}

void _ns4__Peek::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__Peek::input.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns4__Peek::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__Peek::input.soap_serialize(soap);
	/* transient soap skipped */
}

int _ns4__Peek::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__Peek(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Peek(struct soap *soap, const char *tag, int id, const _ns4__Peek *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Peek), type))
		return soap->error;
	if ((a->_ns4__Peek::input).soap_out(soap, "input", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__Peek::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__Peek(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__Peek * SOAP_FMAC4 soap_in__ns4__Peek(struct soap *soap, const char *tag, _ns4__Peek *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__Peek *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Peek, sizeof(_ns4__Peek), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__Peek)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__Peek *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__Peek::input).soap_in(soap, "input", "xsd:base64Binary"))
				{	soap_flag_input1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__Peek *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Peek, 0, sizeof(_ns4__Peek), 0, soap_copy__ns4__Peek);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_input1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__Peek::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__Peek);
	if (this->soap_out(soap, tag?tag:"ns4:Peek", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__Peek::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__Peek(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__Peek * SOAP_FMAC4 soap_get__ns4__Peek(struct soap *soap, _ns4__Peek *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Peek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__Peek * SOAP_FMAC2 soap_instantiate__ns4__Peek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__Peek(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__Peek, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Peek);
		if (size)
			*size = sizeof(_ns4__Peek);
		((_ns4__Peek*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Peek[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__Peek);
		for (int i = 0; i < n; i++)
			((_ns4__Peek*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__Peek*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__Peek(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__Peek %p -> %p\n", q, p));
	*(_ns4__Peek*)p = *(_ns4__Peek*)q;
}

void _ns4__ReclassifyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__ReclassifyResponse::return_.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns4__ReclassifyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__ReclassifyResponse::return_.soap_serialize(soap);
	/* transient soap skipped */
}

int _ns4__ReclassifyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__ReclassifyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ReclassifyResponse(struct soap *soap, const char *tag, int id, const _ns4__ReclassifyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ReclassifyResponse), type))
		return soap->error;
	if ((a->_ns4__ReclassifyResponse::return_).soap_out(soap, "return", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__ReclassifyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__ReclassifyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__ReclassifyResponse * SOAP_FMAC4 soap_in__ns4__ReclassifyResponse(struct soap *soap, const char *tag, _ns4__ReclassifyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__ReclassifyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ReclassifyResponse, sizeof(_ns4__ReclassifyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__ReclassifyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__ReclassifyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__ReclassifyResponse::return_).soap_in(soap, "return", "xsd:base64Binary"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__ReclassifyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ReclassifyResponse, 0, sizeof(_ns4__ReclassifyResponse), 0, soap_copy__ns4__ReclassifyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__ReclassifyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__ReclassifyResponse);
	if (this->soap_out(soap, tag?tag:"ns4:ReclassifyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__ReclassifyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__ReclassifyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__ReclassifyResponse * SOAP_FMAC4 soap_get__ns4__ReclassifyResponse(struct soap *soap, _ns4__ReclassifyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ReclassifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__ReclassifyResponse * SOAP_FMAC2 soap_instantiate__ns4__ReclassifyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__ReclassifyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__ReclassifyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__ReclassifyResponse);
		if (size)
			*size = sizeof(_ns4__ReclassifyResponse);
		((_ns4__ReclassifyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__ReclassifyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__ReclassifyResponse);
		for (int i = 0; i < n; i++)
			((_ns4__ReclassifyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__ReclassifyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__ReclassifyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__ReclassifyResponse %p -> %p\n", q, p));
	*(_ns4__ReclassifyResponse*)p = *(_ns4__ReclassifyResponse*)q;
}

void _ns4__Reclassify::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__Reclassify::input.xsd__base64Binary::soap_default(soap);
	this->_ns4__Reclassify::classification = NULL;
	/* transient soap skipped */
}

void _ns4__Reclassify::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__Reclassify::input.soap_serialize(soap);
	soap_serialize_PointerTons1__Classification(soap, &this->_ns4__Reclassify::classification);
	/* transient soap skipped */
}

int _ns4__Reclassify::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__Reclassify(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Reclassify(struct soap *soap, const char *tag, int id, const _ns4__Reclassify *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Reclassify), type))
		return soap->error;
	if ((a->_ns4__Reclassify::input).soap_out(soap, "input", -1, ""))
		return soap->error;
	if (soap_out_PointerTons1__Classification(soap, "classification", -1, &(a->_ns4__Reclassify::classification), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__Reclassify::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__Reclassify(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__Reclassify * SOAP_FMAC4 soap_in__ns4__Reclassify(struct soap *soap, const char *tag, _ns4__Reclassify *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__Reclassify *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Reclassify, sizeof(_ns4__Reclassify), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__Reclassify)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__Reclassify *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_input1 = 1;
	size_t soap_flag_classification1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__Reclassify::input).soap_in(soap, "input", "xsd:base64Binary"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap_flag_classification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Classification(soap, "classification", &(a->_ns4__Reclassify::classification), "ns1:Classification"))
				{	soap_flag_classification1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__Reclassify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Reclassify, 0, sizeof(_ns4__Reclassify), 0, soap_copy__ns4__Reclassify);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_input1 > 0 || soap_flag_classification1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__Reclassify::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__Reclassify);
	if (this->soap_out(soap, tag?tag:"ns4:Reclassify", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__Reclassify::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__Reclassify(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__Reclassify * SOAP_FMAC4 soap_get__ns4__Reclassify(struct soap *soap, _ns4__Reclassify *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Reclassify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__Reclassify * SOAP_FMAC2 soap_instantiate__ns4__Reclassify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__Reclassify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__Reclassify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Reclassify);
		if (size)
			*size = sizeof(_ns4__Reclassify);
		((_ns4__Reclassify*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Reclassify[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__Reclassify);
		for (int i = 0; i < n; i++)
			((_ns4__Reclassify*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__Reclassify*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__Reclassify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__Reclassify %p -> %p\n", q, p));
	*(_ns4__Reclassify*)p = *(_ns4__Reclassify*)q;
}

void _ns4__ResealResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__ResealResponse::return_.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns4__ResealResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__ResealResponse::return_.soap_serialize(soap);
	/* transient soap skipped */
}

int _ns4__ResealResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__ResealResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__ResealResponse(struct soap *soap, const char *tag, int id, const _ns4__ResealResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__ResealResponse), type))
		return soap->error;
	if ((a->_ns4__ResealResponse::return_).soap_out(soap, "return", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__ResealResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__ResealResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__ResealResponse * SOAP_FMAC4 soap_in__ns4__ResealResponse(struct soap *soap, const char *tag, _ns4__ResealResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__ResealResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__ResealResponse, sizeof(_ns4__ResealResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__ResealResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__ResealResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__ResealResponse::return_).soap_in(soap, "return", "xsd:base64Binary"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__ResealResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__ResealResponse, 0, sizeof(_ns4__ResealResponse), 0, soap_copy__ns4__ResealResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__ResealResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__ResealResponse);
	if (this->soap_out(soap, tag?tag:"ns4:ResealResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__ResealResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__ResealResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__ResealResponse * SOAP_FMAC4 soap_get__ns4__ResealResponse(struct soap *soap, _ns4__ResealResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__ResealResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__ResealResponse * SOAP_FMAC2 soap_instantiate__ns4__ResealResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__ResealResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__ResealResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__ResealResponse);
		if (size)
			*size = sizeof(_ns4__ResealResponse);
		((_ns4__ResealResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__ResealResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__ResealResponse);
		for (int i = 0; i < n; i++)
			((_ns4__ResealResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__ResealResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__ResealResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__ResealResponse %p -> %p\n", q, p));
	*(_ns4__ResealResponse*)p = *(_ns4__ResealResponse*)q;
}

void _ns4__Reseal::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__Reseal::input.xsd__base64Binary::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTons2__CustomData(soap, &this->_ns4__Reseal::customData);
	/* transient soap skipped */
}

void _ns4__Reseal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__Reseal::input.soap_serialize(soap);
	soap_serialize_std__vectorTemplateOfPointerTons2__CustomData(soap, &this->_ns4__Reseal::customData);
	/* transient soap skipped */
}

int _ns4__Reseal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__Reseal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Reseal(struct soap *soap, const char *tag, int id, const _ns4__Reseal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Reseal), type))
		return soap->error;
	if ((a->_ns4__Reseal::input).soap_out(soap, "input", -1, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__CustomData(soap, "customData", -1, &(a->_ns4__Reseal::customData), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__Reseal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__Reseal(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__Reseal * SOAP_FMAC4 soap_in__ns4__Reseal(struct soap *soap, const char *tag, _ns4__Reseal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__Reseal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Reseal, sizeof(_ns4__Reseal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__Reseal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__Reseal *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__Reseal::input).soap_in(soap, "input", "xsd:base64Binary"))
				{	soap_flag_input1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__CustomData(soap, "customData", &(a->_ns4__Reseal::customData), "ns2:CustomData"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__Reseal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Reseal, 0, sizeof(_ns4__Reseal), 0, soap_copy__ns4__Reseal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_input1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__Reseal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__Reseal);
	if (this->soap_out(soap, tag?tag:"ns4:Reseal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__Reseal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__Reseal(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__Reseal * SOAP_FMAC4 soap_get__ns4__Reseal(struct soap *soap, _ns4__Reseal *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Reseal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__Reseal * SOAP_FMAC2 soap_instantiate__ns4__Reseal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__Reseal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__Reseal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Reseal);
		if (size)
			*size = sizeof(_ns4__Reseal);
		((_ns4__Reseal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Reseal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__Reseal);
		for (int i = 0; i < n; i++)
			((_ns4__Reseal*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__Reseal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__Reseal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__Reseal %p -> %p\n", q, p));
	*(_ns4__Reseal*)p = *(_ns4__Reseal*)q;
}

void _ns4__UnsealResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__UnsealResponse::return_.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns4__UnsealResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__UnsealResponse::return_.soap_serialize(soap);
	/* transient soap skipped */
}

int _ns4__UnsealResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__UnsealResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__UnsealResponse(struct soap *soap, const char *tag, int id, const _ns4__UnsealResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__UnsealResponse), type))
		return soap->error;
	if ((a->_ns4__UnsealResponse::return_).soap_out(soap, "return", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__UnsealResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__UnsealResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__UnsealResponse * SOAP_FMAC4 soap_in__ns4__UnsealResponse(struct soap *soap, const char *tag, _ns4__UnsealResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__UnsealResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__UnsealResponse, sizeof(_ns4__UnsealResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__UnsealResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__UnsealResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__UnsealResponse::return_).soap_in(soap, "return", "xsd:base64Binary"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__UnsealResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__UnsealResponse, 0, sizeof(_ns4__UnsealResponse), 0, soap_copy__ns4__UnsealResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__UnsealResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__UnsealResponse);
	if (this->soap_out(soap, tag?tag:"ns4:UnsealResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__UnsealResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__UnsealResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__UnsealResponse * SOAP_FMAC4 soap_get__ns4__UnsealResponse(struct soap *soap, _ns4__UnsealResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__UnsealResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__UnsealResponse * SOAP_FMAC2 soap_instantiate__ns4__UnsealResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__UnsealResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__UnsealResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__UnsealResponse);
		if (size)
			*size = sizeof(_ns4__UnsealResponse);
		((_ns4__UnsealResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__UnsealResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__UnsealResponse);
		for (int i = 0; i < n; i++)
			((_ns4__UnsealResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__UnsealResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__UnsealResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__UnsealResponse %p -> %p\n", q, p));
	*(_ns4__UnsealResponse*)p = *(_ns4__UnsealResponse*)q;
}

void _ns4__Unseal::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__Unseal::input.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns4__Unseal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__Unseal::input.soap_serialize(soap);
	/* transient soap skipped */
}

int _ns4__Unseal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__Unseal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Unseal(struct soap *soap, const char *tag, int id, const _ns4__Unseal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Unseal), type))
		return soap->error;
	if ((a->_ns4__Unseal::input).soap_out(soap, "input", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__Unseal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__Unseal(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__Unseal * SOAP_FMAC4 soap_in__ns4__Unseal(struct soap *soap, const char *tag, _ns4__Unseal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__Unseal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Unseal, sizeof(_ns4__Unseal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__Unseal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__Unseal *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_input1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__Unseal::input).soap_in(soap, "input", "xsd:base64Binary"))
				{	soap_flag_input1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__Unseal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Unseal, 0, sizeof(_ns4__Unseal), 0, soap_copy__ns4__Unseal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_input1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__Unseal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__Unseal);
	if (this->soap_out(soap, tag?tag:"ns4:Unseal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__Unseal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__Unseal(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__Unseal * SOAP_FMAC4 soap_get__ns4__Unseal(struct soap *soap, _ns4__Unseal *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Unseal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__Unseal * SOAP_FMAC2 soap_instantiate__ns4__Unseal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__Unseal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__Unseal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Unseal);
		if (size)
			*size = sizeof(_ns4__Unseal);
		((_ns4__Unseal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Unseal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__Unseal);
		for (int i = 0; i < n; i++)
			((_ns4__Unseal*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__Unseal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__Unseal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__Unseal %p -> %p\n", q, p));
	*(_ns4__Unseal*)p = *(_ns4__Unseal*)q;
}

void _ns4__SealResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__SealResponse::return_.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void _ns4__SealResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__SealResponse::return_.soap_serialize(soap);
	/* transient soap skipped */
}

int _ns4__SealResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__SealResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__SealResponse(struct soap *soap, const char *tag, int id, const _ns4__SealResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__SealResponse), type))
		return soap->error;
	if ((a->_ns4__SealResponse::return_).soap_out(soap, "return", -1, ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__SealResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__SealResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__SealResponse * SOAP_FMAC4 soap_in__ns4__SealResponse(struct soap *soap, const char *tag, _ns4__SealResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__SealResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__SealResponse, sizeof(_ns4__SealResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__SealResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__SealResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__SealResponse::return_).soap_in(soap, "return", "xsd:base64Binary"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__SealResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__SealResponse, 0, sizeof(_ns4__SealResponse), 0, soap_copy__ns4__SealResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__SealResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__SealResponse);
	if (this->soap_out(soap, tag?tag:"ns4:SealResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__SealResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__SealResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__SealResponse * SOAP_FMAC4 soap_get__ns4__SealResponse(struct soap *soap, _ns4__SealResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__SealResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__SealResponse * SOAP_FMAC2 soap_instantiate__ns4__SealResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__SealResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__SealResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__SealResponse);
		if (size)
			*size = sizeof(_ns4__SealResponse);
		((_ns4__SealResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__SealResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__SealResponse);
		for (int i = 0; i < n; i++)
			((_ns4__SealResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__SealResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__SealResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__SealResponse %p -> %p\n", q, p));
	*(_ns4__SealResponse*)p = *(_ns4__SealResponse*)q;
}

void _ns4__Seal::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns4__Seal::stream.xsd__base64Binary::soap_default(soap);
	soap_default_std__string(soap, &this->_ns4__Seal::mimeType);
	this->_ns4__Seal::options = NULL;
	/* transient soap skipped */
}

void _ns4__Seal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->_ns4__Seal::stream.soap_serialize(soap);
	soap_embedded(soap, &this->_ns4__Seal::mimeType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns4__Seal::mimeType);
	soap_serialize_PointerTons2__SealingOptions(soap, &this->_ns4__Seal::options);
	/* transient soap skipped */
}

int _ns4__Seal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns4__Seal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__Seal(struct soap *soap, const char *tag, int id, const _ns4__Seal *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns4__Seal), type))
		return soap->error;
	if ((a->_ns4__Seal::stream).soap_out(soap, "stream", -1, ""))
		return soap->error;
	if (soap_out_std__string(soap, "mimeType", -1, &(a->_ns4__Seal::mimeType), ""))
		return soap->error;
	if (soap_out_PointerTons2__SealingOptions(soap, "options", -1, &(a->_ns4__Seal::options), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns4__Seal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns4__Seal(soap, tag, this, type);
}

SOAP_FMAC3 _ns4__Seal * SOAP_FMAC4 soap_in__ns4__Seal(struct soap *soap, const char *tag, _ns4__Seal *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns4__Seal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns4__Seal, sizeof(_ns4__Seal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns4__Seal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns4__Seal *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stream1 = 1;
	size_t soap_flag_mimeType1 = 1;
	size_t soap_flag_options1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stream1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->_ns4__Seal::stream).soap_in(soap, "stream", "xsd:base64Binary"))
				{	soap_flag_stream1--;
					continue;
				}
			if (soap_flag_mimeType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mimeType", &(a->_ns4__Seal::mimeType), "xsd:string"))
				{	soap_flag_mimeType1--;
					continue;
				}
			if (soap_flag_options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SealingOptions(soap, "options", &(a->_ns4__Seal::options), "ns2:SealingOptions"))
				{	soap_flag_options1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns4__Seal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns4__Seal, 0, sizeof(_ns4__Seal), 0, soap_copy__ns4__Seal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stream1 > 0 || soap_flag_mimeType1 > 0 || soap_flag_options1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns4__Seal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns4__Seal);
	if (this->soap_out(soap, tag?tag:"ns4:Seal", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns4__Seal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns4__Seal(soap, this, tag, type);
}

SOAP_FMAC3 _ns4__Seal * SOAP_FMAC4 soap_get__ns4__Seal(struct soap *soap, _ns4__Seal *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns4__Seal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns4__Seal * SOAP_FMAC2 soap_instantiate__ns4__Seal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns4__Seal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns4__Seal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Seal);
		if (size)
			*size = sizeof(_ns4__Seal);
		((_ns4__Seal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_ns4__Seal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns4__Seal);
		for (int i = 0; i < n; i++)
			((_ns4__Seal*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns4__Seal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns4__Seal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns4__Seal %p -> %p\n", q, p));
	*(_ns4__Seal*)p = *(_ns4__Seal*)q;
}

void ns3__AuthorizationDeniedFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns3__AuthorizationDeniedFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns3__AuthorizationDeniedFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__AuthorizationDeniedFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__AuthorizationDeniedFault(struct soap *soap, const char *tag, int id, const ns3__AuthorizationDeniedFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__AuthorizationDeniedFault), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns3__AuthorizationDeniedFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__AuthorizationDeniedFault(soap, tag, this, type);
}

SOAP_FMAC3 ns3__AuthorizationDeniedFault * SOAP_FMAC4 soap_in_ns3__AuthorizationDeniedFault(struct soap *soap, const char *tag, ns3__AuthorizationDeniedFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__AuthorizationDeniedFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__AuthorizationDeniedFault, sizeof(ns3__AuthorizationDeniedFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__AuthorizationDeniedFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__AuthorizationDeniedFault *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__AuthorizationDeniedFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__AuthorizationDeniedFault, 0, sizeof(ns3__AuthorizationDeniedFault), 0, soap_copy_ns3__AuthorizationDeniedFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns3__AuthorizationDeniedFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__AuthorizationDeniedFault);
	if (this->soap_out(soap, tag?tag:"ns3:AuthorizationDeniedFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns3__AuthorizationDeniedFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__AuthorizationDeniedFault(soap, this, tag, type);
}

SOAP_FMAC3 ns3__AuthorizationDeniedFault * SOAP_FMAC4 soap_get_ns3__AuthorizationDeniedFault(struct soap *soap, ns3__AuthorizationDeniedFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__AuthorizationDeniedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns3__AuthorizationDeniedFault * SOAP_FMAC2 soap_instantiate_ns3__AuthorizationDeniedFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__AuthorizationDeniedFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__AuthorizationDeniedFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns3__AuthorizationDeniedFault);
		if (size)
			*size = sizeof(ns3__AuthorizationDeniedFault);
		((ns3__AuthorizationDeniedFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns3__AuthorizationDeniedFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__AuthorizationDeniedFault);
		for (int i = 0; i < n; i++)
			((ns3__AuthorizationDeniedFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__AuthorizationDeniedFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__AuthorizationDeniedFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__AuthorizationDeniedFault %p -> %p\n", q, p));
	*(ns3__AuthorizationDeniedFault*)p = *(ns3__AuthorizationDeniedFault*)q;
}

void ns2__ContentParseFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__ContentParseFault_USCOREReason(soap, &this->ns2__ContentParseFault::reason);
	/* transient soap skipped */
}

void ns2__ContentParseFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__ContentParseFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentParseFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentParseFault(struct soap *soap, const char *tag, int id, const ns2__ContentParseFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentParseFault), type))
		return soap->error;
	if (soap_out_ns2__ContentParseFault_USCOREReason(soap, "reason", -1, &(a->ns2__ContentParseFault::reason), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentParseFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentParseFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentParseFault * SOAP_FMAC4 soap_in_ns2__ContentParseFault(struct soap *soap, const char *tag, ns2__ContentParseFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentParseFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentParseFault, sizeof(ns2__ContentParseFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentParseFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentParseFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_reason1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_reason1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ContentParseFault_USCOREReason(soap, "reason", &(a->ns2__ContentParseFault::reason), "ns2:ContentParseFault_Reason"))
				{	soap_flag_reason1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentParseFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentParseFault, 0, sizeof(ns2__ContentParseFault), 0, soap_copy_ns2__ContentParseFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_reason1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ContentParseFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentParseFault);
	if (this->soap_out(soap, tag?tag:"ns2:ContentParseFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentParseFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentParseFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentParseFault * SOAP_FMAC4 soap_get_ns2__ContentParseFault(struct soap *soap, ns2__ContentParseFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentParseFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentParseFault * SOAP_FMAC2 soap_instantiate_ns2__ContentParseFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentParseFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentParseFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentParseFault);
		if (size)
			*size = sizeof(ns2__ContentParseFault);
		((ns2__ContentParseFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentParseFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentParseFault);
		for (int i = 0; i < n; i++)
			((ns2__ContentParseFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentParseFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentParseFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentParseFault %p -> %p\n", q, p));
	*(ns2__ContentParseFault*)p = *(ns2__ContentParseFault*)q;
}

void ns2__PublicHeaderLengthFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__PublicHeaderLengthFault::length);
	soap_default_int(soap, &this->ns2__PublicHeaderLengthFault::maximum);
	/* transient soap skipped */
}

void ns2__PublicHeaderLengthFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__PublicHeaderLengthFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__PublicHeaderLengthFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__PublicHeaderLengthFault(struct soap *soap, const char *tag, int id, const ns2__PublicHeaderLengthFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__PublicHeaderLengthFault), type))
		return soap->error;
	if (soap_out_int(soap, "length", -1, &(a->ns2__PublicHeaderLengthFault::length), ""))
		return soap->error;
	if (soap_out_int(soap, "maximum", -1, &(a->ns2__PublicHeaderLengthFault::maximum), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__PublicHeaderLengthFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__PublicHeaderLengthFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__PublicHeaderLengthFault * SOAP_FMAC4 soap_in_ns2__PublicHeaderLengthFault(struct soap *soap, const char *tag, ns2__PublicHeaderLengthFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__PublicHeaderLengthFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__PublicHeaderLengthFault, sizeof(ns2__PublicHeaderLengthFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__PublicHeaderLengthFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__PublicHeaderLengthFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_length1 = 1;
	size_t soap_flag_maximum1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_length1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "length", &(a->ns2__PublicHeaderLengthFault::length), "xsd:int"))
				{	soap_flag_length1--;
					continue;
				}
			if (soap_flag_maximum1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maximum", &(a->ns2__PublicHeaderLengthFault::maximum), "xsd:int"))
				{	soap_flag_maximum1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__PublicHeaderLengthFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__PublicHeaderLengthFault, 0, sizeof(ns2__PublicHeaderLengthFault), 0, soap_copy_ns2__PublicHeaderLengthFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_length1 > 0 || soap_flag_maximum1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__PublicHeaderLengthFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__PublicHeaderLengthFault);
	if (this->soap_out(soap, tag?tag:"ns2:PublicHeaderLengthFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__PublicHeaderLengthFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__PublicHeaderLengthFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__PublicHeaderLengthFault * SOAP_FMAC4 soap_get_ns2__PublicHeaderLengthFault(struct soap *soap, ns2__PublicHeaderLengthFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__PublicHeaderLengthFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__PublicHeaderLengthFault * SOAP_FMAC2 soap_instantiate_ns2__PublicHeaderLengthFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__PublicHeaderLengthFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__PublicHeaderLengthFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__PublicHeaderLengthFault);
		if (size)
			*size = sizeof(ns2__PublicHeaderLengthFault);
		((ns2__PublicHeaderLengthFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__PublicHeaderLengthFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__PublicHeaderLengthFault);
		for (int i = 0; i < n; i++)
			((ns2__PublicHeaderLengthFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__PublicHeaderLengthFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__PublicHeaderLengthFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__PublicHeaderLengthFault %p -> %p\n", q, p));
	*(ns2__PublicHeaderLengthFault*)p = *(ns2__PublicHeaderLengthFault*)q;
}

void ns2__IllegalEncryptedContentBlockSizeFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__IllegalEncryptedContentBlockSizeFault::blockSize);
	soap_default_int(soap, &this->ns2__IllegalEncryptedContentBlockSizeFault::encryptedContentBlockSize);
	/* transient soap skipped */
}

void ns2__IllegalEncryptedContentBlockSizeFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__IllegalEncryptedContentBlockSizeFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__IllegalEncryptedContentBlockSizeFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, const char *tag, int id, const ns2__IllegalEncryptedContentBlockSizeFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault), type))
		return soap->error;
	if (soap_out_int(soap, "blockSize", -1, &(a->ns2__IllegalEncryptedContentBlockSizeFault::blockSize), ""))
		return soap->error;
	if (soap_out_int(soap, "encryptedContentBlockSize", -1, &(a->ns2__IllegalEncryptedContentBlockSizeFault::encryptedContentBlockSize), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__IllegalEncryptedContentBlockSizeFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__IllegalEncryptedContentBlockSizeFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__IllegalEncryptedContentBlockSizeFault * SOAP_FMAC4 soap_in_ns2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, const char *tag, ns2__IllegalEncryptedContentBlockSizeFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__IllegalEncryptedContentBlockSizeFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault, sizeof(ns2__IllegalEncryptedContentBlockSizeFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__IllegalEncryptedContentBlockSizeFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_blockSize1 = 1;
	size_t soap_flag_encryptedContentBlockSize1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blockSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "blockSize", &(a->ns2__IllegalEncryptedContentBlockSizeFault::blockSize), "xsd:int"))
				{	soap_flag_blockSize1--;
					continue;
				}
			if (soap_flag_encryptedContentBlockSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "encryptedContentBlockSize", &(a->ns2__IllegalEncryptedContentBlockSizeFault::encryptedContentBlockSize), "xsd:int"))
				{	soap_flag_encryptedContentBlockSize1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__IllegalEncryptedContentBlockSizeFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault, 0, sizeof(ns2__IllegalEncryptedContentBlockSizeFault), 0, soap_copy_ns2__IllegalEncryptedContentBlockSizeFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blockSize1 > 0 || soap_flag_encryptedContentBlockSize1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__IllegalEncryptedContentBlockSizeFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault);
	if (this->soap_out(soap, tag?tag:"ns2:IllegalEncryptedContentBlockSizeFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__IllegalEncryptedContentBlockSizeFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__IllegalEncryptedContentBlockSizeFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__IllegalEncryptedContentBlockSizeFault * SOAP_FMAC4 soap_get_ns2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, ns2__IllegalEncryptedContentBlockSizeFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__IllegalEncryptedContentBlockSizeFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__IllegalEncryptedContentBlockSizeFault * SOAP_FMAC2 soap_instantiate_ns2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__IllegalEncryptedContentBlockSizeFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__IllegalEncryptedContentBlockSizeFault);
		if (size)
			*size = sizeof(ns2__IllegalEncryptedContentBlockSizeFault);
		((ns2__IllegalEncryptedContentBlockSizeFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__IllegalEncryptedContentBlockSizeFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__IllegalEncryptedContentBlockSizeFault);
		for (int i = 0; i < n; i++)
			((ns2__IllegalEncryptedContentBlockSizeFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__IllegalEncryptedContentBlockSizeFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__IllegalEncryptedContentBlockSizeFault %p -> %p\n", q, p));
	*(ns2__IllegalEncryptedContentBlockSizeFault*)p = *(ns2__IllegalEncryptedContentBlockSizeFault*)q;
}

void ns2__UnsupportedContentTypeFault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__UnsupportedContentTypeFault::value);
	/* transient soap skipped */
}

void ns2__UnsupportedContentTypeFault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__UnsupportedContentTypeFault::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__UnsupportedContentTypeFault::value);
	/* transient soap skipped */
}

int ns2__UnsupportedContentTypeFault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__UnsupportedContentTypeFault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__UnsupportedContentTypeFault(struct soap *soap, const char *tag, int id, const ns2__UnsupportedContentTypeFault *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__UnsupportedContentTypeFault), type))
		return soap->error;
	if (soap_out_std__string(soap, "value", -1, &(a->ns2__UnsupportedContentTypeFault::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__UnsupportedContentTypeFault::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__UnsupportedContentTypeFault(soap, tag, this, type);
}

SOAP_FMAC3 ns2__UnsupportedContentTypeFault * SOAP_FMAC4 soap_in_ns2__UnsupportedContentTypeFault(struct soap *soap, const char *tag, ns2__UnsupportedContentTypeFault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__UnsupportedContentTypeFault *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__UnsupportedContentTypeFault, sizeof(ns2__UnsupportedContentTypeFault), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__UnsupportedContentTypeFault)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__UnsupportedContentTypeFault *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "value", &(a->ns2__UnsupportedContentTypeFault::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__UnsupportedContentTypeFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__UnsupportedContentTypeFault, 0, sizeof(ns2__UnsupportedContentTypeFault), 0, soap_copy_ns2__UnsupportedContentTypeFault);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__UnsupportedContentTypeFault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__UnsupportedContentTypeFault);
	if (this->soap_out(soap, tag?tag:"ns2:UnsupportedContentTypeFault", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__UnsupportedContentTypeFault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__UnsupportedContentTypeFault(soap, this, tag, type);
}

SOAP_FMAC3 ns2__UnsupportedContentTypeFault * SOAP_FMAC4 soap_get_ns2__UnsupportedContentTypeFault(struct soap *soap, ns2__UnsupportedContentTypeFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__UnsupportedContentTypeFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__UnsupportedContentTypeFault * SOAP_FMAC2 soap_instantiate_ns2__UnsupportedContentTypeFault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__UnsupportedContentTypeFault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__UnsupportedContentTypeFault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__UnsupportedContentTypeFault);
		if (size)
			*size = sizeof(ns2__UnsupportedContentTypeFault);
		((ns2__UnsupportedContentTypeFault*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__UnsupportedContentTypeFault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__UnsupportedContentTypeFault);
		for (int i = 0; i < n; i++)
			((ns2__UnsupportedContentTypeFault*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__UnsupportedContentTypeFault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__UnsupportedContentTypeFault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__UnsupportedContentTypeFault %p -> %p\n", q, p));
	*(ns2__UnsupportedContentTypeFault*)p = *(ns2__UnsupportedContentTypeFault*)q;
}

void ns2__ContentDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ContentDescription::schema = NULL;
	this->ns2__ContentDescription::classification = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__CustomData(soap, &this->ns2__ContentDescription::customData);
	soap_default_time(soap, &this->ns2__ContentDescription::creationTime);
	soap_default_time(soap, &this->ns2__ContentDescription::editTime);
	soap_default_std__string(soap, &this->ns2__ContentDescription::sealedMime);
	soap_default_LONG64(soap, &this->ns2__ContentDescription::unsealedSize);
	/* transient soap skipped */
}

void ns2__ContentDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ContentSchema(soap, &this->ns2__ContentDescription::schema);
	soap_serialize_PointerTons1__Classification(soap, &this->ns2__ContentDescription::classification);
	soap_serialize_std__vectorTemplateOfPointerTons2__CustomData(soap, &this->ns2__ContentDescription::customData);
	soap_embedded(soap, &this->ns2__ContentDescription::creationTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__ContentDescription::editTime, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns2__ContentDescription::sealedMime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__ContentDescription::sealedMime);
	/* transient soap skipped */
}

int ns2__ContentDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentDescription(struct soap *soap, const char *tag, int id, const ns2__ContentDescription *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentDescription), type))
		return soap->error;
	if (soap_out_PointerTons2__ContentSchema(soap, "schema", -1, &(a->ns2__ContentDescription::schema), ""))
		return soap->error;
	if (soap_out_PointerTons1__Classification(soap, "classification", -1, &(a->ns2__ContentDescription::classification), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__CustomData(soap, "customData", -1, &(a->ns2__ContentDescription::customData), ""))
		return soap->error;
	if (soap_out_time(soap, "creationTime", -1, &(a->ns2__ContentDescription::creationTime), ""))
		return soap->error;
	if (soap_out_time(soap, "editTime", -1, &(a->ns2__ContentDescription::editTime), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sealedMime", -1, &(a->ns2__ContentDescription::sealedMime), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "unsealedSize", -1, &(a->ns2__ContentDescription::unsealedSize), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentDescription(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentDescription * SOAP_FMAC4 soap_in_ns2__ContentDescription(struct soap *soap, const char *tag, ns2__ContentDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentDescription *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentDescription, sizeof(ns2__ContentDescription), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentDescription)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentDescription *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_schema1 = 1;
	size_t soap_flag_classification1 = 1;
	size_t soap_flag_creationTime1 = 1;
	size_t soap_flag_editTime1 = 1;
	size_t soap_flag_sealedMime1 = 1;
	size_t soap_flag_unsealedSize1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_schema1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentSchema(soap, "schema", &(a->ns2__ContentDescription::schema), "ns2:ContentSchema"))
				{	soap_flag_schema1--;
					continue;
				}
			if (soap_flag_classification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Classification(soap, "classification", &(a->ns2__ContentDescription::classification), "ns1:Classification"))
				{	soap_flag_classification1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__CustomData(soap, "customData", &(a->ns2__ContentDescription::customData), "ns2:CustomData"))
					continue;
			if (soap_flag_creationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "creationTime", &(a->ns2__ContentDescription::creationTime), "xsd:dateTime"))
				{	soap_flag_creationTime1--;
					continue;
				}
			if (soap_flag_editTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "editTime", &(a->ns2__ContentDescription::editTime), "xsd:dateTime"))
				{	soap_flag_editTime1--;
					continue;
				}
			if (soap_flag_sealedMime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sealedMime", &(a->ns2__ContentDescription::sealedMime), "xsd:string"))
				{	soap_flag_sealedMime1--;
					continue;
				}
			if (soap_flag_unsealedSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "unsealedSize", &(a->ns2__ContentDescription::unsealedSize), "xsd:long"))
				{	soap_flag_unsealedSize1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentDescription, 0, sizeof(ns2__ContentDescription), 0, soap_copy_ns2__ContentDescription);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_schema1 > 0 || soap_flag_classification1 > 0 || soap_flag_creationTime1 > 0 || soap_flag_editTime1 > 0 || soap_flag_sealedMime1 > 0 || soap_flag_unsealedSize1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ContentDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentDescription);
	if (this->soap_out(soap, tag?tag:"ns2:ContentDescription", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentDescription(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentDescription * SOAP_FMAC4 soap_get_ns2__ContentDescription(struct soap *soap, ns2__ContentDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentDescription * SOAP_FMAC2 soap_instantiate_ns2__ContentDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentDescription(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentDescription, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentDescription);
		if (size)
			*size = sizeof(ns2__ContentDescription);
		((ns2__ContentDescription*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentDescription[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentDescription);
		for (int i = 0; i < n; i++)
			((ns2__ContentDescription*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentDescription*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentDescription(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentDescription %p -> %p\n", q, p));
	*(ns2__ContentDescription*)p = *(ns2__ContentDescription*)q;
}

void ns2__SealingOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SealingOptions::classification = NULL;
	soap_default_std__vectorTemplateOfPointerTons2__CustomData(soap, &this->ns2__SealingOptions::customData);
	this->ns2__SealingOptions::contentSchema = NULL;
	this->ns2__SealingOptions::creationTime = NULL;
	this->ns2__SealingOptions::encryptionOptions = NULL;
	/* transient soap skipped */
}

void ns2__SealingOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Classification(soap, &this->ns2__SealingOptions::classification);
	soap_serialize_std__vectorTemplateOfPointerTons2__CustomData(soap, &this->ns2__SealingOptions::customData);
	soap_serialize_PointerTons2__ContentSchema(soap, &this->ns2__SealingOptions::contentSchema);
	soap_serialize_PointerTotime(soap, &this->ns2__SealingOptions::creationTime);
	soap_serialize_PointerTons2__EncryptionOptions(soap, &this->ns2__SealingOptions::encryptionOptions);
	/* transient soap skipped */
}

int ns2__SealingOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SealingOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SealingOptions(struct soap *soap, const char *tag, int id, const ns2__SealingOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SealingOptions), type))
		return soap->error;
	if (soap_out_PointerTons1__Classification(soap, "classification", -1, &(a->ns2__SealingOptions::classification), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons2__CustomData(soap, "customData", -1, &(a->ns2__SealingOptions::customData), ""))
		return soap->error;
	if (soap_out_PointerTons2__ContentSchema(soap, "contentSchema", -1, &(a->ns2__SealingOptions::contentSchema), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "creationTime", -1, &(a->ns2__SealingOptions::creationTime), ""))
		return soap->error;
	if (soap_out_PointerTons2__EncryptionOptions(soap, "encryptionOptions", -1, &(a->ns2__SealingOptions::encryptionOptions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SealingOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SealingOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SealingOptions * SOAP_FMAC4 soap_in_ns2__SealingOptions(struct soap *soap, const char *tag, ns2__SealingOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SealingOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SealingOptions, sizeof(ns2__SealingOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SealingOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SealingOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_classification1 = 1;
	size_t soap_flag_contentSchema1 = 1;
	size_t soap_flag_creationTime1 = 1;
	size_t soap_flag_encryptionOptions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_classification1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Classification(soap, "classification", &(a->ns2__SealingOptions::classification), "ns1:Classification"))
				{	soap_flag_classification1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons2__CustomData(soap, "customData", &(a->ns2__SealingOptions::customData), "ns2:CustomData"))
					continue;
			if (soap_flag_contentSchema1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentSchema(soap, "contentSchema", &(a->ns2__SealingOptions::contentSchema), "ns2:ContentSchema"))
				{	soap_flag_contentSchema1--;
					continue;
				}
			if (soap_flag_creationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "creationTime", &(a->ns2__SealingOptions::creationTime), "xsd:dateTime"))
				{	soap_flag_creationTime1--;
					continue;
				}
			if (soap_flag_encryptionOptions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EncryptionOptions(soap, "encryptionOptions", &(a->ns2__SealingOptions::encryptionOptions), "ns2:EncryptionOptions"))
				{	soap_flag_encryptionOptions1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SealingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SealingOptions, 0, sizeof(ns2__SealingOptions), 0, soap_copy_ns2__SealingOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_classification1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SealingOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SealingOptions);
	if (this->soap_out(soap, tag?tag:"ns2:SealingOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SealingOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SealingOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SealingOptions * SOAP_FMAC4 soap_get_ns2__SealingOptions(struct soap *soap, ns2__SealingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SealingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SealingOptions * SOAP_FMAC2 soap_instantiate_ns2__SealingOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SealingOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SealingOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SealingOptions);
		if (size)
			*size = sizeof(ns2__SealingOptions);
		((ns2__SealingOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SealingOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SealingOptions);
		for (int i = 0; i < n; i++)
			((ns2__SealingOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SealingOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SealingOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SealingOptions %p -> %p\n", q, p));
	*(ns2__SealingOptions*)p = *(ns2__SealingOptions*)q;
}

void ns2__EncryptionOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__EncryptionOptions::publicHeaderPeriod);
	soap_default_int(soap, &this->ns2__EncryptionOptions::encryptedContentBlockSize);
	/* transient soap skipped */
}

void ns2__EncryptionOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__EncryptionOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EncryptionOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EncryptionOptions(struct soap *soap, const char *tag, int id, const ns2__EncryptionOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EncryptionOptions), type))
		return soap->error;
	if (soap_out_int(soap, "publicHeaderPeriod", -1, &(a->ns2__EncryptionOptions::publicHeaderPeriod), ""))
		return soap->error;
	if (soap_out_int(soap, "encryptedContentBlockSize", -1, &(a->ns2__EncryptionOptions::encryptedContentBlockSize), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__EncryptionOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EncryptionOptions(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EncryptionOptions * SOAP_FMAC4 soap_in_ns2__EncryptionOptions(struct soap *soap, const char *tag, ns2__EncryptionOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EncryptionOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EncryptionOptions, sizeof(ns2__EncryptionOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__EncryptionOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__EncryptionOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_publicHeaderPeriod1 = 1;
	size_t soap_flag_encryptedContentBlockSize1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_publicHeaderPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "publicHeaderPeriod", &(a->ns2__EncryptionOptions::publicHeaderPeriod), "xsd:int"))
				{	soap_flag_publicHeaderPeriod1--;
					continue;
				}
			if (soap_flag_encryptedContentBlockSize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "encryptedContentBlockSize", &(a->ns2__EncryptionOptions::encryptedContentBlockSize), "xsd:int"))
				{	soap_flag_encryptedContentBlockSize1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EncryptionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EncryptionOptions, 0, sizeof(ns2__EncryptionOptions), 0, soap_copy_ns2__EncryptionOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_publicHeaderPeriod1 > 0 || soap_flag_encryptedContentBlockSize1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__EncryptionOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__EncryptionOptions);
	if (this->soap_out(soap, tag?tag:"ns2:EncryptionOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EncryptionOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EncryptionOptions(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EncryptionOptions * SOAP_FMAC4 soap_get_ns2__EncryptionOptions(struct soap *soap, ns2__EncryptionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EncryptionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__EncryptionOptions * SOAP_FMAC2 soap_instantiate_ns2__EncryptionOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EncryptionOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__EncryptionOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__EncryptionOptions);
		if (size)
			*size = sizeof(ns2__EncryptionOptions);
		((ns2__EncryptionOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__EncryptionOptions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__EncryptionOptions);
		for (int i = 0; i < n; i++)
			((ns2__EncryptionOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__EncryptionOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__EncryptionOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__EncryptionOptions %p -> %p\n", q, p));
	*(ns2__EncryptionOptions*)p = *(ns2__EncryptionOptions*)q;
}

void ns2__ContentSchema::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__ContentSchema::schemaVersion = NULL;
	/* transient soap skipped */
}

void ns2__ContentSchema::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SchemaVersion(soap, &this->ns2__ContentSchema::schemaVersion);
	/* transient soap skipped */
}

int ns2__ContentSchema::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ContentSchema(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ContentSchema(struct soap *soap, const char *tag, int id, const ns2__ContentSchema *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ContentSchema), type))
		return soap->error;
	if (soap_out_PointerTons2__SchemaVersion(soap, "schemaVersion", -1, &(a->ns2__ContentSchema::schemaVersion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ContentSchema::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ContentSchema(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ContentSchema * SOAP_FMAC4 soap_in_ns2__ContentSchema(struct soap *soap, const char *tag, ns2__ContentSchema *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ContentSchema *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ContentSchema, sizeof(ns2__ContentSchema), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ContentSchema)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ContentSchema *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_schemaVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_schemaVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SchemaVersion(soap, "schemaVersion", &(a->ns2__ContentSchema::schemaVersion), "ns2:SchemaVersion"))
				{	soap_flag_schemaVersion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ContentSchema *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ContentSchema, 0, sizeof(ns2__ContentSchema), 0, soap_copy_ns2__ContentSchema);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_schemaVersion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ContentSchema::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ContentSchema);
	if (this->soap_out(soap, tag?tag:"ns2:ContentSchema", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ContentSchema::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ContentSchema(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ContentSchema * SOAP_FMAC4 soap_get_ns2__ContentSchema(struct soap *soap, ns2__ContentSchema *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ContentSchema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ContentSchema * SOAP_FMAC2 soap_instantiate_ns2__ContentSchema(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ContentSchema(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ContentSchema, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentSchema);
		if (size)
			*size = sizeof(ns2__ContentSchema);
		((ns2__ContentSchema*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__ContentSchema[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__ContentSchema);
		for (int i = 0; i < n; i++)
			((ns2__ContentSchema*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__ContentSchema*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ContentSchema(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ContentSchema %p -> %p\n", q, p));
	*(ns2__ContentSchema*)p = *(ns2__ContentSchema*)q;
}

void ns2__SchemaVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__SchemaVersion::version);
	/* transient soap skipped */
}

void ns2__SchemaVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__SchemaVersion::version, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__SchemaVersion::version);
	/* transient soap skipped */
}

int ns2__SchemaVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SchemaVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SchemaVersion(struct soap *soap, const char *tag, int id, const ns2__SchemaVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SchemaVersion), type))
		return soap->error;
	if (soap_out_std__string(soap, "version", -1, &(a->ns2__SchemaVersion::version), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SchemaVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SchemaVersion(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SchemaVersion * SOAP_FMAC4 soap_in_ns2__SchemaVersion(struct soap *soap, const char *tag, ns2__SchemaVersion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SchemaVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SchemaVersion, sizeof(ns2__SchemaVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SchemaVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SchemaVersion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_version1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "version", &(a->ns2__SchemaVersion::version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SchemaVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SchemaVersion, 0, sizeof(ns2__SchemaVersion), 0, soap_copy_ns2__SchemaVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_version1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SchemaVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SchemaVersion);
	if (this->soap_out(soap, tag?tag:"ns2:SchemaVersion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SchemaVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SchemaVersion(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SchemaVersion * SOAP_FMAC4 soap_get_ns2__SchemaVersion(struct soap *soap, ns2__SchemaVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SchemaVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SchemaVersion * SOAP_FMAC2 soap_instantiate_ns2__SchemaVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SchemaVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SchemaVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SchemaVersion);
		if (size)
			*size = sizeof(ns2__SchemaVersion);
		((ns2__SchemaVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__SchemaVersion[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__SchemaVersion);
		for (int i = 0; i < n; i++)
			((ns2__SchemaVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__SchemaVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SchemaVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SchemaVersion %p -> %p\n", q, p));
	*(ns2__SchemaVersion*)p = *(ns2__SchemaVersion*)q;
}

void ns2__CustomData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__CustomData::uuid);
	this->ns2__CustomData::__any = NULL;
	/* transient soap skipped */
}

void ns2__CustomData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__CustomData::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CustomData::uuid);
	/* transient soap skipped */
}

int ns2__CustomData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CustomData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CustomData(struct soap *soap, const char *tag, int id, const ns2__CustomData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CustomData), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns2__CustomData::uuid), ""))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->ns2__CustomData::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CustomData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CustomData(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CustomData * SOAP_FMAC4 soap_in_ns2__CustomData(struct soap *soap, const char *tag, ns2__CustomData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CustomData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CustomData, sizeof(ns2__CustomData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CustomData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CustomData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns2__CustomData::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->ns2__CustomData::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CustomData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CustomData, 0, sizeof(ns2__CustomData), 0, soap_copy_ns2__CustomData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CustomData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CustomData);
	if (this->soap_out(soap, tag?tag:"ns2:CustomData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CustomData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CustomData(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CustomData * SOAP_FMAC4 soap_get_ns2__CustomData(struct soap *soap, ns2__CustomData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CustomData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CustomData * SOAP_FMAC2 soap_instantiate_ns2__CustomData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CustomData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CustomData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CustomData);
		if (size)
			*size = sizeof(ns2__CustomData);
		((ns2__CustomData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CustomData[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CustomData);
		for (int i = 0; i < n; i++)
			((ns2__CustomData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CustomData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CustomData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CustomData %p -> %p\n", q, p));
	*(ns2__CustomData*)p = *(ns2__CustomData*)q;
}

void ns2__KeySetRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__KeySetRef::uuid);
	/* transient soap skipped */
}

void ns2__KeySetRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__KeySetRef::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__KeySetRef::uuid);
	/* transient soap skipped */
}

int ns2__KeySetRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__KeySetRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__KeySetRef(struct soap *soap, const char *tag, int id, const ns2__KeySetRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__KeySetRef), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns2__KeySetRef::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__KeySetRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__KeySetRef(soap, tag, this, type);
}

SOAP_FMAC3 ns2__KeySetRef * SOAP_FMAC4 soap_in_ns2__KeySetRef(struct soap *soap, const char *tag, ns2__KeySetRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__KeySetRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__KeySetRef, sizeof(ns2__KeySetRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__KeySetRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__KeySetRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns2__KeySetRef::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__KeySetRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__KeySetRef, 0, sizeof(ns2__KeySetRef), 0, soap_copy_ns2__KeySetRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__KeySetRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__KeySetRef);
	if (this->soap_out(soap, tag?tag:"ns2:KeySetRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__KeySetRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__KeySetRef(soap, this, tag, type);
}

SOAP_FMAC3 ns2__KeySetRef * SOAP_FMAC4 soap_get_ns2__KeySetRef(struct soap *soap, ns2__KeySetRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__KeySetRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__KeySetRef * SOAP_FMAC2 soap_instantiate_ns2__KeySetRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__KeySetRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__KeySetRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__KeySetRef);
		if (size)
			*size = sizeof(ns2__KeySetRef);
		((ns2__KeySetRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__KeySetRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__KeySetRef);
		for (int i = 0; i < n; i++)
			((ns2__KeySetRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__KeySetRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__KeySetRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__KeySetRef %p -> %p\n", q, p));
	*(ns2__KeySetRef*)p = *(ns2__KeySetRef*)q;
}

void ns2__KeySet::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__KeySet::uuid);
	this->ns2__KeySet::schema = NULL;
	soap_default_time(soap, &this->ns2__KeySet::creationTime);
	this->ns2__KeySet::extensions = NULL;
	/* transient soap skipped */
}

void ns2__KeySet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__KeySet::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__KeySet::uuid);
	soap_serialize_PointerTons2__CryptoSchemaRef(soap, &this->ns2__KeySet::schema);
	soap_embedded(soap, &this->ns2__KeySet::creationTime, SOAP_TYPE_time);
	soap_serialize_PointerTons2__KeySetExtensions(soap, &this->ns2__KeySet::extensions);
	/* transient soap skipped */
}

int ns2__KeySet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__KeySet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__KeySet(struct soap *soap, const char *tag, int id, const ns2__KeySet *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__KeySet), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns2__KeySet::uuid), ""))
		return soap->error;
	if (soap_out_PointerTons2__CryptoSchemaRef(soap, "schema", -1, &(a->ns2__KeySet::schema), ""))
		return soap->error;
	if (soap_out_time(soap, "creationTime", -1, &(a->ns2__KeySet::creationTime), ""))
		return soap->error;
	if (soap_out_PointerTons2__KeySetExtensions(soap, "extensions", -1, &(a->ns2__KeySet::extensions), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__KeySet::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__KeySet(soap, tag, this, type);
}

SOAP_FMAC3 ns2__KeySet * SOAP_FMAC4 soap_in_ns2__KeySet(struct soap *soap, const char *tag, ns2__KeySet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__KeySet *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__KeySet, sizeof(ns2__KeySet), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__KeySet)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__KeySet *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag_schema1 = 1;
	size_t soap_flag_creationTime1 = 1;
	size_t soap_flag_extensions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns2__KeySet::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap_flag_schema1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__CryptoSchemaRef(soap, "schema", &(a->ns2__KeySet::schema), "ns2:CryptoSchemaRef"))
				{	soap_flag_schema1--;
					continue;
				}
			if (soap_flag_creationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "creationTime", &(a->ns2__KeySet::creationTime), "xsd:dateTime"))
				{	soap_flag_creationTime1--;
					continue;
				}
			if (soap_flag_extensions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__KeySetExtensions(soap, "extensions", &(a->ns2__KeySet::extensions), "ns2:KeySetExtensions"))
				{	soap_flag_extensions1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__KeySet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__KeySet, 0, sizeof(ns2__KeySet), 0, soap_copy_ns2__KeySet);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0 || soap_flag_schema1 > 0 || soap_flag_creationTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__KeySet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__KeySet);
	if (this->soap_out(soap, tag?tag:"ns2:KeySet", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__KeySet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__KeySet(soap, this, tag, type);
}

SOAP_FMAC3 ns2__KeySet * SOAP_FMAC4 soap_get_ns2__KeySet(struct soap *soap, ns2__KeySet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__KeySet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__KeySet * SOAP_FMAC2 soap_instantiate_ns2__KeySet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__KeySet(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__KeySet, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__KeySet);
		if (size)
			*size = sizeof(ns2__KeySet);
		((ns2__KeySet*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__KeySet[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__KeySet);
		for (int i = 0; i < n; i++)
			((ns2__KeySet*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__KeySet*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__KeySet(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__KeySet %p -> %p\n", q, p));
	*(ns2__KeySet*)p = *(ns2__KeySet*)q;
}

void ns2__KeySetExtensions::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns2__KeySetExtensions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns2__KeySetExtensions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__KeySetExtensions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__KeySetExtensions(struct soap *soap, const char *tag, int id, const ns2__KeySetExtensions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__KeySetExtensions), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__KeySetExtensions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__KeySetExtensions(soap, tag, this, type);
}

SOAP_FMAC3 ns2__KeySetExtensions * SOAP_FMAC4 soap_in_ns2__KeySetExtensions(struct soap *soap, const char *tag, ns2__KeySetExtensions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__KeySetExtensions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__KeySetExtensions, sizeof(ns2__KeySetExtensions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__KeySetExtensions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__KeySetExtensions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__KeySetExtensions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__KeySetExtensions, 0, sizeof(ns2__KeySetExtensions), 0, soap_copy_ns2__KeySetExtensions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__KeySetExtensions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__KeySetExtensions);
	if (this->soap_out(soap, tag?tag:"ns2:KeySetExtensions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__KeySetExtensions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__KeySetExtensions(soap, this, tag, type);
}

SOAP_FMAC3 ns2__KeySetExtensions * SOAP_FMAC4 soap_get_ns2__KeySetExtensions(struct soap *soap, ns2__KeySetExtensions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__KeySetExtensions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__KeySetExtensions * SOAP_FMAC2 soap_instantiate_ns2__KeySetExtensions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__KeySetExtensions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__KeySetExtensions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:DesktopKeySetExtensions"))
	{	cp->type = SOAP_TYPE_ns1__DesktopKeySetExtensions;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__DesktopKeySetExtensions);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__DesktopKeySetExtensions);
			((ns1__DesktopKeySetExtensions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__DesktopKeySetExtensions[n]);
			if (size)
				*size = n * sizeof(ns1__DesktopKeySetExtensions);
			for (int i = 0; i < n; i++)
				((ns1__DesktopKeySetExtensions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__DesktopKeySetExtensions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:RawKeySetExtensions"))
	{	cp->type = SOAP_TYPE_ns2__RawKeySetExtensions;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__RawKeySetExtensions);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__RawKeySetExtensions);
			((ns2__RawKeySetExtensions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__RawKeySetExtensions[n]);
			if (size)
				*size = n * sizeof(ns2__RawKeySetExtensions);
			for (int i = 0; i < n; i++)
				((ns2__RawKeySetExtensions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__RawKeySetExtensions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:WrappedKeySetExtensions"))
	{	cp->type = SOAP_TYPE_ns2__WrappedKeySetExtensions;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns2__WrappedKeySetExtensions);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__WrappedKeySetExtensions);
			((ns2__WrappedKeySetExtensions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns2__WrappedKeySetExtensions[n]);
			if (size)
				*size = n * sizeof(ns2__WrappedKeySetExtensions);
			for (int i = 0; i < n; i++)
				((ns2__WrappedKeySetExtensions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__WrappedKeySetExtensions*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__KeySetExtensions);
		if (size)
			*size = sizeof(ns2__KeySetExtensions);
		((ns2__KeySetExtensions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__KeySetExtensions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__KeySetExtensions);
		for (int i = 0; i < n; i++)
			((ns2__KeySetExtensions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__KeySetExtensions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__KeySetExtensions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__KeySetExtensions %p -> %p\n", q, p));
	*(ns2__KeySetExtensions*)p = *(ns2__KeySetExtensions*)q;
}

void ns2__WrappedKeySetExtensions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__WrappedKeySetExtensions::alias);
	this->ns2__WrappedKeySetExtensions::encryptionKey.xsd__base64Binary::soap_default(soap);
	this->ns2__WrappedKeySetExtensions::signingKey.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void ns2__WrappedKeySetExtensions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__WrappedKeySetExtensions::alias, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__WrappedKeySetExtensions::alias);
	this->ns2__WrappedKeySetExtensions::encryptionKey.soap_serialize(soap);
	this->ns2__WrappedKeySetExtensions::signingKey.soap_serialize(soap);
	/* transient soap skipped */
}

int ns2__WrappedKeySetExtensions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__WrappedKeySetExtensions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__WrappedKeySetExtensions(struct soap *soap, const char *tag, int id, const ns2__WrappedKeySetExtensions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__WrappedKeySetExtensions), "ns2:WrappedKeySetExtensions"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "alias", -1, &(a->ns2__WrappedKeySetExtensions::alias), ""))
		return soap->error;
	if ((a->ns2__WrappedKeySetExtensions::encryptionKey).soap_out(soap, "encryptionKey", -1, ""))
		return soap->error;
	if ((a->ns2__WrappedKeySetExtensions::signingKey).soap_out(soap, "signingKey", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__WrappedKeySetExtensions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__WrappedKeySetExtensions(soap, tag, this, type);
}

SOAP_FMAC3 ns2__WrappedKeySetExtensions * SOAP_FMAC4 soap_in_ns2__WrappedKeySetExtensions(struct soap *soap, const char *tag, ns2__WrappedKeySetExtensions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__WrappedKeySetExtensions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__WrappedKeySetExtensions, sizeof(ns2__WrappedKeySetExtensions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__WrappedKeySetExtensions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__WrappedKeySetExtensions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_alias1 = 1;
	size_t soap_flag_encryptionKey1 = 1;
	size_t soap_flag_signingKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_alias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alias", &(a->ns2__WrappedKeySetExtensions::alias), "xsd:string"))
				{	soap_flag_alias1--;
					continue;
				}
			if (soap_flag_encryptionKey1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns2__WrappedKeySetExtensions::encryptionKey).soap_in(soap, "encryptionKey", "xsd:base64Binary"))
				{	soap_flag_encryptionKey1--;
					continue;
				}
			if (soap_flag_signingKey1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns2__WrappedKeySetExtensions::signingKey).soap_in(soap, "signingKey", "xsd:base64Binary"))
				{	soap_flag_signingKey1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__WrappedKeySetExtensions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__WrappedKeySetExtensions, 0, sizeof(ns2__WrappedKeySetExtensions), 0, soap_copy_ns2__WrappedKeySetExtensions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alias1 > 0 || soap_flag_encryptionKey1 > 0 || soap_flag_signingKey1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__WrappedKeySetExtensions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__WrappedKeySetExtensions);
	if (this->soap_out(soap, tag?tag:"ns2:WrappedKeySetExtensions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__WrappedKeySetExtensions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__WrappedKeySetExtensions(soap, this, tag, type);
}

SOAP_FMAC3 ns2__WrappedKeySetExtensions * SOAP_FMAC4 soap_get_ns2__WrappedKeySetExtensions(struct soap *soap, ns2__WrappedKeySetExtensions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__WrappedKeySetExtensions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__WrappedKeySetExtensions * SOAP_FMAC2 soap_instantiate_ns2__WrappedKeySetExtensions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__WrappedKeySetExtensions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__WrappedKeySetExtensions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__WrappedKeySetExtensions);
		if (size)
			*size = sizeof(ns2__WrappedKeySetExtensions);
		((ns2__WrappedKeySetExtensions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__WrappedKeySetExtensions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__WrappedKeySetExtensions);
		for (int i = 0; i < n; i++)
			((ns2__WrappedKeySetExtensions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__WrappedKeySetExtensions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__WrappedKeySetExtensions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__WrappedKeySetExtensions %p -> %p\n", q, p));
	*(ns2__WrappedKeySetExtensions*)p = *(ns2__WrappedKeySetExtensions*)q;
}

void ns2__RawKeySetExtensions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RawKeySetExtensions::encryptionKey.xsd__base64Binary::soap_default(soap);
	this->ns2__RawKeySetExtensions::signingKey.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void ns2__RawKeySetExtensions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	this->ns2__RawKeySetExtensions::encryptionKey.soap_serialize(soap);
	this->ns2__RawKeySetExtensions::signingKey.soap_serialize(soap);
	/* transient soap skipped */
}

int ns2__RawKeySetExtensions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RawKeySetExtensions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RawKeySetExtensions(struct soap *soap, const char *tag, int id, const ns2__RawKeySetExtensions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RawKeySetExtensions), "ns2:RawKeySetExtensions"))
		return soap->error;
	/* transient soap skipped */
	if ((a->ns2__RawKeySetExtensions::encryptionKey).soap_out(soap, "encryptionKey", -1, ""))
		return soap->error;
	if ((a->ns2__RawKeySetExtensions::signingKey).soap_out(soap, "signingKey", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__RawKeySetExtensions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RawKeySetExtensions(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RawKeySetExtensions * SOAP_FMAC4 soap_in_ns2__RawKeySetExtensions(struct soap *soap, const char *tag, ns2__RawKeySetExtensions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RawKeySetExtensions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RawKeySetExtensions, sizeof(ns2__RawKeySetExtensions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RawKeySetExtensions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RawKeySetExtensions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_encryptionKey1 = 1;
	size_t soap_flag_signingKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_encryptionKey1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns2__RawKeySetExtensions::encryptionKey).soap_in(soap, "encryptionKey", "xsd:base64Binary"))
				{	soap_flag_encryptionKey1--;
					continue;
				}
			if (soap_flag_signingKey1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns2__RawKeySetExtensions::signingKey).soap_in(soap, "signingKey", "xsd:base64Binary"))
				{	soap_flag_signingKey1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RawKeySetExtensions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RawKeySetExtensions, 0, sizeof(ns2__RawKeySetExtensions), 0, soap_copy_ns2__RawKeySetExtensions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_encryptionKey1 > 0 || soap_flag_signingKey1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RawKeySetExtensions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RawKeySetExtensions);
	if (this->soap_out(soap, tag?tag:"ns2:RawKeySetExtensions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RawKeySetExtensions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RawKeySetExtensions(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RawKeySetExtensions * SOAP_FMAC4 soap_get_ns2__RawKeySetExtensions(struct soap *soap, ns2__RawKeySetExtensions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RawKeySetExtensions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RawKeySetExtensions * SOAP_FMAC2 soap_instantiate_ns2__RawKeySetExtensions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RawKeySetExtensions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RawKeySetExtensions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RawKeySetExtensions);
		if (size)
			*size = sizeof(ns2__RawKeySetExtensions);
		((ns2__RawKeySetExtensions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__RawKeySetExtensions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__RawKeySetExtensions);
		for (int i = 0; i < n; i++)
			((ns2__RawKeySetExtensions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__RawKeySetExtensions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RawKeySetExtensions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RawKeySetExtensions %p -> %p\n", q, p));
	*(ns2__RawKeySetExtensions*)p = *(ns2__RawKeySetExtensions*)q;
}

void ns2__CryptoSchemaRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__CryptoSchemaRef::id);
	/* transient soap skipped */
}

void ns2__CryptoSchemaRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__CryptoSchemaRef::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CryptoSchemaRef::id);
	/* transient soap skipped */
}

int ns2__CryptoSchemaRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CryptoSchemaRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CryptoSchemaRef(struct soap *soap, const char *tag, int id, const ns2__CryptoSchemaRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CryptoSchemaRef), type))
		return soap->error;
	if (soap_out_std__string(soap, "id", -1, &(a->ns2__CryptoSchemaRef::id), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CryptoSchemaRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CryptoSchemaRef(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CryptoSchemaRef * SOAP_FMAC4 soap_in_ns2__CryptoSchemaRef(struct soap *soap, const char *tag, ns2__CryptoSchemaRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CryptoSchemaRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CryptoSchemaRef, sizeof(ns2__CryptoSchemaRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CryptoSchemaRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CryptoSchemaRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "id", &(a->ns2__CryptoSchemaRef::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CryptoSchemaRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CryptoSchemaRef, 0, sizeof(ns2__CryptoSchemaRef), 0, soap_copy_ns2__CryptoSchemaRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CryptoSchemaRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CryptoSchemaRef);
	if (this->soap_out(soap, tag?tag:"ns2:CryptoSchemaRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CryptoSchemaRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CryptoSchemaRef(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CryptoSchemaRef * SOAP_FMAC4 soap_get_ns2__CryptoSchemaRef(struct soap *soap, ns2__CryptoSchemaRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CryptoSchemaRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CryptoSchemaRef * SOAP_FMAC2 soap_instantiate_ns2__CryptoSchemaRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CryptoSchemaRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CryptoSchemaRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CryptoSchemaRef);
		if (size)
			*size = sizeof(ns2__CryptoSchemaRef);
		((ns2__CryptoSchemaRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CryptoSchemaRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CryptoSchemaRef);
		for (int i = 0; i < n; i++)
			((ns2__CryptoSchemaRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CryptoSchemaRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CryptoSchemaRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CryptoSchemaRef %p -> %p\n", q, p));
	*(ns2__CryptoSchemaRef*)p = *(ns2__CryptoSchemaRef*)q;
}

void ns2__CryptoSchema::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns2__CryptoSchema::id);
	soap_default_std__string(soap, &this->ns2__CryptoSchema::encryptionTransformation);
	soap_default_int(soap, &this->ns2__CryptoSchema::encryptionKeySize);
	soap_default_std__string(soap, &this->ns2__CryptoSchema::hmacSigningAlgorithm);
	soap_default_int(soap, &this->ns2__CryptoSchema::hmacSigningKeySize);
	soap_default_std__string(soap, &this->ns2__CryptoSchema::digestAlgorithm);
	soap_default_std__string(soap, &this->ns2__CryptoSchema::sessionKeyEncryptionTransformation);
	soap_default_int(soap, &this->ns2__CryptoSchema::sessionKeyEncryptionKeySize);
	soap_default_bool(soap, &this->ns2__CryptoSchema::useFips);
	/* transient soap skipped */
}

void ns2__CryptoSchema::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns2__CryptoSchema::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CryptoSchema::id);
	soap_embedded(soap, &this->ns2__CryptoSchema::encryptionTransformation, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CryptoSchema::encryptionTransformation);
	soap_embedded(soap, &this->ns2__CryptoSchema::hmacSigningAlgorithm, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CryptoSchema::hmacSigningAlgorithm);
	soap_embedded(soap, &this->ns2__CryptoSchema::digestAlgorithm, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CryptoSchema::digestAlgorithm);
	soap_embedded(soap, &this->ns2__CryptoSchema::sessionKeyEncryptionTransformation, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns2__CryptoSchema::sessionKeyEncryptionTransformation);
	/* transient soap skipped */
}

int ns2__CryptoSchema::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__CryptoSchema(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CryptoSchema(struct soap *soap, const char *tag, int id, const ns2__CryptoSchema *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CryptoSchema), type))
		return soap->error;
	if (soap_out_std__string(soap, "id", -1, &(a->ns2__CryptoSchema::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "encryptionTransformation", -1, &(a->ns2__CryptoSchema::encryptionTransformation), ""))
		return soap->error;
	if (soap_out_int(soap, "encryptionKeySize", -1, &(a->ns2__CryptoSchema::encryptionKeySize), ""))
		return soap->error;
	if (soap_out_std__string(soap, "hmacSigningAlgorithm", -1, &(a->ns2__CryptoSchema::hmacSigningAlgorithm), ""))
		return soap->error;
	if (soap_out_int(soap, "hmacSigningKeySize", -1, &(a->ns2__CryptoSchema::hmacSigningKeySize), ""))
		return soap->error;
	if (soap_out_std__string(soap, "digestAlgorithm", -1, &(a->ns2__CryptoSchema::digestAlgorithm), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sessionKeyEncryptionTransformation", -1, &(a->ns2__CryptoSchema::sessionKeyEncryptionTransformation), ""))
		return soap->error;
	if (soap_out_int(soap, "sessionKeyEncryptionKeySize", -1, &(a->ns2__CryptoSchema::sessionKeyEncryptionKeySize), ""))
		return soap->error;
	if (soap_out_bool(soap, "useFips", -1, &(a->ns2__CryptoSchema::useFips), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__CryptoSchema::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__CryptoSchema(soap, tag, this, type);
}

SOAP_FMAC3 ns2__CryptoSchema * SOAP_FMAC4 soap_in_ns2__CryptoSchema(struct soap *soap, const char *tag, ns2__CryptoSchema *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__CryptoSchema *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CryptoSchema, sizeof(ns2__CryptoSchema), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__CryptoSchema)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__CryptoSchema *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_encryptionTransformation1 = 1;
	size_t soap_flag_encryptionKeySize1 = 1;
	size_t soap_flag_hmacSigningAlgorithm1 = 1;
	size_t soap_flag_hmacSigningKeySize1 = 1;
	size_t soap_flag_digestAlgorithm1 = 1;
	size_t soap_flag_sessionKeyEncryptionTransformation1 = 1;
	size_t soap_flag_sessionKeyEncryptionKeySize1 = 1;
	size_t soap_flag_useFips1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "id", &(a->ns2__CryptoSchema::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_encryptionTransformation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "encryptionTransformation", &(a->ns2__CryptoSchema::encryptionTransformation), "xsd:string"))
				{	soap_flag_encryptionTransformation1--;
					continue;
				}
			if (soap_flag_encryptionKeySize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "encryptionKeySize", &(a->ns2__CryptoSchema::encryptionKeySize), "xsd:int"))
				{	soap_flag_encryptionKeySize1--;
					continue;
				}
			if (soap_flag_hmacSigningAlgorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "hmacSigningAlgorithm", &(a->ns2__CryptoSchema::hmacSigningAlgorithm), "xsd:string"))
				{	soap_flag_hmacSigningAlgorithm1--;
					continue;
				}
			if (soap_flag_hmacSigningKeySize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "hmacSigningKeySize", &(a->ns2__CryptoSchema::hmacSigningKeySize), "xsd:int"))
				{	soap_flag_hmacSigningKeySize1--;
					continue;
				}
			if (soap_flag_digestAlgorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "digestAlgorithm", &(a->ns2__CryptoSchema::digestAlgorithm), "xsd:string"))
				{	soap_flag_digestAlgorithm1--;
					continue;
				}
			if (soap_flag_sessionKeyEncryptionTransformation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sessionKeyEncryptionTransformation", &(a->ns2__CryptoSchema::sessionKeyEncryptionTransformation), "xsd:string"))
				{	soap_flag_sessionKeyEncryptionTransformation1--;
					continue;
				}
			if (soap_flag_sessionKeyEncryptionKeySize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sessionKeyEncryptionKeySize", &(a->ns2__CryptoSchema::sessionKeyEncryptionKeySize), "xsd:int"))
				{	soap_flag_sessionKeyEncryptionKeySize1--;
					continue;
				}
			if (soap_flag_useFips1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "useFips", &(a->ns2__CryptoSchema::useFips), "xsd:boolean"))
				{	soap_flag_useFips1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__CryptoSchema *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CryptoSchema, 0, sizeof(ns2__CryptoSchema), 0, soap_copy_ns2__CryptoSchema);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_encryptionTransformation1 > 0 || soap_flag_encryptionKeySize1 > 0 || soap_flag_hmacSigningAlgorithm1 > 0 || soap_flag_hmacSigningKeySize1 > 0 || soap_flag_digestAlgorithm1 > 0 || soap_flag_sessionKeyEncryptionTransformation1 > 0 || soap_flag_sessionKeyEncryptionKeySize1 > 0 || soap_flag_useFips1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__CryptoSchema::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__CryptoSchema);
	if (this->soap_out(soap, tag?tag:"ns2:CryptoSchema", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__CryptoSchema::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__CryptoSchema(soap, this, tag, type);
}

SOAP_FMAC3 ns2__CryptoSchema * SOAP_FMAC4 soap_get_ns2__CryptoSchema(struct soap *soap, ns2__CryptoSchema *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CryptoSchema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__CryptoSchema * SOAP_FMAC2 soap_instantiate_ns2__CryptoSchema(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CryptoSchema(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CryptoSchema, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__CryptoSchema);
		if (size)
			*size = sizeof(ns2__CryptoSchema);
		((ns2__CryptoSchema*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns2__CryptoSchema[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__CryptoSchema);
		for (int i = 0; i < n; i++)
			((ns2__CryptoSchema*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__CryptoSchema*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CryptoSchema(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__CryptoSchema %p -> %p\n", q, p));
	*(ns2__CryptoSchema*)p = *(ns2__CryptoSchema*)q;
}

void ns1__PageRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__PageRange::first);
	soap_default_int(soap, &this->ns1__PageRange::last);
	/* transient soap skipped */
}

void ns1__PageRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__PageRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PageRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PageRange(struct soap *soap, const char *tag, int id, const ns1__PageRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PageRange), type))
		return soap->error;
	if (soap_out_int(soap, "first", -1, &(a->ns1__PageRange::first), ""))
		return soap->error;
	if (soap_out_int(soap, "last", -1, &(a->ns1__PageRange::last), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PageRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PageRange(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PageRange * SOAP_FMAC4 soap_in_ns1__PageRange(struct soap *soap, const char *tag, ns1__PageRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PageRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PageRange, sizeof(ns1__PageRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PageRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PageRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_first1 = 1;
	size_t soap_flag_last1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_first1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "first", &(a->ns1__PageRange::first), "xsd:int"))
				{	soap_flag_first1--;
					continue;
				}
			if (soap_flag_last1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "last", &(a->ns1__PageRange::last), "xsd:int"))
				{	soap_flag_last1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PageRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PageRange, 0, sizeof(ns1__PageRange), 0, soap_copy_ns1__PageRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_first1 > 0 || soap_flag_last1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__PageRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PageRange);
	if (this->soap_out(soap, tag?tag:"ns1:PageRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PageRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PageRange(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PageRange * SOAP_FMAC4 soap_get_ns1__PageRange(struct soap *soap, ns1__PageRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PageRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PageRange * SOAP_FMAC2 soap_instantiate_ns1__PageRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PageRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PageRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PageRange);
		if (size)
			*size = sizeof(ns1__PageRange);
		((ns1__PageRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__PageRange[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PageRange);
		for (int i = 0; i < n; i++)
			((ns1__PageRange*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PageRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PageRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PageRange %p -> %p\n", q, p));
	*(ns1__PageRange*)p = *(ns1__PageRange*)q;
}

void ns1__AccountRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__AccountRef::uuid);
	/* transient soap skipped */
}

void ns1__AccountRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__AccountRef::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__AccountRef::uuid);
	/* transient soap skipped */
}

int ns1__AccountRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AccountRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccountRef(struct soap *soap, const char *tag, int id, const ns1__AccountRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccountRef), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns1__AccountRef::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__AccountRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AccountRef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AccountRef * SOAP_FMAC4 soap_in_ns1__AccountRef(struct soap *soap, const char *tag, ns1__AccountRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AccountRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccountRef, sizeof(ns1__AccountRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AccountRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AccountRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns1__AccountRef::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AccountRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccountRef, 0, sizeof(ns1__AccountRef), 0, soap_copy_ns1__AccountRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AccountRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AccountRef);
	if (this->soap_out(soap, tag?tag:"ns1:AccountRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AccountRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AccountRef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AccountRef * SOAP_FMAC4 soap_get_ns1__AccountRef(struct soap *soap, ns1__AccountRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccountRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AccountRef * SOAP_FMAC2 soap_instantiate_ns1__AccountRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AccountRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AccountRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AccountRef);
		if (size)
			*size = sizeof(ns1__AccountRef);
		((ns1__AccountRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__AccountRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AccountRef);
		for (int i = 0; i < n; i++)
			((ns1__AccountRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AccountRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AccountRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AccountRef %p -> %p\n", q, p));
	*(ns1__AccountRef*)p = *(ns1__AccountRef*)q;
}

void ns1__Account::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Account::uuid);
	soap_default_std__string(soap, &this->ns1__Account::name);
	soap_default_ns1__Account_USCOREType(soap, &this->ns1__Account::type);
	/* transient soap skipped */
}

void ns1__Account::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Account::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Account::uuid);
	soap_embedded(soap, &this->ns1__Account::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Account::name);
	/* transient soap skipped */
}

int ns1__Account::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Account(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Account(struct soap *soap, const char *tag, int id, const ns1__Account *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Account), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns1__Account::uuid), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__Account::name), ""))
		return soap->error;
	if (soap_out_ns1__Account_USCOREType(soap, "type", -1, &(a->ns1__Account::type), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Account::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Account(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Account * SOAP_FMAC4 soap_in_ns1__Account(struct soap *soap, const char *tag, ns1__Account *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Account *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Account, sizeof(ns1__Account), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Account)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Account *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns1__Account::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__Account::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__Account_USCOREType(soap, "type", &(a->ns1__Account::type), "ns1:Account_Type"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Account *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Account, 0, sizeof(ns1__Account), 0, soap_copy_ns1__Account);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0 || soap_flag_name1 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Account::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Account);
	if (this->soap_out(soap, tag?tag:"ns1:Account", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Account::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Account(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Account * SOAP_FMAC4 soap_get_ns1__Account(struct soap *soap, ns1__Account *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Account(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Account * SOAP_FMAC2 soap_instantiate_ns1__Account(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Account(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Account, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Account);
		if (size)
			*size = sizeof(ns1__Account);
		((ns1__Account*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Account[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Account);
		for (int i = 0; i < n; i++)
			((ns1__Account*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Account*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Account(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Account %p -> %p\n", q, p));
	*(ns1__Account*)p = *(ns1__Account*)q;
}

void ns1__XPathExpression::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__QName(soap, &this->ns1__XPathExpression::namespaceContexts);
	soap_default_std__string(soap, &this->ns1__XPathExpression::value);
	/* transient soap skipped */
}

void ns1__XPathExpression::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &this->ns1__XPathExpression::namespaceContexts);
	soap_embedded(soap, &this->ns1__XPathExpression::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__XPathExpression::value);
	/* transient soap skipped */
}

int ns1__XPathExpression::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__XPathExpression(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__XPathExpression(struct soap *soap, const char *tag, int id, const ns1__XPathExpression *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__XPathExpression), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__QName(soap, "namespaceContexts", -1, &(a->ns1__XPathExpression::namespaceContexts), ""))
		return soap->error;
	if (soap_out_std__string(soap, "value", -1, &(a->ns1__XPathExpression::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__XPathExpression::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__XPathExpression(soap, tag, this, type);
}

SOAP_FMAC3 ns1__XPathExpression * SOAP_FMAC4 soap_in_ns1__XPathExpression(struct soap *soap, const char *tag, ns1__XPathExpression *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__XPathExpression *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__XPathExpression, sizeof(ns1__XPathExpression), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__XPathExpression)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__XPathExpression *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "namespaceContexts", &(a->ns1__XPathExpression::namespaceContexts), "xsd:QName"))
					continue;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "value", &(a->ns1__XPathExpression::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__XPathExpression *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__XPathExpression, 0, sizeof(ns1__XPathExpression), 0, soap_copy_ns1__XPathExpression);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__XPathExpression::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__XPathExpression);
	if (this->soap_out(soap, tag?tag:"ns1:XPathExpression", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__XPathExpression::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__XPathExpression(soap, this, tag, type);
}

SOAP_FMAC3 ns1__XPathExpression * SOAP_FMAC4 soap_get_ns1__XPathExpression(struct soap *soap, ns1__XPathExpression *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__XPathExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__XPathExpression * SOAP_FMAC2 soap_instantiate_ns1__XPathExpression(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__XPathExpression(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__XPathExpression, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__XPathExpression);
		if (size)
			*size = sizeof(ns1__XPathExpression);
		((ns1__XPathExpression*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__XPathExpression[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__XPathExpression);
		for (int i = 0; i < n; i++)
			((ns1__XPathExpression*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__XPathExpression*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__XPathExpression(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__XPathExpression %p -> %p\n", q, p));
	*(ns1__XPathExpression*)p = *(ns1__XPathExpression*)q;
}

void ns1__XPathClassificationFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__XPathClassificationFilter::expression = NULL;
	this->ns1__ClassificationFilter::system = NULL;
	soap_default_xsd__anyURI(soap, &this->ns1__ClassificationFilter::uri);
	this->ns1__ClassificationFilter::index = NULL;
	/* transient soap skipped */
}

void ns1__XPathClassificationFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__XPathExpression(soap, &this->ns1__XPathClassificationFilter::expression);
	soap_serialize_PointerTons1__ClassificationSystemRef(soap, &this->ns1__ClassificationFilter::system);
	soap_serialize_xsd__anyURI(soap, &this->ns1__ClassificationFilter::uri);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ClassificationFilter::index);
	/* transient soap skipped */
}

int ns1__XPathClassificationFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__XPathClassificationFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__XPathClassificationFilter(struct soap *soap, const char *tag, int id, const ns1__XPathClassificationFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__XPathClassificationFilter), "ns1:XPathClassificationFilter"))
		return soap->error;
	if (soap_out_PointerTons1__ClassificationSystemRef(soap, "system", -1, &(a->ns1__ClassificationFilter::system), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "uri", -1, &(a->ns1__ClassificationFilter::uri), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "index", -1, &(a->ns1__ClassificationFilter::index), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTons1__XPathExpression(soap, "expression", -1, &(a->ns1__XPathClassificationFilter::expression), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__XPathClassificationFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__XPathClassificationFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__XPathClassificationFilter * SOAP_FMAC4 soap_in_ns1__XPathClassificationFilter(struct soap *soap, const char *tag, ns1__XPathClassificationFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__XPathClassificationFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__XPathClassificationFilter, sizeof(ns1__XPathClassificationFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__XPathClassificationFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__XPathClassificationFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_system2 = 1;
	size_t soap_flag_uri2 = 1;
	size_t soap_flag_index2 = 1;
	size_t soap_flag_expression1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_system2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ClassificationSystemRef(soap, "system", &(a->ns1__ClassificationFilter::system), "ns1:ClassificationSystemRef"))
				{	soap_flag_system2--;
					continue;
				}
			if (soap_flag_uri2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "uri", &(a->ns1__ClassificationFilter::uri), "xsd:anyURI"))
				{	soap_flag_uri2--;
					continue;
				}
			if (soap_flag_index2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "index", &(a->ns1__ClassificationFilter::index), "xsd:string"))
				{	soap_flag_index2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_expression1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__XPathExpression(soap, "expression", &(a->ns1__XPathClassificationFilter::expression), "ns1:XPathExpression"))
				{	soap_flag_expression1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__XPathClassificationFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__XPathClassificationFilter, 0, sizeof(ns1__XPathClassificationFilter), 0, soap_copy_ns1__XPathClassificationFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_system2 > 0 || soap_flag_uri2 > 0 || soap_flag_expression1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__XPathClassificationFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__XPathClassificationFilter);
	if (this->soap_out(soap, tag?tag:"ns1:XPathClassificationFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__XPathClassificationFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__XPathClassificationFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__XPathClassificationFilter * SOAP_FMAC4 soap_get_ns1__XPathClassificationFilter(struct soap *soap, ns1__XPathClassificationFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__XPathClassificationFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__XPathClassificationFilter * SOAP_FMAC2 soap_instantiate_ns1__XPathClassificationFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__XPathClassificationFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__XPathClassificationFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__XPathClassificationFilter);
		if (size)
			*size = sizeof(ns1__XPathClassificationFilter);
		((ns1__XPathClassificationFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__XPathClassificationFilter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__XPathClassificationFilter);
		for (int i = 0; i < n; i++)
			((ns1__XPathClassificationFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__XPathClassificationFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__XPathClassificationFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__XPathClassificationFilter %p -> %p\n", q, p));
	*(ns1__XPathClassificationFilter*)p = *(ns1__XPathClassificationFilter*)q;
}

void ns1__AbsoluteTimeSpan::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__AbsoluteTimeSpan::startTime = NULL;
	this->ns1__AbsoluteTimeSpan::stopTime = NULL;
	soap_default_ns1__TimeSpan_USCOREReferencePoint(soap, &this->ns1__TimeSpan::referencePoint);
	/* transient soap skipped */
}

void ns1__AbsoluteTimeSpan::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__AbsoluteTimeSpan::startTime);
	soap_serialize_PointerTotime(soap, &this->ns1__AbsoluteTimeSpan::stopTime);
	/* transient soap skipped */
}

int ns1__AbsoluteTimeSpan::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AbsoluteTimeSpan(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AbsoluteTimeSpan(struct soap *soap, const char *tag, int id, const ns1__AbsoluteTimeSpan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AbsoluteTimeSpan), "ns1:AbsoluteTimeSpan"))
		return soap->error;
	if (soap_out_ns1__TimeSpan_USCOREReferencePoint(soap, "referencePoint", -1, &(a->ns1__TimeSpan::referencePoint), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns1__AbsoluteTimeSpan::startTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "stopTime", -1, &(a->ns1__AbsoluteTimeSpan::stopTime), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__AbsoluteTimeSpan::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AbsoluteTimeSpan(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AbsoluteTimeSpan * SOAP_FMAC4 soap_in_ns1__AbsoluteTimeSpan(struct soap *soap, const char *tag, ns1__AbsoluteTimeSpan *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AbsoluteTimeSpan *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AbsoluteTimeSpan, sizeof(ns1__AbsoluteTimeSpan), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AbsoluteTimeSpan)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AbsoluteTimeSpan *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_referencePoint2 = 1;
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_stopTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_referencePoint2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__TimeSpan_USCOREReferencePoint(soap, "referencePoint", &(a->ns1__TimeSpan::referencePoint), "ns1:TimeSpan_ReferencePoint"))
				{	soap_flag_referencePoint2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns1__AbsoluteTimeSpan::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_stopTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "stopTime", &(a->ns1__AbsoluteTimeSpan::stopTime), "xsd:dateTime"))
				{	soap_flag_stopTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AbsoluteTimeSpan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AbsoluteTimeSpan, 0, sizeof(ns1__AbsoluteTimeSpan), 0, soap_copy_ns1__AbsoluteTimeSpan);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_referencePoint2 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__AbsoluteTimeSpan::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AbsoluteTimeSpan);
	if (this->soap_out(soap, tag?tag:"ns1:AbsoluteTimeSpan", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__AbsoluteTimeSpan::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AbsoluteTimeSpan(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AbsoluteTimeSpan * SOAP_FMAC4 soap_get_ns1__AbsoluteTimeSpan(struct soap *soap, ns1__AbsoluteTimeSpan *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AbsoluteTimeSpan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__AbsoluteTimeSpan * SOAP_FMAC2 soap_instantiate_ns1__AbsoluteTimeSpan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AbsoluteTimeSpan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AbsoluteTimeSpan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__AbsoluteTimeSpan);
		if (size)
			*size = sizeof(ns1__AbsoluteTimeSpan);
		((ns1__AbsoluteTimeSpan*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__AbsoluteTimeSpan[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AbsoluteTimeSpan);
		for (int i = 0; i < n; i++)
			((ns1__AbsoluteTimeSpan*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AbsoluteTimeSpan*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AbsoluteTimeSpan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AbsoluteTimeSpan %p -> %p\n", q, p));
	*(ns1__AbsoluteTimeSpan*)p = *(ns1__AbsoluteTimeSpan*)q;
}

void ns1__RelativeTimeSpan::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__RelativeTimeSpan_USCORETimeBase(soap, &this->ns1__RelativeTimeSpan::timeBase);
	this->ns1__RelativeTimeSpan::startTime = NULL;
	this->ns1__RelativeTimeSpan::stopTime = NULL;
	soap_default_ns1__TimeSpan_USCOREReferencePoint(soap, &this->ns1__TimeSpan::referencePoint);
	/* transient soap skipped */
}

void ns1__RelativeTimeSpan::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TimePeriod(soap, &this->ns1__RelativeTimeSpan::startTime);
	soap_serialize_PointerTons1__TimePeriod(soap, &this->ns1__RelativeTimeSpan::stopTime);
	/* transient soap skipped */
}

int ns1__RelativeTimeSpan::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RelativeTimeSpan(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RelativeTimeSpan(struct soap *soap, const char *tag, int id, const ns1__RelativeTimeSpan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RelativeTimeSpan), "ns1:RelativeTimeSpan"))
		return soap->error;
	if (soap_out_ns1__TimeSpan_USCOREReferencePoint(soap, "referencePoint", -1, &(a->ns1__TimeSpan::referencePoint), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_ns1__RelativeTimeSpan_USCORETimeBase(soap, "timeBase", -1, &(a->ns1__RelativeTimeSpan::timeBase), ""))
		return soap->error;
	if (soap_out_PointerTons1__TimePeriod(soap, "startTime", -1, &(a->ns1__RelativeTimeSpan::startTime), ""))
		return soap->error;
	if (soap_out_PointerTons1__TimePeriod(soap, "stopTime", -1, &(a->ns1__RelativeTimeSpan::stopTime), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__RelativeTimeSpan::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RelativeTimeSpan(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RelativeTimeSpan * SOAP_FMAC4 soap_in_ns1__RelativeTimeSpan(struct soap *soap, const char *tag, ns1__RelativeTimeSpan *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RelativeTimeSpan *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RelativeTimeSpan, sizeof(ns1__RelativeTimeSpan), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RelativeTimeSpan)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RelativeTimeSpan *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_referencePoint2 = 1;
	size_t soap_flag_timeBase1 = 1;
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_stopTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_referencePoint2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__TimeSpan_USCOREReferencePoint(soap, "referencePoint", &(a->ns1__TimeSpan::referencePoint), "ns1:TimeSpan_ReferencePoint"))
				{	soap_flag_referencePoint2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_timeBase1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__RelativeTimeSpan_USCORETimeBase(soap, "timeBase", &(a->ns1__RelativeTimeSpan::timeBase), "ns1:RelativeTimeSpan_TimeBase"))
				{	soap_flag_timeBase1--;
					continue;
				}
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TimePeriod(soap, "startTime", &(a->ns1__RelativeTimeSpan::startTime), "ns1:TimePeriod"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_stopTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TimePeriod(soap, "stopTime", &(a->ns1__RelativeTimeSpan::stopTime), "ns1:TimePeriod"))
				{	soap_flag_stopTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RelativeTimeSpan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RelativeTimeSpan, 0, sizeof(ns1__RelativeTimeSpan), 0, soap_copy_ns1__RelativeTimeSpan);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_referencePoint2 > 0 || soap_flag_timeBase1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__RelativeTimeSpan::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__RelativeTimeSpan);
	if (this->soap_out(soap, tag?tag:"ns1:RelativeTimeSpan", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__RelativeTimeSpan::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RelativeTimeSpan(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RelativeTimeSpan * SOAP_FMAC4 soap_get_ns1__RelativeTimeSpan(struct soap *soap, ns1__RelativeTimeSpan *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RelativeTimeSpan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__RelativeTimeSpan * SOAP_FMAC2 soap_instantiate_ns1__RelativeTimeSpan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RelativeTimeSpan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RelativeTimeSpan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__RelativeTimeSpan);
		if (size)
			*size = sizeof(ns1__RelativeTimeSpan);
		((ns1__RelativeTimeSpan*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__RelativeTimeSpan[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__RelativeTimeSpan);
		for (int i = 0; i < n; i++)
			((ns1__RelativeTimeSpan*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__RelativeTimeSpan*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RelativeTimeSpan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RelativeTimeSpan %p -> %p\n", q, p));
	*(ns1__RelativeTimeSpan*)p = *(ns1__RelativeTimeSpan*)q;
}

void ns1__ClassificationFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ClassificationFilter::system = NULL;
	soap_default_xsd__anyURI(soap, &this->ns1__ClassificationFilter::uri);
	this->ns1__ClassificationFilter::index = NULL;
	/* transient soap skipped */
}

void ns1__ClassificationFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ClassificationSystemRef(soap, &this->ns1__ClassificationFilter::system);
	soap_serialize_xsd__anyURI(soap, &this->ns1__ClassificationFilter::uri);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ClassificationFilter::index);
	/* transient soap skipped */
}

int ns1__ClassificationFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ClassificationFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClassificationFilter(struct soap *soap, const char *tag, int id, const ns1__ClassificationFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClassificationFilter), type))
		return soap->error;
	if (soap_out_PointerTons1__ClassificationSystemRef(soap, "system", -1, &(a->ns1__ClassificationFilter::system), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "uri", -1, &(a->ns1__ClassificationFilter::uri), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "index", -1, &(a->ns1__ClassificationFilter::index), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ClassificationFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ClassificationFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ClassificationFilter * SOAP_FMAC4 soap_in_ns1__ClassificationFilter(struct soap *soap, const char *tag, ns1__ClassificationFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ClassificationFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClassificationFilter, sizeof(ns1__ClassificationFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ClassificationFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ClassificationFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_system1 = 1;
	size_t soap_flag_uri1 = 1;
	size_t soap_flag_index1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_system1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ClassificationSystemRef(soap, "system", &(a->ns1__ClassificationFilter::system), "ns1:ClassificationSystemRef"))
				{	soap_flag_system1--;
					continue;
				}
			if (soap_flag_uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "uri", &(a->ns1__ClassificationFilter::uri), "xsd:anyURI"))
				{	soap_flag_uri1--;
					continue;
				}
			if (soap_flag_index1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "index", &(a->ns1__ClassificationFilter::index), "xsd:string"))
				{	soap_flag_index1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ClassificationFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClassificationFilter, 0, sizeof(ns1__ClassificationFilter), 0, soap_copy_ns1__ClassificationFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_system1 > 0 || soap_flag_uri1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ClassificationFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ClassificationFilter);
	if (this->soap_out(soap, tag?tag:"ns1:ClassificationFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ClassificationFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ClassificationFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ClassificationFilter * SOAP_FMAC4 soap_get_ns1__ClassificationFilter(struct soap *soap, ns1__ClassificationFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClassificationFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ClassificationFilter * SOAP_FMAC2 soap_instantiate_ns1__ClassificationFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClassificationFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ClassificationFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:XPathClassificationFilter"))
	{	cp->type = SOAP_TYPE_ns1__XPathClassificationFilter;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__XPathClassificationFilter);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__XPathClassificationFilter);
			((ns1__XPathClassificationFilter*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__XPathClassificationFilter[n]);
			if (size)
				*size = n * sizeof(ns1__XPathClassificationFilter);
			for (int i = 0; i < n; i++)
				((ns1__XPathClassificationFilter*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__XPathClassificationFilter*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ClassificationFilter);
		if (size)
			*size = sizeof(ns1__ClassificationFilter);
		((ns1__ClassificationFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ClassificationFilter[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ClassificationFilter);
		for (int i = 0; i < n; i++)
			((ns1__ClassificationFilter*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ClassificationFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ClassificationFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ClassificationFilter %p -> %p\n", q, p));
	*(ns1__ClassificationFilter*)p = *(ns1__ClassificationFilter*)q;
}

void ns1__TimePeriod::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__TimePeriod::amount);
	soap_default_ns1__TimePeriod_USCOREUnits(soap, &this->ns1__TimePeriod::units);
	/* transient soap skipped */
}

void ns1__TimePeriod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__TimePeriod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TimePeriod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TimePeriod(struct soap *soap, const char *tag, int id, const ns1__TimePeriod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TimePeriod), type))
		return soap->error;
	if (soap_out_int(soap, "amount", -1, &(a->ns1__TimePeriod::amount), ""))
		return soap->error;
	if (soap_out_ns1__TimePeriod_USCOREUnits(soap, "units", -1, &(a->ns1__TimePeriod::units), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TimePeriod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TimePeriod(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TimePeriod * SOAP_FMAC4 soap_in_ns1__TimePeriod(struct soap *soap, const char *tag, ns1__TimePeriod *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TimePeriod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TimePeriod, sizeof(ns1__TimePeriod), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TimePeriod)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TimePeriod *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_amount1 = 1;
	size_t soap_flag_units1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_amount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "amount", &(a->ns1__TimePeriod::amount), "xsd:int"))
				{	soap_flag_amount1--;
					continue;
				}
			if (soap_flag_units1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__TimePeriod_USCOREUnits(soap, "units", &(a->ns1__TimePeriod::units), "ns1:TimePeriod_Units"))
				{	soap_flag_units1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TimePeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TimePeriod, 0, sizeof(ns1__TimePeriod), 0, soap_copy_ns1__TimePeriod);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_amount1 > 0 || soap_flag_units1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TimePeriod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TimePeriod);
	if (this->soap_out(soap, tag?tag:"ns1:TimePeriod", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TimePeriod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TimePeriod(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TimePeriod * SOAP_FMAC4 soap_get_ns1__TimePeriod(struct soap *soap, ns1__TimePeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TimePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TimePeriod * SOAP_FMAC2 soap_instantiate_ns1__TimePeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TimePeriod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TimePeriod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TimePeriod);
		if (size)
			*size = sizeof(ns1__TimePeriod);
		((ns1__TimePeriod*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__TimePeriod[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__TimePeriod);
		for (int i = 0; i < n; i++)
			((ns1__TimePeriod*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__TimePeriod*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TimePeriod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TimePeriod %p -> %p\n", q, p));
	*(ns1__TimePeriod*)p = *(ns1__TimePeriod*)q;
}

void ns1__TimeSpan::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__TimeSpan_USCOREReferencePoint(soap, &this->ns1__TimeSpan::referencePoint);
	/* transient soap skipped */
}

void ns1__TimeSpan::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__TimeSpan::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TimeSpan(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TimeSpan(struct soap *soap, const char *tag, int id, const ns1__TimeSpan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TimeSpan), type))
		return soap->error;
	if (soap_out_ns1__TimeSpan_USCOREReferencePoint(soap, "referencePoint", -1, &(a->ns1__TimeSpan::referencePoint), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TimeSpan::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TimeSpan(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TimeSpan * SOAP_FMAC4 soap_in_ns1__TimeSpan(struct soap *soap, const char *tag, ns1__TimeSpan *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TimeSpan *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TimeSpan, sizeof(ns1__TimeSpan), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TimeSpan)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TimeSpan *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_referencePoint1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_referencePoint1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__TimeSpan_USCOREReferencePoint(soap, "referencePoint", &(a->ns1__TimeSpan::referencePoint), "ns1:TimeSpan_ReferencePoint"))
				{	soap_flag_referencePoint1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TimeSpan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TimeSpan, 0, sizeof(ns1__TimeSpan), 0, soap_copy_ns1__TimeSpan);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_referencePoint1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TimeSpan::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TimeSpan);
	if (this->soap_out(soap, tag?tag:"ns1:TimeSpan", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TimeSpan::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TimeSpan(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TimeSpan * SOAP_FMAC4 soap_get_ns1__TimeSpan(struct soap *soap, ns1__TimeSpan *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TimeSpan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TimeSpan * SOAP_FMAC2 soap_instantiate_ns1__TimeSpan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TimeSpan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TimeSpan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:RelativeTimeSpan"))
	{	cp->type = SOAP_TYPE_ns1__RelativeTimeSpan;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__RelativeTimeSpan);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__RelativeTimeSpan);
			((ns1__RelativeTimeSpan*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__RelativeTimeSpan[n]);
			if (size)
				*size = n * sizeof(ns1__RelativeTimeSpan);
			for (int i = 0; i < n; i++)
				((ns1__RelativeTimeSpan*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__RelativeTimeSpan*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:AbsoluteTimeSpan"))
	{	cp->type = SOAP_TYPE_ns1__AbsoluteTimeSpan;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__AbsoluteTimeSpan);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__AbsoluteTimeSpan);
			((ns1__AbsoluteTimeSpan*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__AbsoluteTimeSpan[n]);
			if (size)
				*size = n * sizeof(ns1__AbsoluteTimeSpan);
			for (int i = 0; i < n; i++)
				((ns1__AbsoluteTimeSpan*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__AbsoluteTimeSpan*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TimeSpan);
		if (size)
			*size = sizeof(ns1__TimeSpan);
		((ns1__TimeSpan*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__TimeSpan[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__TimeSpan);
		for (int i = 0; i < n; i++)
			((ns1__TimeSpan*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__TimeSpan*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TimeSpan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TimeSpan %p -> %p\n", q, p));
	*(ns1__TimeSpan*)p = *(ns1__TimeSpan*)q;
}

void ns1__Feature::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Feature::id);
	soap_default_ns1__Feature_USCOREUse(soap, &this->ns1__Feature::use);
	soap_default_bool(soap, &this->ns1__Feature::record);
	/* transient soap skipped */
}

void ns1__Feature::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Feature::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Feature::id);
	/* transient soap skipped */
}

int ns1__Feature::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Feature(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Feature(struct soap *soap, const char *tag, int id, const ns1__Feature *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Feature), type))
		return soap->error;
	if (soap_out_std__string(soap, "id", -1, &(a->ns1__Feature::id), ""))
		return soap->error;
	if (soap_out_ns1__Feature_USCOREUse(soap, "use", -1, &(a->ns1__Feature::use), ""))
		return soap->error;
	if (soap_out_bool(soap, "record", -1, &(a->ns1__Feature::record), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Feature::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Feature(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Feature * SOAP_FMAC4 soap_in_ns1__Feature(struct soap *soap, const char *tag, ns1__Feature *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Feature *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Feature, sizeof(ns1__Feature), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Feature)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Feature *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_use1 = 1;
	size_t soap_flag_record1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "id", &(a->ns1__Feature::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_use1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__Feature_USCOREUse(soap, "use", &(a->ns1__Feature::use), "ns1:Feature_Use"))
				{	soap_flag_use1--;
					continue;
				}
			if (soap_flag_record1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "record", &(a->ns1__Feature::record), "xsd:boolean"))
				{	soap_flag_record1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Feature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Feature, 0, sizeof(ns1__Feature), 0, soap_copy_ns1__Feature);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_use1 > 0 || soap_flag_record1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Feature::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Feature);
	if (this->soap_out(soap, tag?tag:"ns1:Feature", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Feature::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Feature(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Feature * SOAP_FMAC4 soap_get_ns1__Feature(struct soap *soap, ns1__Feature *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Feature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Feature * SOAP_FMAC2 soap_instantiate_ns1__Feature(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Feature(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Feature, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Feature);
		if (size)
			*size = sizeof(ns1__Feature);
		((ns1__Feature*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Feature[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Feature);
		for (int i = 0; i < n; i++)
			((ns1__Feature*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Feature*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Feature(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Feature %p -> %p\n", q, p));
	*(ns1__Feature*)p = *(ns1__Feature*)q;
}

void ns1__LicenseCriteria::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__LicenseCriteria_USCOREStorage(soap, &this->ns1__LicenseCriteria::storage);
	soap_default_ns1__LicenseCriteria_USCOREDelivery(soap, &this->ns1__LicenseCriteria::delivery);
	soap_default_ns1__LicenseCriteria_USCOREUse(soap, &this->ns1__LicenseCriteria::use);
	soap_default_std__vectorTemplateOfPointerTons1__Feature(soap, &this->ns1__LicenseCriteria::features);
	soap_default_std__vectorTemplateOfPointerTons1__TimeSpan(soap, &this->ns1__LicenseCriteria::timeSpans);
	this->ns1__LicenseCriteria::refreshPeriod = NULL;
	this->ns1__LicenseCriteria::classifications = NULL;
	this->ns1__LicenseCriteria::destinations = NULL;
	/* transient soap skipped */
}

void ns1__LicenseCriteria::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__Feature(soap, &this->ns1__LicenseCriteria::features);
	soap_serialize_std__vectorTemplateOfPointerTons1__TimeSpan(soap, &this->ns1__LicenseCriteria::timeSpans);
	soap_serialize_PointerTons1__TimePeriod(soap, &this->ns1__LicenseCriteria::refreshPeriod);
	soap_serialize_PointerTons1__ClassificationFilter(soap, &this->ns1__LicenseCriteria::classifications);
	soap_serialize_PointerTons1__ClassificationFilter(soap, &this->ns1__LicenseCriteria::destinations);
	/* transient soap skipped */
}

int ns1__LicenseCriteria::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LicenseCriteria(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LicenseCriteria(struct soap *soap, const char *tag, int id, const ns1__LicenseCriteria *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LicenseCriteria), type))
		return soap->error;
	if (soap_out_ns1__LicenseCriteria_USCOREStorage(soap, "storage", -1, &(a->ns1__LicenseCriteria::storage), ""))
		return soap->error;
	if (soap_out_ns1__LicenseCriteria_USCOREDelivery(soap, "delivery", -1, &(a->ns1__LicenseCriteria::delivery), ""))
		return soap->error;
	if (soap_out_ns1__LicenseCriteria_USCOREUse(soap, "use", -1, &(a->ns1__LicenseCriteria::use), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Feature(soap, "features", -1, &(a->ns1__LicenseCriteria::features), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TimeSpan(soap, "timeSpans", -1, &(a->ns1__LicenseCriteria::timeSpans), ""))
		return soap->error;
	if (soap_out_PointerTons1__TimePeriod(soap, "refreshPeriod", -1, &(a->ns1__LicenseCriteria::refreshPeriod), ""))
		return soap->error;
	if (soap_out_PointerTons1__ClassificationFilter(soap, "classifications", -1, &(a->ns1__LicenseCriteria::classifications), ""))
		return soap->error;
	if (soap_out_PointerTons1__ClassificationFilter(soap, "destinations", -1, &(a->ns1__LicenseCriteria::destinations), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__LicenseCriteria::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LicenseCriteria(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LicenseCriteria * SOAP_FMAC4 soap_in_ns1__LicenseCriteria(struct soap *soap, const char *tag, ns1__LicenseCriteria *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LicenseCriteria *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LicenseCriteria, sizeof(ns1__LicenseCriteria), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LicenseCriteria)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LicenseCriteria *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_storage1 = 1;
	size_t soap_flag_delivery1 = 1;
	size_t soap_flag_use1 = 1;
	size_t soap_flag_refreshPeriod1 = 1;
	size_t soap_flag_classifications1 = 1;
	size_t soap_flag_destinations1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_storage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__LicenseCriteria_USCOREStorage(soap, "storage", &(a->ns1__LicenseCriteria::storage), "ns1:LicenseCriteria_Storage"))
				{	soap_flag_storage1--;
					continue;
				}
			if (soap_flag_delivery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__LicenseCriteria_USCOREDelivery(soap, "delivery", &(a->ns1__LicenseCriteria::delivery), "ns1:LicenseCriteria_Delivery"))
				{	soap_flag_delivery1--;
					continue;
				}
			if (soap_flag_use1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__LicenseCriteria_USCOREUse(soap, "use", &(a->ns1__LicenseCriteria::use), "ns1:LicenseCriteria_Use"))
				{	soap_flag_use1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Feature(soap, "features", &(a->ns1__LicenseCriteria::features), "ns1:Feature"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__TimeSpan(soap, "timeSpans", &(a->ns1__LicenseCriteria::timeSpans), "ns1:TimeSpan"))
					continue;
			if (soap_flag_refreshPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TimePeriod(soap, "refreshPeriod", &(a->ns1__LicenseCriteria::refreshPeriod), "ns1:TimePeriod"))
				{	soap_flag_refreshPeriod1--;
					continue;
				}
			if (soap_flag_classifications1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ClassificationFilter(soap, "classifications", &(a->ns1__LicenseCriteria::classifications), "ns1:ClassificationFilter"))
				{	soap_flag_classifications1--;
					continue;
				}
			if (soap_flag_destinations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ClassificationFilter(soap, "destinations", &(a->ns1__LicenseCriteria::destinations), "ns1:ClassificationFilter"))
				{	soap_flag_destinations1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LicenseCriteria *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LicenseCriteria, 0, sizeof(ns1__LicenseCriteria), 0, soap_copy_ns1__LicenseCriteria);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_storage1 > 0 || soap_flag_delivery1 > 0 || soap_flag_use1 > 0 || a->ns1__LicenseCriteria::features.size() < 1 || soap_flag_classifications1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__LicenseCriteria::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LicenseCriteria);
	if (this->soap_out(soap, tag?tag:"ns1:LicenseCriteria", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LicenseCriteria::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LicenseCriteria(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LicenseCriteria * SOAP_FMAC4 soap_get_ns1__LicenseCriteria(struct soap *soap, ns1__LicenseCriteria *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LicenseCriteria(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__LicenseCriteria * SOAP_FMAC2 soap_instantiate_ns1__LicenseCriteria(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LicenseCriteria(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LicenseCriteria, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__LicenseCriteria);
		if (size)
			*size = sizeof(ns1__LicenseCriteria);
		((ns1__LicenseCriteria*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__LicenseCriteria[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LicenseCriteria);
		for (int i = 0; i < n; i++)
			((ns1__LicenseCriteria*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LicenseCriteria*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LicenseCriteria(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LicenseCriteria %p -> %p\n", q, p));
	*(ns1__LicenseCriteria*)p = *(ns1__LicenseCriteria*)q;
}

void ns1__Classification::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Classification::id);
	this->ns1__Classification::system = NULL;
	this->ns1__Classification::keySet = NULL;
	soap_default_xsd__anyURI(soap, &this->ns1__Classification::uri);
	this->ns1__Classification::classificationTime = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns1__Classification::labels);
	this->ns1__Classification::__any = NULL;
	/* transient soap skipped */
}

void ns1__Classification::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Classification::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Classification::id);
	soap_serialize_PointerTons1__ClassificationSystemRef(soap, &this->ns1__Classification::system);
	soap_serialize_PointerTons2__KeySetRef(soap, &this->ns1__Classification::keySet);
	soap_serialize_xsd__anyURI(soap, &this->ns1__Classification::uri);
	soap_serialize_PointerTotime(soap, &this->ns1__Classification::classificationTime);
	soap_serialize_std__vectorTemplateOfPointerTons1__Label(soap, &this->ns1__Classification::labels);
	/* transient soap skipped */
}

int ns1__Classification::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Classification(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Classification(struct soap *soap, const char *tag, int id, const ns1__Classification *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Classification), type))
		return soap->error;
	if (soap_out_std__string(soap, "id", -1, &(a->ns1__Classification::id), ""))
		return soap->error;
	if (soap_out_PointerTons1__ClassificationSystemRef(soap, "system", -1, &(a->ns1__Classification::system), ""))
		return soap->error;
	if (soap_out_PointerTons2__KeySetRef(soap, "keySet", -1, &(a->ns1__Classification::keySet), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "uri", -1, &(a->ns1__Classification::uri), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "classificationTime", -1, &(a->ns1__Classification::classificationTime), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Label(soap, "labels", -1, &(a->ns1__Classification::labels), ""))
		return soap->error;
	soap_outliteral(soap, "-any", &(a->ns1__Classification::__any), NULL);
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Classification::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Classification(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Classification * SOAP_FMAC4 soap_in_ns1__Classification(struct soap *soap, const char *tag, ns1__Classification *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Classification *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Classification, sizeof(ns1__Classification), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Classification)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Classification *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_id1 = 1;
	size_t soap_flag_system1 = 1;
	size_t soap_flag_keySet1 = 1;
	size_t soap_flag_uri1 = 1;
	size_t soap_flag_classificationTime1 = 1;
	size_t soap_flag___any1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "id", &(a->ns1__Classification::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_system1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ClassificationSystemRef(soap, "system", &(a->ns1__Classification::system), "ns1:ClassificationSystemRef"))
				{	soap_flag_system1--;
					continue;
				}
			if (soap_flag_keySet1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__KeySetRef(soap, "keySet", &(a->ns1__Classification::keySet), "ns2:KeySetRef"))
				{	soap_flag_keySet1--;
					continue;
				}
			if (soap_flag_uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "uri", &(a->ns1__Classification::uri), "xsd:anyURI"))
				{	soap_flag_uri1--;
					continue;
				}
			if (soap_flag_classificationTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "classificationTime", &(a->ns1__Classification::classificationTime), "xsd:dateTime"))
				{	soap_flag_classificationTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Label(soap, "labels", &(a->ns1__Classification::labels), "ns1:Label"))
					continue;
			/* transient soap skipped */
			if (soap_flag___any1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &(a->ns1__Classification::__any)))
				{	soap_flag___any1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Classification *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Classification, 0, sizeof(ns1__Classification), 0, soap_copy_ns1__Classification);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_system1 > 0 || soap_flag_uri1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Classification::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Classification);
	if (this->soap_out(soap, tag?tag:"ns1:Classification", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Classification::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Classification(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Classification * SOAP_FMAC4 soap_get_ns1__Classification(struct soap *soap, ns1__Classification *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Classification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Classification * SOAP_FMAC2 soap_instantiate_ns1__Classification(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Classification(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Classification, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Classification);
		if (size)
			*size = sizeof(ns1__Classification);
		((ns1__Classification*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Classification[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Classification);
		for (int i = 0; i < n; i++)
			((ns1__Classification*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Classification*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Classification(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Classification %p -> %p\n", q, p));
	*(ns1__Classification*)p = *(ns1__Classification*)q;
}

void ns1__Label::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Label::locale);
	soap_default_std__string(soap, &this->ns1__Label::name);
	this->ns1__Label::description = NULL;
	/* transient soap skipped */
}

void ns1__Label::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__Label::locale, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Label::locale);
	soap_embedded(soap, &this->ns1__Label::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Label::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__Label::description);
	/* transient soap skipped */
}

int ns1__Label::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Label(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Label(struct soap *soap, const char *tag, int id, const ns1__Label *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Label), type))
		return soap->error;
	if (soap_out_std__string(soap, "locale", -1, &(a->ns1__Label::locale), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__Label::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "description", -1, &(a->ns1__Label::description), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Label::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Label(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Label * SOAP_FMAC4 soap_in_ns1__Label(struct soap *soap, const char *tag, ns1__Label *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Label *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Label, sizeof(ns1__Label), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Label)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Label *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_locale1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_locale1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "locale", &(a->ns1__Label::locale), "xsd:string"))
				{	soap_flag_locale1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__Label::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "description", &(a->ns1__Label::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Label *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Label, 0, sizeof(ns1__Label), 0, soap_copy_ns1__Label);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_locale1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__Label::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Label);
	if (this->soap_out(soap, tag?tag:"ns1:Label", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Label::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Label(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Label * SOAP_FMAC4 soap_get_ns1__Label(struct soap *soap, ns1__Label *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Label(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__Label * SOAP_FMAC2 soap_instantiate_ns1__Label(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Label(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Label, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__Label);
		if (size)
			*size = sizeof(ns1__Label);
		((ns1__Label*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__Label[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Label);
		for (int i = 0; i < n; i++)
			((ns1__Label*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Label*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Label(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Label %p -> %p\n", q, p));
	*(ns1__Label*)p = *(ns1__Label*)q;
}

void ns1__DesktopKeySetExtensions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__DesktopKeySetExtensions::identityToken);
	this->ns1__DesktopKeySetExtensions::encryptedContentKey.xsd__base64Binary::soap_default(soap);
	this->ns1__DesktopKeySetExtensions::encryptedSigningKey.xsd__base64Binary::soap_default(soap);
	/* transient soap skipped */
}

void ns1__DesktopKeySetExtensions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__DesktopKeySetExtensions::identityToken, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DesktopKeySetExtensions::identityToken);
	this->ns1__DesktopKeySetExtensions::encryptedContentKey.soap_serialize(soap);
	this->ns1__DesktopKeySetExtensions::encryptedSigningKey.soap_serialize(soap);
	/* transient soap skipped */
}

int ns1__DesktopKeySetExtensions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DesktopKeySetExtensions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DesktopKeySetExtensions(struct soap *soap, const char *tag, int id, const ns1__DesktopKeySetExtensions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DesktopKeySetExtensions), "ns1:DesktopKeySetExtensions"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "identityToken", -1, &(a->ns1__DesktopKeySetExtensions::identityToken), ""))
		return soap->error;
	if ((a->ns1__DesktopKeySetExtensions::encryptedContentKey).soap_out(soap, "encryptedContentKey", -1, ""))
		return soap->error;
	if ((a->ns1__DesktopKeySetExtensions::encryptedSigningKey).soap_out(soap, "encryptedSigningKey", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DesktopKeySetExtensions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DesktopKeySetExtensions(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DesktopKeySetExtensions * SOAP_FMAC4 soap_in_ns1__DesktopKeySetExtensions(struct soap *soap, const char *tag, ns1__DesktopKeySetExtensions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DesktopKeySetExtensions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DesktopKeySetExtensions, sizeof(ns1__DesktopKeySetExtensions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DesktopKeySetExtensions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DesktopKeySetExtensions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_identityToken1 = 1;
	size_t soap_flag_encryptedContentKey1 = 1;
	size_t soap_flag_encryptedSigningKey1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_identityToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "identityToken", &(a->ns1__DesktopKeySetExtensions::identityToken), "xsd:string"))
				{	soap_flag_identityToken1--;
					continue;
				}
			if (soap_flag_encryptedContentKey1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns1__DesktopKeySetExtensions::encryptedContentKey).soap_in(soap, "encryptedContentKey", "xsd:base64Binary"))
				{	soap_flag_encryptedContentKey1--;
					continue;
				}
			if (soap_flag_encryptedSigningKey1 && soap->error == SOAP_TAG_MISMATCH)
				if ((a->ns1__DesktopKeySetExtensions::encryptedSigningKey).soap_in(soap, "encryptedSigningKey", "xsd:base64Binary"))
				{	soap_flag_encryptedSigningKey1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DesktopKeySetExtensions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DesktopKeySetExtensions, 0, sizeof(ns1__DesktopKeySetExtensions), 0, soap_copy_ns1__DesktopKeySetExtensions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_identityToken1 > 0 || soap_flag_encryptedContentKey1 > 0 || soap_flag_encryptedSigningKey1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__DesktopKeySetExtensions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DesktopKeySetExtensions);
	if (this->soap_out(soap, tag?tag:"ns1:DesktopKeySetExtensions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__DesktopKeySetExtensions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DesktopKeySetExtensions(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DesktopKeySetExtensions * SOAP_FMAC4 soap_get_ns1__DesktopKeySetExtensions(struct soap *soap, ns1__DesktopKeySetExtensions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DesktopKeySetExtensions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__DesktopKeySetExtensions * SOAP_FMAC2 soap_instantiate_ns1__DesktopKeySetExtensions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DesktopKeySetExtensions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DesktopKeySetExtensions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__DesktopKeySetExtensions);
		if (size)
			*size = sizeof(ns1__DesktopKeySetExtensions);
		((ns1__DesktopKeySetExtensions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__DesktopKeySetExtensions[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DesktopKeySetExtensions);
		for (int i = 0; i < n; i++)
			((ns1__DesktopKeySetExtensions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DesktopKeySetExtensions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DesktopKeySetExtensions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DesktopKeySetExtensions %p -> %p\n", q, p));
	*(ns1__DesktopKeySetExtensions*)p = *(ns1__DesktopKeySetExtensions*)q;
}

void ns1__ClassificationSystemRef::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ClassificationSystemRef::uuid);
	/* transient soap skipped */
}

void ns1__ClassificationSystemRef::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ClassificationSystemRef::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ClassificationSystemRef::uuid);
	/* transient soap skipped */
}

int ns1__ClassificationSystemRef::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ClassificationSystemRef(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClassificationSystemRef(struct soap *soap, const char *tag, int id, const ns1__ClassificationSystemRef *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClassificationSystemRef), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns1__ClassificationSystemRef::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ClassificationSystemRef::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ClassificationSystemRef(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ClassificationSystemRef * SOAP_FMAC4 soap_in_ns1__ClassificationSystemRef(struct soap *soap, const char *tag, ns1__ClassificationSystemRef *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ClassificationSystemRef *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClassificationSystemRef, sizeof(ns1__ClassificationSystemRef), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ClassificationSystemRef)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ClassificationSystemRef *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns1__ClassificationSystemRef::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ClassificationSystemRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClassificationSystemRef, 0, sizeof(ns1__ClassificationSystemRef), 0, soap_copy_ns1__ClassificationSystemRef);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ClassificationSystemRef::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ClassificationSystemRef);
	if (this->soap_out(soap, tag?tag:"ns1:ClassificationSystemRef", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ClassificationSystemRef::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ClassificationSystemRef(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ClassificationSystemRef * SOAP_FMAC4 soap_get_ns1__ClassificationSystemRef(struct soap *soap, ns1__ClassificationSystemRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClassificationSystemRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ClassificationSystemRef * SOAP_FMAC2 soap_instantiate_ns1__ClassificationSystemRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClassificationSystemRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ClassificationSystemRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ClassificationSystemRef);
		if (size)
			*size = sizeof(ns1__ClassificationSystemRef);
		((ns1__ClassificationSystemRef*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ClassificationSystemRef[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ClassificationSystemRef);
		for (int i = 0; i < n; i++)
			((ns1__ClassificationSystemRef*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ClassificationSystemRef*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ClassificationSystemRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ClassificationSystemRef %p -> %p\n", q, p));
	*(ns1__ClassificationSystemRef*)p = *(ns1__ClassificationSystemRef*)q;
}

void ns1__ClassificationSystem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__ClassificationSystem::uuid);
	/* transient soap skipped */
}

void ns1__ClassificationSystem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__ClassificationSystem::uuid, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__ClassificationSystem::uuid);
	/* transient soap skipped */
}

int ns1__ClassificationSystem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ClassificationSystem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ClassificationSystem(struct soap *soap, const char *tag, int id, const ns1__ClassificationSystem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ClassificationSystem), type))
		return soap->error;
	if (soap_out_std__string(soap, "uuid", -1, &(a->ns1__ClassificationSystem::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ClassificationSystem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ClassificationSystem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ClassificationSystem * SOAP_FMAC4 soap_in_ns1__ClassificationSystem(struct soap *soap, const char *tag, ns1__ClassificationSystem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ClassificationSystem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ClassificationSystem, sizeof(ns1__ClassificationSystem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ClassificationSystem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ClassificationSystem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "uuid", &(a->ns1__ClassificationSystem::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ClassificationSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ClassificationSystem, 0, sizeof(ns1__ClassificationSystem), 0, soap_copy_ns1__ClassificationSystem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_uuid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__ClassificationSystem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ClassificationSystem);
	if (this->soap_out(soap, tag?tag:"ns1:ClassificationSystem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ClassificationSystem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ClassificationSystem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ClassificationSystem * SOAP_FMAC4 soap_get_ns1__ClassificationSystem(struct soap *soap, ns1__ClassificationSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ClassificationSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__ClassificationSystem * SOAP_FMAC2 soap_instantiate_ns1__ClassificationSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ClassificationSystem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ClassificationSystem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__ClassificationSystem);
		if (size)
			*size = sizeof(ns1__ClassificationSystem);
		((ns1__ClassificationSystem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__ClassificationSystem[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ClassificationSystem);
		for (int i = 0; i < n; i++)
			((ns1__ClassificationSystem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ClassificationSystem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ClassificationSystem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ClassificationSystem %p -> %p\n", q, p));
	*(ns1__ClassificationSystem*)p = *(ns1__ClassificationSystem*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		for (int i = 0; i < n; i++)
			((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__anyURI, 0, sizeof(std::string), 0, soap_copy_xsd__anyURI);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"xsd:anyURI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const xsd__QName *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__QName), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 2, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const xsd__QName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag?tag:"xsd:QName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__QName * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, xsd__QName *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__QName * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__QName);
		if (size)
			*size = sizeof(xsd__QName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(xsd__QName[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__QName);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__QName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__QName %p -> %p\n", q, p));
	*(xsd__QName*)p = *(xsd__QName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__ListRightsByAccount(struct soap *soap, struct __ns7__ListRightsByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__ListRightsByAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__ListRightsByAccount(struct soap *soap, const struct __ns7__ListRightsByAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns7__ListRightsByAccount(soap, &a->ns7__ListRightsByAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__ListRightsByAccount(struct soap *soap, const char *tag, int id, const struct __ns7__ListRightsByAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns7__ListRightsByAccount(soap, "ns7:ListRightsByAccount", -1, &a->ns7__ListRightsByAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__ListRightsByAccount * SOAP_FMAC4 soap_in___ns7__ListRightsByAccount(struct soap *soap, const char *tag, struct __ns7__ListRightsByAccount *a, const char *type)
{
	size_t soap_flag_ns7__ListRightsByAccount = 1;
	short soap_flag;
	a = (struct __ns7__ListRightsByAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__ListRightsByAccount, sizeof(struct __ns7__ListRightsByAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__ListRightsByAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__ListRightsByAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns7__ListRightsByAccount(soap, "ns7:ListRightsByAccount", &a->ns7__ListRightsByAccount, ""))
				{	soap_flag_ns7__ListRightsByAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__ListRightsByAccount(struct soap *soap, const struct __ns7__ListRightsByAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__ListRightsByAccount(soap, tag?tag:"-ns7:ListRightsByAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__ListRightsByAccount * SOAP_FMAC4 soap_get___ns7__ListRightsByAccount(struct soap *soap, struct __ns7__ListRightsByAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__ListRightsByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__ListRightsByAccount * SOAP_FMAC2 soap_instantiate___ns7__ListRightsByAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__ListRightsByAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__ListRightsByAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__ListRightsByAccount);
		if (size)
			*size = sizeof(struct __ns7__ListRightsByAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__ListRightsByAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__ListRightsByAccount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__ListRightsByAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__ListRightsByAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__ListRightsByAccount %p -> %p\n", q, p));
	*(struct __ns7__ListRightsByAccount*)p = *(struct __ns7__ListRightsByAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__ListRightsByContext(struct soap *soap, struct __ns7__ListRightsByContext *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__ListRightsByContext = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__ListRightsByContext(struct soap *soap, const struct __ns7__ListRightsByContext *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns7__ListRightsByContext(soap, &a->ns7__ListRightsByContext);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__ListRightsByContext(struct soap *soap, const char *tag, int id, const struct __ns7__ListRightsByContext *a, const char *type)
{
	if (soap_out_PointerTo_ns7__ListRightsByContext(soap, "ns7:ListRightsByContext", -1, &a->ns7__ListRightsByContext, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__ListRightsByContext * SOAP_FMAC4 soap_in___ns7__ListRightsByContext(struct soap *soap, const char *tag, struct __ns7__ListRightsByContext *a, const char *type)
{
	size_t soap_flag_ns7__ListRightsByContext = 1;
	short soap_flag;
	a = (struct __ns7__ListRightsByContext *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__ListRightsByContext, sizeof(struct __ns7__ListRightsByContext), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__ListRightsByContext(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__ListRightsByContext && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns7__ListRightsByContext(soap, "ns7:ListRightsByContext", &a->ns7__ListRightsByContext, ""))
				{	soap_flag_ns7__ListRightsByContext--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__ListRightsByContext(struct soap *soap, const struct __ns7__ListRightsByContext *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__ListRightsByContext(soap, tag?tag:"-ns7:ListRightsByContext", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__ListRightsByContext * SOAP_FMAC4 soap_get___ns7__ListRightsByContext(struct soap *soap, struct __ns7__ListRightsByContext *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__ListRightsByContext(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__ListRightsByContext * SOAP_FMAC2 soap_instantiate___ns7__ListRightsByContext(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__ListRightsByContext(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__ListRightsByContext, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__ListRightsByContext);
		if (size)
			*size = sizeof(struct __ns7__ListRightsByContext);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__ListRightsByContext[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__ListRightsByContext);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__ListRightsByContext*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__ListRightsByContext(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__ListRightsByContext %p -> %p\n", q, p));
	*(struct __ns7__ListRightsByContext*)p = *(struct __ns7__ListRightsByContext*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__UnassignRights(struct soap *soap, struct __ns7__UnassignRights *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__UnassignRights = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__UnassignRights(struct soap *soap, const struct __ns7__UnassignRights *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns7__UnassignRights(soap, &a->ns7__UnassignRights);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__UnassignRights(struct soap *soap, const char *tag, int id, const struct __ns7__UnassignRights *a, const char *type)
{
	if (soap_out_PointerTo_ns7__UnassignRights(soap, "ns7:UnassignRights", -1, &a->ns7__UnassignRights, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UnassignRights * SOAP_FMAC4 soap_in___ns7__UnassignRights(struct soap *soap, const char *tag, struct __ns7__UnassignRights *a, const char *type)
{
	size_t soap_flag_ns7__UnassignRights = 1;
	short soap_flag;
	a = (struct __ns7__UnassignRights *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__UnassignRights, sizeof(struct __ns7__UnassignRights), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__UnassignRights(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__UnassignRights && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns7__UnassignRights(soap, "ns7:UnassignRights", &a->ns7__UnassignRights, ""))
				{	soap_flag_ns7__UnassignRights--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__UnassignRights(struct soap *soap, const struct __ns7__UnassignRights *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__UnassignRights(soap, tag?tag:"-ns7:UnassignRights", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__UnassignRights * SOAP_FMAC4 soap_get___ns7__UnassignRights(struct soap *soap, struct __ns7__UnassignRights *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__UnassignRights(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__UnassignRights * SOAP_FMAC2 soap_instantiate___ns7__UnassignRights(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__UnassignRights(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__UnassignRights, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UnassignRights);
		if (size)
			*size = sizeof(struct __ns7__UnassignRights);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__UnassignRights[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__UnassignRights);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__UnassignRights*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__UnassignRights(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__UnassignRights %p -> %p\n", q, p));
	*(struct __ns7__UnassignRights*)p = *(struct __ns7__UnassignRights*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__SaveChangesToItems(struct soap *soap, struct __ns7__SaveChangesToItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__SaveChangesToItems = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__SaveChangesToItems(struct soap *soap, const struct __ns7__SaveChangesToItems *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns7__SaveChangesToItems(soap, &a->ns7__SaveChangesToItems);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__SaveChangesToItems(struct soap *soap, const char *tag, int id, const struct __ns7__SaveChangesToItems *a, const char *type)
{
	if (soap_out_PointerTo_ns7__SaveChangesToItems(soap, "ns7:SaveChangesToItems", -1, &a->ns7__SaveChangesToItems, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__SaveChangesToItems * SOAP_FMAC4 soap_in___ns7__SaveChangesToItems(struct soap *soap, const char *tag, struct __ns7__SaveChangesToItems *a, const char *type)
{
	size_t soap_flag_ns7__SaveChangesToItems = 1;
	short soap_flag;
	a = (struct __ns7__SaveChangesToItems *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__SaveChangesToItems, sizeof(struct __ns7__SaveChangesToItems), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__SaveChangesToItems(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__SaveChangesToItems && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns7__SaveChangesToItems(soap, "ns7:SaveChangesToItems", &a->ns7__SaveChangesToItems, ""))
				{	soap_flag_ns7__SaveChangesToItems--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__SaveChangesToItems(struct soap *soap, const struct __ns7__SaveChangesToItems *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__SaveChangesToItems(soap, tag?tag:"-ns7:SaveChangesToItems", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__SaveChangesToItems * SOAP_FMAC4 soap_get___ns7__SaveChangesToItems(struct soap *soap, struct __ns7__SaveChangesToItems *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__SaveChangesToItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__SaveChangesToItems * SOAP_FMAC2 soap_instantiate___ns7__SaveChangesToItems(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__SaveChangesToItems(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__SaveChangesToItems, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__SaveChangesToItems);
		if (size)
			*size = sizeof(struct __ns7__SaveChangesToItems);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__SaveChangesToItems[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__SaveChangesToItems);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__SaveChangesToItems*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__SaveChangesToItems(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__SaveChangesToItems %p -> %p\n", q, p));
	*(struct __ns7__SaveChangesToItems*)p = *(struct __ns7__SaveChangesToItems*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__CheckInRightsForAccount(struct soap *soap, struct __ns7__CheckInRightsForAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__CheckInRightsForAccount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__CheckInRightsForAccount(struct soap *soap, const struct __ns7__CheckInRightsForAccount *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns7__CheckInRightsForAccount(soap, &a->ns7__CheckInRightsForAccount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__CheckInRightsForAccount(struct soap *soap, const char *tag, int id, const struct __ns7__CheckInRightsForAccount *a, const char *type)
{
	if (soap_out_PointerTo_ns7__CheckInRightsForAccount(soap, "ns7:CheckInRightsForAccount", -1, &a->ns7__CheckInRightsForAccount, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__CheckInRightsForAccount * SOAP_FMAC4 soap_in___ns7__CheckInRightsForAccount(struct soap *soap, const char *tag, struct __ns7__CheckInRightsForAccount *a, const char *type)
{
	size_t soap_flag_ns7__CheckInRightsForAccount = 1;
	short soap_flag;
	a = (struct __ns7__CheckInRightsForAccount *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__CheckInRightsForAccount, sizeof(struct __ns7__CheckInRightsForAccount), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__CheckInRightsForAccount(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__CheckInRightsForAccount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns7__CheckInRightsForAccount(soap, "ns7:CheckInRightsForAccount", &a->ns7__CheckInRightsForAccount, ""))
				{	soap_flag_ns7__CheckInRightsForAccount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__CheckInRightsForAccount(struct soap *soap, const struct __ns7__CheckInRightsForAccount *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__CheckInRightsForAccount(soap, tag?tag:"-ns7:CheckInRightsForAccount", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__CheckInRightsForAccount * SOAP_FMAC4 soap_get___ns7__CheckInRightsForAccount(struct soap *soap, struct __ns7__CheckInRightsForAccount *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__CheckInRightsForAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__CheckInRightsForAccount * SOAP_FMAC2 soap_instantiate___ns7__CheckInRightsForAccount(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__CheckInRightsForAccount(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__CheckInRightsForAccount, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__CheckInRightsForAccount);
		if (size)
			*size = sizeof(struct __ns7__CheckInRightsForAccount);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__CheckInRightsForAccount[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__CheckInRightsForAccount);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__CheckInRightsForAccount*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__CheckInRightsForAccount(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__CheckInRightsForAccount %p -> %p\n", q, p));
	*(struct __ns7__CheckInRightsForAccount*)p = *(struct __ns7__CheckInRightsForAccount*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__ReassignRole(struct soap *soap, struct __ns7__ReassignRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__ReassignRole = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__ReassignRole(struct soap *soap, const struct __ns7__ReassignRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns7__ReassignRole(soap, &a->ns7__ReassignRole);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__ReassignRole(struct soap *soap, const char *tag, int id, const struct __ns7__ReassignRole *a, const char *type)
{
	if (soap_out_PointerTo_ns7__ReassignRole(soap, "ns7:ReassignRole", -1, &a->ns7__ReassignRole, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__ReassignRole * SOAP_FMAC4 soap_in___ns7__ReassignRole(struct soap *soap, const char *tag, struct __ns7__ReassignRole *a, const char *type)
{
	size_t soap_flag_ns7__ReassignRole = 1;
	short soap_flag;
	a = (struct __ns7__ReassignRole *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__ReassignRole, sizeof(struct __ns7__ReassignRole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__ReassignRole(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__ReassignRole && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns7__ReassignRole(soap, "ns7:ReassignRole", &a->ns7__ReassignRole, ""))
				{	soap_flag_ns7__ReassignRole--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__ReassignRole(struct soap *soap, const struct __ns7__ReassignRole *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__ReassignRole(soap, tag?tag:"-ns7:ReassignRole", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__ReassignRole * SOAP_FMAC4 soap_get___ns7__ReassignRole(struct soap *soap, struct __ns7__ReassignRole *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__ReassignRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__ReassignRole * SOAP_FMAC2 soap_instantiate___ns7__ReassignRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__ReassignRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__ReassignRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__ReassignRole);
		if (size)
			*size = sizeof(struct __ns7__ReassignRole);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__ReassignRole[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__ReassignRole);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__ReassignRole*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__ReassignRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__ReassignRole %p -> %p\n", q, p));
	*(struct __ns7__ReassignRole*)p = *(struct __ns7__ReassignRole*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns7__AssignRole(struct soap *soap, struct __ns7__AssignRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns7__AssignRole = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns7__AssignRole(struct soap *soap, const struct __ns7__AssignRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns7__AssignRole(soap, &a->ns7__AssignRole);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns7__AssignRole(struct soap *soap, const char *tag, int id, const struct __ns7__AssignRole *a, const char *type)
{
	if (soap_out_PointerTo_ns7__AssignRole(soap, "ns7:AssignRole", -1, &a->ns7__AssignRole, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AssignRole * SOAP_FMAC4 soap_in___ns7__AssignRole(struct soap *soap, const char *tag, struct __ns7__AssignRole *a, const char *type)
{
	size_t soap_flag_ns7__AssignRole = 1;
	short soap_flag;
	a = (struct __ns7__AssignRole *)soap_id_enter(soap, "", a, SOAP_TYPE___ns7__AssignRole, sizeof(struct __ns7__AssignRole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns7__AssignRole(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns7__AssignRole && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns7__AssignRole(soap, "ns7:AssignRole", &a->ns7__AssignRole, ""))
				{	soap_flag_ns7__AssignRole--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns7__AssignRole(struct soap *soap, const struct __ns7__AssignRole *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns7__AssignRole(soap, tag?tag:"-ns7:AssignRole", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns7__AssignRole * SOAP_FMAC4 soap_get___ns7__AssignRole(struct soap *soap, struct __ns7__AssignRole *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns7__AssignRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns7__AssignRole * SOAP_FMAC2 soap_instantiate___ns7__AssignRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns7__AssignRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns7__AssignRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AssignRole);
		if (size)
			*size = sizeof(struct __ns7__AssignRole);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns7__AssignRole[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns7__AssignRole);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns7__AssignRole*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns7__AssignRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns7__AssignRole %p -> %p\n", q, p));
	*(struct __ns7__AssignRole*)p = *(struct __ns7__AssignRole*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__ValidatedPeek(struct soap *soap, struct __ns4__ValidatedPeek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__ValidatedPeek = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__ValidatedPeek(struct soap *soap, const struct __ns4__ValidatedPeek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__ValidatedPeek(soap, &a->ns4__ValidatedPeek);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__ValidatedPeek(struct soap *soap, const char *tag, int id, const struct __ns4__ValidatedPeek *a, const char *type)
{
	if (soap_out_PointerTo_ns4__ValidatedPeek(soap, "ns4:ValidatedPeek", -1, &a->ns4__ValidatedPeek, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__ValidatedPeek * SOAP_FMAC4 soap_in___ns4__ValidatedPeek(struct soap *soap, const char *tag, struct __ns4__ValidatedPeek *a, const char *type)
{
	size_t soap_flag_ns4__ValidatedPeek = 1;
	short soap_flag;
	a = (struct __ns4__ValidatedPeek *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__ValidatedPeek, sizeof(struct __ns4__ValidatedPeek), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__ValidatedPeek(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__ValidatedPeek && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__ValidatedPeek(soap, "ns4:ValidatedPeek", &a->ns4__ValidatedPeek, ""))
				{	soap_flag_ns4__ValidatedPeek--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__ValidatedPeek(struct soap *soap, const struct __ns4__ValidatedPeek *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__ValidatedPeek(soap, tag?tag:"-ns4:ValidatedPeek", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__ValidatedPeek * SOAP_FMAC4 soap_get___ns4__ValidatedPeek(struct soap *soap, struct __ns4__ValidatedPeek *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__ValidatedPeek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__ValidatedPeek * SOAP_FMAC2 soap_instantiate___ns4__ValidatedPeek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__ValidatedPeek(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__ValidatedPeek, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__ValidatedPeek);
		if (size)
			*size = sizeof(struct __ns4__ValidatedPeek);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__ValidatedPeek[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__ValidatedPeek);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__ValidatedPeek*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__ValidatedPeek(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__ValidatedPeek %p -> %p\n", q, p));
	*(struct __ns4__ValidatedPeek*)p = *(struct __ns4__ValidatedPeek*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__Peek(struct soap *soap, struct __ns4__Peek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__Peek = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__Peek(struct soap *soap, const struct __ns4__Peek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__Peek(soap, &a->ns4__Peek);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__Peek(struct soap *soap, const char *tag, int id, const struct __ns4__Peek *a, const char *type)
{
	if (soap_out_PointerTo_ns4__Peek(soap, "ns4:Peek", -1, &a->ns4__Peek, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Peek * SOAP_FMAC4 soap_in___ns4__Peek(struct soap *soap, const char *tag, struct __ns4__Peek *a, const char *type)
{
	size_t soap_flag_ns4__Peek = 1;
	short soap_flag;
	a = (struct __ns4__Peek *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__Peek, sizeof(struct __ns4__Peek), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__Peek(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__Peek && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__Peek(soap, "ns4:Peek", &a->ns4__Peek, ""))
				{	soap_flag_ns4__Peek--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__Peek(struct soap *soap, const struct __ns4__Peek *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__Peek(soap, tag?tag:"-ns4:Peek", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Peek * SOAP_FMAC4 soap_get___ns4__Peek(struct soap *soap, struct __ns4__Peek *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__Peek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__Peek * SOAP_FMAC2 soap_instantiate___ns4__Peek(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__Peek(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__Peek, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Peek);
		if (size)
			*size = sizeof(struct __ns4__Peek);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Peek[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__Peek);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__Peek*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__Peek(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__Peek %p -> %p\n", q, p));
	*(struct __ns4__Peek*)p = *(struct __ns4__Peek*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__Reclassify(struct soap *soap, struct __ns4__Reclassify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__Reclassify = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__Reclassify(struct soap *soap, const struct __ns4__Reclassify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__Reclassify(soap, &a->ns4__Reclassify);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__Reclassify(struct soap *soap, const char *tag, int id, const struct __ns4__Reclassify *a, const char *type)
{
	if (soap_out_PointerTo_ns4__Reclassify(soap, "ns4:Reclassify", -1, &a->ns4__Reclassify, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Reclassify * SOAP_FMAC4 soap_in___ns4__Reclassify(struct soap *soap, const char *tag, struct __ns4__Reclassify *a, const char *type)
{
	size_t soap_flag_ns4__Reclassify = 1;
	short soap_flag;
	a = (struct __ns4__Reclassify *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__Reclassify, sizeof(struct __ns4__Reclassify), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__Reclassify(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__Reclassify && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__Reclassify(soap, "ns4:Reclassify", &a->ns4__Reclassify, ""))
				{	soap_flag_ns4__Reclassify--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__Reclassify(struct soap *soap, const struct __ns4__Reclassify *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__Reclassify(soap, tag?tag:"-ns4:Reclassify", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Reclassify * SOAP_FMAC4 soap_get___ns4__Reclassify(struct soap *soap, struct __ns4__Reclassify *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__Reclassify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__Reclassify * SOAP_FMAC2 soap_instantiate___ns4__Reclassify(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__Reclassify(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__Reclassify, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Reclassify);
		if (size)
			*size = sizeof(struct __ns4__Reclassify);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Reclassify[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__Reclassify);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__Reclassify*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__Reclassify(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__Reclassify %p -> %p\n", q, p));
	*(struct __ns4__Reclassify*)p = *(struct __ns4__Reclassify*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__Reseal(struct soap *soap, struct __ns4__Reseal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__Reseal = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__Reseal(struct soap *soap, const struct __ns4__Reseal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__Reseal(soap, &a->ns4__Reseal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__Reseal(struct soap *soap, const char *tag, int id, const struct __ns4__Reseal *a, const char *type)
{
	if (soap_out_PointerTo_ns4__Reseal(soap, "ns4:Reseal", -1, &a->ns4__Reseal, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Reseal * SOAP_FMAC4 soap_in___ns4__Reseal(struct soap *soap, const char *tag, struct __ns4__Reseal *a, const char *type)
{
	size_t soap_flag_ns4__Reseal = 1;
	short soap_flag;
	a = (struct __ns4__Reseal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__Reseal, sizeof(struct __ns4__Reseal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__Reseal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__Reseal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__Reseal(soap, "ns4:Reseal", &a->ns4__Reseal, ""))
				{	soap_flag_ns4__Reseal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__Reseal(struct soap *soap, const struct __ns4__Reseal *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__Reseal(soap, tag?tag:"-ns4:Reseal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Reseal * SOAP_FMAC4 soap_get___ns4__Reseal(struct soap *soap, struct __ns4__Reseal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__Reseal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__Reseal * SOAP_FMAC2 soap_instantiate___ns4__Reseal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__Reseal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__Reseal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Reseal);
		if (size)
			*size = sizeof(struct __ns4__Reseal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Reseal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__Reseal);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__Reseal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__Reseal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__Reseal %p -> %p\n", q, p));
	*(struct __ns4__Reseal*)p = *(struct __ns4__Reseal*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__Unseal(struct soap *soap, struct __ns4__Unseal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__Unseal = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__Unseal(struct soap *soap, const struct __ns4__Unseal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__Unseal(soap, &a->ns4__Unseal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__Unseal(struct soap *soap, const char *tag, int id, const struct __ns4__Unseal *a, const char *type)
{
	if (soap_out_PointerTo_ns4__Unseal(soap, "ns4:Unseal", -1, &a->ns4__Unseal, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Unseal * SOAP_FMAC4 soap_in___ns4__Unseal(struct soap *soap, const char *tag, struct __ns4__Unseal *a, const char *type)
{
	size_t soap_flag_ns4__Unseal = 1;
	short soap_flag;
	a = (struct __ns4__Unseal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__Unseal, sizeof(struct __ns4__Unseal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__Unseal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__Unseal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__Unseal(soap, "ns4:Unseal", &a->ns4__Unseal, ""))
				{	soap_flag_ns4__Unseal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__Unseal(struct soap *soap, const struct __ns4__Unseal *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__Unseal(soap, tag?tag:"-ns4:Unseal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Unseal * SOAP_FMAC4 soap_get___ns4__Unseal(struct soap *soap, struct __ns4__Unseal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__Unseal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__Unseal * SOAP_FMAC2 soap_instantiate___ns4__Unseal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__Unseal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__Unseal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Unseal);
		if (size)
			*size = sizeof(struct __ns4__Unseal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Unseal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__Unseal);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__Unseal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__Unseal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__Unseal %p -> %p\n", q, p));
	*(struct __ns4__Unseal*)p = *(struct __ns4__Unseal*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns4__Seal(struct soap *soap, struct __ns4__Seal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__Seal = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns4__Seal(struct soap *soap, const struct __ns4__Seal *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns4__Seal(soap, &a->ns4__Seal);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns4__Seal(struct soap *soap, const char *tag, int id, const struct __ns4__Seal *a, const char *type)
{
	if (soap_out_PointerTo_ns4__Seal(soap, "ns4:Seal", -1, &a->ns4__Seal, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Seal * SOAP_FMAC4 soap_in___ns4__Seal(struct soap *soap, const char *tag, struct __ns4__Seal *a, const char *type)
{
	size_t soap_flag_ns4__Seal = 1;
	short soap_flag;
	a = (struct __ns4__Seal *)soap_id_enter(soap, "", a, SOAP_TYPE___ns4__Seal, sizeof(struct __ns4__Seal), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns4__Seal(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__Seal && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns4__Seal(soap, "ns4:Seal", &a->ns4__Seal, ""))
				{	soap_flag_ns4__Seal--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns4__Seal(struct soap *soap, const struct __ns4__Seal *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns4__Seal(soap, tag?tag:"-ns4:Seal", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns4__Seal * SOAP_FMAC4 soap_get___ns4__Seal(struct soap *soap, struct __ns4__Seal *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns4__Seal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns4__Seal * SOAP_FMAC2 soap_instantiate___ns4__Seal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns4__Seal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns4__Seal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Seal);
		if (size)
			*size = sizeof(struct __ns4__Seal);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns4__Seal[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns4__Seal);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns4__Seal*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns4__Seal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns4__Seal %p -> %p\n", q, p));
	*(struct __ns4__Seal*)p = *(struct __ns4__Seal*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns4__AuthorizationDeniedFault = NULL;
	a->ns4__ContentParseFault = NULL;
	a->ns4__IllegalEncryptedContentBlockSizeFault = NULL;
	a->ns4__PublicHeaderLengthFault = NULL;
	a->ns4__UnsupportedContentTypeFault = NULL;
	a->ns7__AccountAlreadyAssignedFault = NULL;
	a->ns7__AuthorizationDeniedFault = NULL;
	a->ns7__UnknownContextFault = NULL;
	a->ns7__UnknownDocumentRightFault = NULL;
	a->ns7__UnknownDocumentRoleFault = NULL;
	a->ns7__UnsupportedDocumentRoleFault = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons3__AuthorizationDeniedFault(soap, &a->ns4__AuthorizationDeniedFault);
	soap_serialize_PointerTons2__ContentParseFault(soap, &a->ns4__ContentParseFault);
	soap_serialize_PointerTons2__IllegalEncryptedContentBlockSizeFault(soap, &a->ns4__IllegalEncryptedContentBlockSizeFault);
	soap_serialize_PointerTons2__PublicHeaderLengthFault(soap, &a->ns4__PublicHeaderLengthFault);
	soap_serialize_PointerTons2__UnsupportedContentTypeFault(soap, &a->ns4__UnsupportedContentTypeFault);
	soap_serialize_PointerTons6__AccountAlreadyAssignedFault(soap, &a->ns7__AccountAlreadyAssignedFault);
	soap_serialize_PointerTons3__AuthorizationDeniedFault(soap, &a->ns7__AuthorizationDeniedFault);
	soap_serialize_PointerTons5__UnknownContextFault(soap, &a->ns7__UnknownContextFault);
	soap_serialize_PointerTons6__UnknownDocumentRightFault(soap, &a->ns7__UnknownDocumentRightFault);
	soap_serialize_PointerTons6__UnknownDocumentRoleFault(soap, &a->ns7__UnknownDocumentRoleFault);
	soap_serialize_PointerTons6__UnsupportedDocumentRoleFault(soap, &a->ns7__UnsupportedDocumentRoleFault);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTons3__AuthorizationDeniedFault(soap, "ns4:AuthorizationDeniedFault", -1, &a->ns4__AuthorizationDeniedFault, ""))
		return soap->error;
	if (soap_out_PointerTons2__ContentParseFault(soap, "ns4:ContentParseFault", -1, &a->ns4__ContentParseFault, ""))
		return soap->error;
	if (soap_out_PointerTons2__IllegalEncryptedContentBlockSizeFault(soap, "ns4:IllegalEncryptedContentBlockSizeFault", -1, &a->ns4__IllegalEncryptedContentBlockSizeFault, ""))
		return soap->error;
	if (soap_out_PointerTons2__PublicHeaderLengthFault(soap, "ns4:PublicHeaderLengthFault", -1, &a->ns4__PublicHeaderLengthFault, ""))
		return soap->error;
	if (soap_out_PointerTons2__UnsupportedContentTypeFault(soap, "ns4:UnsupportedContentTypeFault", -1, &a->ns4__UnsupportedContentTypeFault, ""))
		return soap->error;
	if (soap_out_PointerTons6__AccountAlreadyAssignedFault(soap, "ns7:AccountAlreadyAssignedFault", -1, &a->ns7__AccountAlreadyAssignedFault, ""))
		return soap->error;
	if (soap_out_PointerTons3__AuthorizationDeniedFault(soap, "ns7:AuthorizationDeniedFault", -1, &a->ns7__AuthorizationDeniedFault, ""))
		return soap->error;
	if (soap_out_PointerTons5__UnknownContextFault(soap, "ns7:UnknownContextFault", -1, &a->ns7__UnknownContextFault, ""))
		return soap->error;
	if (soap_out_PointerTons6__UnknownDocumentRightFault(soap, "ns7:UnknownDocumentRightFault", -1, &a->ns7__UnknownDocumentRightFault, ""))
		return soap->error;
	if (soap_out_PointerTons6__UnknownDocumentRoleFault(soap, "ns7:UnknownDocumentRoleFault", -1, &a->ns7__UnknownDocumentRoleFault, ""))
		return soap->error;
	if (soap_out_PointerTons6__UnsupportedDocumentRoleFault(soap, "ns7:UnsupportedDocumentRoleFault", -1, &a->ns7__UnsupportedDocumentRoleFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns4__AuthorizationDeniedFault = 1;
	size_t soap_flag_ns4__ContentParseFault = 1;
	size_t soap_flag_ns4__IllegalEncryptedContentBlockSizeFault = 1;
	size_t soap_flag_ns4__PublicHeaderLengthFault = 1;
	size_t soap_flag_ns4__UnsupportedContentTypeFault = 1;
	size_t soap_flag_ns7__AccountAlreadyAssignedFault = 1;
	size_t soap_flag_ns7__AuthorizationDeniedFault = 1;
	size_t soap_flag_ns7__UnknownContextFault = 1;
	size_t soap_flag_ns7__UnknownDocumentRightFault = 1;
	size_t soap_flag_ns7__UnknownDocumentRoleFault = 1;
	size_t soap_flag_ns7__UnsupportedDocumentRoleFault = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns4__AuthorizationDeniedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AuthorizationDeniedFault(soap, "ns4:AuthorizationDeniedFault", &a->ns4__AuthorizationDeniedFault, "ns3:AuthorizationDeniedFault"))
				{	soap_flag_ns4__AuthorizationDeniedFault--;
					continue;
				}
			if (soap_flag_ns4__ContentParseFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ContentParseFault(soap, "ns4:ContentParseFault", &a->ns4__ContentParseFault, "ns2:ContentParseFault"))
				{	soap_flag_ns4__ContentParseFault--;
					continue;
				}
			if (soap_flag_ns4__IllegalEncryptedContentBlockSizeFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__IllegalEncryptedContentBlockSizeFault(soap, "ns4:IllegalEncryptedContentBlockSizeFault", &a->ns4__IllegalEncryptedContentBlockSizeFault, "ns2:IllegalEncryptedContentBlockSizeFault"))
				{	soap_flag_ns4__IllegalEncryptedContentBlockSizeFault--;
					continue;
				}
			if (soap_flag_ns4__PublicHeaderLengthFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__PublicHeaderLengthFault(soap, "ns4:PublicHeaderLengthFault", &a->ns4__PublicHeaderLengthFault, "ns2:PublicHeaderLengthFault"))
				{	soap_flag_ns4__PublicHeaderLengthFault--;
					continue;
				}
			if (soap_flag_ns4__UnsupportedContentTypeFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__UnsupportedContentTypeFault(soap, "ns4:UnsupportedContentTypeFault", &a->ns4__UnsupportedContentTypeFault, "ns2:UnsupportedContentTypeFault"))
				{	soap_flag_ns4__UnsupportedContentTypeFault--;
					continue;
				}
			if (soap_flag_ns7__AccountAlreadyAssignedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__AccountAlreadyAssignedFault(soap, "ns7:AccountAlreadyAssignedFault", &a->ns7__AccountAlreadyAssignedFault, "ns6:AccountAlreadyAssignedFault"))
				{	soap_flag_ns7__AccountAlreadyAssignedFault--;
					continue;
				}
			if (soap_flag_ns7__AuthorizationDeniedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons3__AuthorizationDeniedFault(soap, "ns7:AuthorizationDeniedFault", &a->ns7__AuthorizationDeniedFault, "ns3:AuthorizationDeniedFault"))
				{	soap_flag_ns7__AuthorizationDeniedFault--;
					continue;
				}
			if (soap_flag_ns7__UnknownContextFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__UnknownContextFault(soap, "ns7:UnknownContextFault", &a->ns7__UnknownContextFault, "ns5:UnknownContextFault"))
				{	soap_flag_ns7__UnknownContextFault--;
					continue;
				}
			if (soap_flag_ns7__UnknownDocumentRightFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__UnknownDocumentRightFault(soap, "ns7:UnknownDocumentRightFault", &a->ns7__UnknownDocumentRightFault, "ns6:UnknownDocumentRightFault"))
				{	soap_flag_ns7__UnknownDocumentRightFault--;
					continue;
				}
			if (soap_flag_ns7__UnknownDocumentRoleFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__UnknownDocumentRoleFault(soap, "ns7:UnknownDocumentRoleFault", &a->ns7__UnknownDocumentRoleFault, "ns6:UnknownDocumentRoleFault"))
				{	soap_flag_ns7__UnknownDocumentRoleFault--;
					continue;
				}
			if (soap_flag_ns7__UnsupportedDocumentRoleFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__UnsupportedDocumentRoleFault(soap, "ns7:UnsupportedDocumentRoleFault", &a->ns7__UnsupportedDocumentRoleFault, "ns6:UnsupportedDocumentRoleFault"))
				{	soap_flag_ns7__UnsupportedDocumentRoleFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__ListRightsByAccountResponse(struct soap *soap, _ns7__ListRightsByAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__ListRightsByAccountResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__ListRightsByAccountResponse(struct soap *soap, const char *tag, int id, _ns7__ListRightsByAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__ListRightsByAccountResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__ListRightsByAccountResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__ListRightsByAccountResponse(struct soap *soap, const char *tag, _ns7__ListRightsByAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__ListRightsByAccountResponse **)soap_malloc(soap, sizeof(_ns7__ListRightsByAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__ListRightsByAccountResponse *)soap_instantiate__ns7__ListRightsByAccountResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__ListRightsByAccountResponse ** p = (_ns7__ListRightsByAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__ListRightsByAccountResponse, sizeof(_ns7__ListRightsByAccountResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__ListRightsByAccountResponse(struct soap *soap, _ns7__ListRightsByAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__ListRightsByAccountResponse);
	if (soap_out_PointerTo_ns7__ListRightsByAccountResponse(soap, tag?tag:"ns7:ListRightsByAccountResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__ListRightsByAccountResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__ListRightsByAccountResponse(struct soap *soap, _ns7__ListRightsByAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__ListRightsByAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__ListRightsByAccount(struct soap *soap, _ns7__ListRightsByAccount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__ListRightsByAccount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__ListRightsByAccount(struct soap *soap, const char *tag, int id, _ns7__ListRightsByAccount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__ListRightsByAccount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__ListRightsByAccount ** SOAP_FMAC4 soap_in_PointerTo_ns7__ListRightsByAccount(struct soap *soap, const char *tag, _ns7__ListRightsByAccount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__ListRightsByAccount **)soap_malloc(soap, sizeof(_ns7__ListRightsByAccount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__ListRightsByAccount *)soap_instantiate__ns7__ListRightsByAccount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__ListRightsByAccount ** p = (_ns7__ListRightsByAccount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__ListRightsByAccount, sizeof(_ns7__ListRightsByAccount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__ListRightsByAccount(struct soap *soap, _ns7__ListRightsByAccount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__ListRightsByAccount);
	if (soap_out_PointerTo_ns7__ListRightsByAccount(soap, tag?tag:"ns7:ListRightsByAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__ListRightsByAccount ** SOAP_FMAC4 soap_get_PointerTo_ns7__ListRightsByAccount(struct soap *soap, _ns7__ListRightsByAccount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__ListRightsByAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__ListRightsByContextResponse(struct soap *soap, _ns7__ListRightsByContextResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__ListRightsByContextResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__ListRightsByContextResponse(struct soap *soap, const char *tag, int id, _ns7__ListRightsByContextResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__ListRightsByContextResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__ListRightsByContextResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__ListRightsByContextResponse(struct soap *soap, const char *tag, _ns7__ListRightsByContextResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__ListRightsByContextResponse **)soap_malloc(soap, sizeof(_ns7__ListRightsByContextResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__ListRightsByContextResponse *)soap_instantiate__ns7__ListRightsByContextResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__ListRightsByContextResponse ** p = (_ns7__ListRightsByContextResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__ListRightsByContextResponse, sizeof(_ns7__ListRightsByContextResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__ListRightsByContextResponse(struct soap *soap, _ns7__ListRightsByContextResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__ListRightsByContextResponse);
	if (soap_out_PointerTo_ns7__ListRightsByContextResponse(soap, tag?tag:"ns7:ListRightsByContextResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__ListRightsByContextResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__ListRightsByContextResponse(struct soap *soap, _ns7__ListRightsByContextResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__ListRightsByContextResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__ListRightsByContext(struct soap *soap, _ns7__ListRightsByContext *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__ListRightsByContext))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__ListRightsByContext(struct soap *soap, const char *tag, int id, _ns7__ListRightsByContext *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__ListRightsByContext);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__ListRightsByContext ** SOAP_FMAC4 soap_in_PointerTo_ns7__ListRightsByContext(struct soap *soap, const char *tag, _ns7__ListRightsByContext **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__ListRightsByContext **)soap_malloc(soap, sizeof(_ns7__ListRightsByContext *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__ListRightsByContext *)soap_instantiate__ns7__ListRightsByContext(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__ListRightsByContext ** p = (_ns7__ListRightsByContext **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__ListRightsByContext, sizeof(_ns7__ListRightsByContext), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__ListRightsByContext(struct soap *soap, _ns7__ListRightsByContext *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__ListRightsByContext);
	if (soap_out_PointerTo_ns7__ListRightsByContext(soap, tag?tag:"ns7:ListRightsByContext", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__ListRightsByContext ** SOAP_FMAC4 soap_get_PointerTo_ns7__ListRightsByContext(struct soap *soap, _ns7__ListRightsByContext **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__ListRightsByContext(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__UnassignRightsResponse(struct soap *soap, _ns7__UnassignRightsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__UnassignRightsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__UnassignRightsResponse(struct soap *soap, const char *tag, int id, _ns7__UnassignRightsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__UnassignRightsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__UnassignRightsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__UnassignRightsResponse(struct soap *soap, const char *tag, _ns7__UnassignRightsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__UnassignRightsResponse **)soap_malloc(soap, sizeof(_ns7__UnassignRightsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__UnassignRightsResponse *)soap_instantiate__ns7__UnassignRightsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__UnassignRightsResponse ** p = (_ns7__UnassignRightsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__UnassignRightsResponse, sizeof(_ns7__UnassignRightsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__UnassignRightsResponse(struct soap *soap, _ns7__UnassignRightsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__UnassignRightsResponse);
	if (soap_out_PointerTo_ns7__UnassignRightsResponse(soap, tag?tag:"ns7:UnassignRightsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__UnassignRightsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__UnassignRightsResponse(struct soap *soap, _ns7__UnassignRightsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__UnassignRightsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__UnassignRights(struct soap *soap, _ns7__UnassignRights *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__UnassignRights))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__UnassignRights(struct soap *soap, const char *tag, int id, _ns7__UnassignRights *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__UnassignRights);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__UnassignRights ** SOAP_FMAC4 soap_in_PointerTo_ns7__UnassignRights(struct soap *soap, const char *tag, _ns7__UnassignRights **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__UnassignRights **)soap_malloc(soap, sizeof(_ns7__UnassignRights *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__UnassignRights *)soap_instantiate__ns7__UnassignRights(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__UnassignRights ** p = (_ns7__UnassignRights **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__UnassignRights, sizeof(_ns7__UnassignRights), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__UnassignRights(struct soap *soap, _ns7__UnassignRights *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__UnassignRights);
	if (soap_out_PointerTo_ns7__UnassignRights(soap, tag?tag:"ns7:UnassignRights", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__UnassignRights ** SOAP_FMAC4 soap_get_PointerTo_ns7__UnassignRights(struct soap *soap, _ns7__UnassignRights **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__UnassignRights(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__SaveChangesToItemsResponse(struct soap *soap, _ns7__SaveChangesToItemsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__SaveChangesToItemsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__SaveChangesToItemsResponse(struct soap *soap, const char *tag, int id, _ns7__SaveChangesToItemsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__SaveChangesToItemsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__SaveChangesToItemsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__SaveChangesToItemsResponse(struct soap *soap, const char *tag, _ns7__SaveChangesToItemsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__SaveChangesToItemsResponse **)soap_malloc(soap, sizeof(_ns7__SaveChangesToItemsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__SaveChangesToItemsResponse *)soap_instantiate__ns7__SaveChangesToItemsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__SaveChangesToItemsResponse ** p = (_ns7__SaveChangesToItemsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__SaveChangesToItemsResponse, sizeof(_ns7__SaveChangesToItemsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__SaveChangesToItemsResponse(struct soap *soap, _ns7__SaveChangesToItemsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__SaveChangesToItemsResponse);
	if (soap_out_PointerTo_ns7__SaveChangesToItemsResponse(soap, tag?tag:"ns7:SaveChangesToItemsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__SaveChangesToItemsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__SaveChangesToItemsResponse(struct soap *soap, _ns7__SaveChangesToItemsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__SaveChangesToItemsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__SaveChangesToItems(struct soap *soap, _ns7__SaveChangesToItems *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__SaveChangesToItems))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__SaveChangesToItems(struct soap *soap, const char *tag, int id, _ns7__SaveChangesToItems *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__SaveChangesToItems);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__SaveChangesToItems ** SOAP_FMAC4 soap_in_PointerTo_ns7__SaveChangesToItems(struct soap *soap, const char *tag, _ns7__SaveChangesToItems **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__SaveChangesToItems **)soap_malloc(soap, sizeof(_ns7__SaveChangesToItems *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__SaveChangesToItems *)soap_instantiate__ns7__SaveChangesToItems(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__SaveChangesToItems ** p = (_ns7__SaveChangesToItems **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__SaveChangesToItems, sizeof(_ns7__SaveChangesToItems), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__SaveChangesToItems(struct soap *soap, _ns7__SaveChangesToItems *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__SaveChangesToItems);
	if (soap_out_PointerTo_ns7__SaveChangesToItems(soap, tag?tag:"ns7:SaveChangesToItems", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__SaveChangesToItems ** SOAP_FMAC4 soap_get_PointerTo_ns7__SaveChangesToItems(struct soap *soap, _ns7__SaveChangesToItems **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__SaveChangesToItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__CheckInRightsForAccountResponse(struct soap *soap, _ns7__CheckInRightsForAccountResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__CheckInRightsForAccountResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__CheckInRightsForAccountResponse(struct soap *soap, const char *tag, int id, _ns7__CheckInRightsForAccountResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__CheckInRightsForAccountResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__CheckInRightsForAccountResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__CheckInRightsForAccountResponse(struct soap *soap, const char *tag, _ns7__CheckInRightsForAccountResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__CheckInRightsForAccountResponse **)soap_malloc(soap, sizeof(_ns7__CheckInRightsForAccountResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__CheckInRightsForAccountResponse *)soap_instantiate__ns7__CheckInRightsForAccountResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__CheckInRightsForAccountResponse ** p = (_ns7__CheckInRightsForAccountResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__CheckInRightsForAccountResponse, sizeof(_ns7__CheckInRightsForAccountResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__CheckInRightsForAccountResponse(struct soap *soap, _ns7__CheckInRightsForAccountResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__CheckInRightsForAccountResponse);
	if (soap_out_PointerTo_ns7__CheckInRightsForAccountResponse(soap, tag?tag:"ns7:CheckInRightsForAccountResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__CheckInRightsForAccountResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__CheckInRightsForAccountResponse(struct soap *soap, _ns7__CheckInRightsForAccountResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__CheckInRightsForAccountResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__CheckInRightsForAccount(struct soap *soap, _ns7__CheckInRightsForAccount *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__CheckInRightsForAccount))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__CheckInRightsForAccount(struct soap *soap, const char *tag, int id, _ns7__CheckInRightsForAccount *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__CheckInRightsForAccount);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__CheckInRightsForAccount ** SOAP_FMAC4 soap_in_PointerTo_ns7__CheckInRightsForAccount(struct soap *soap, const char *tag, _ns7__CheckInRightsForAccount **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__CheckInRightsForAccount **)soap_malloc(soap, sizeof(_ns7__CheckInRightsForAccount *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__CheckInRightsForAccount *)soap_instantiate__ns7__CheckInRightsForAccount(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__CheckInRightsForAccount ** p = (_ns7__CheckInRightsForAccount **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__CheckInRightsForAccount, sizeof(_ns7__CheckInRightsForAccount), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__CheckInRightsForAccount(struct soap *soap, _ns7__CheckInRightsForAccount *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__CheckInRightsForAccount);
	if (soap_out_PointerTo_ns7__CheckInRightsForAccount(soap, tag?tag:"ns7:CheckInRightsForAccount", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__CheckInRightsForAccount ** SOAP_FMAC4 soap_get_PointerTo_ns7__CheckInRightsForAccount(struct soap *soap, _ns7__CheckInRightsForAccount **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__CheckInRightsForAccount(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__ReassignRoleResponse(struct soap *soap, _ns7__ReassignRoleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__ReassignRoleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__ReassignRoleResponse(struct soap *soap, const char *tag, int id, _ns7__ReassignRoleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__ReassignRoleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__ReassignRoleResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__ReassignRoleResponse(struct soap *soap, const char *tag, _ns7__ReassignRoleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__ReassignRoleResponse **)soap_malloc(soap, sizeof(_ns7__ReassignRoleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__ReassignRoleResponse *)soap_instantiate__ns7__ReassignRoleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__ReassignRoleResponse ** p = (_ns7__ReassignRoleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__ReassignRoleResponse, sizeof(_ns7__ReassignRoleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__ReassignRoleResponse(struct soap *soap, _ns7__ReassignRoleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__ReassignRoleResponse);
	if (soap_out_PointerTo_ns7__ReassignRoleResponse(soap, tag?tag:"ns7:ReassignRoleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__ReassignRoleResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__ReassignRoleResponse(struct soap *soap, _ns7__ReassignRoleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__ReassignRoleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__ReassignRole(struct soap *soap, _ns7__ReassignRole *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__ReassignRole))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__ReassignRole(struct soap *soap, const char *tag, int id, _ns7__ReassignRole *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__ReassignRole);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__ReassignRole ** SOAP_FMAC4 soap_in_PointerTo_ns7__ReassignRole(struct soap *soap, const char *tag, _ns7__ReassignRole **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__ReassignRole **)soap_malloc(soap, sizeof(_ns7__ReassignRole *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__ReassignRole *)soap_instantiate__ns7__ReassignRole(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__ReassignRole ** p = (_ns7__ReassignRole **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__ReassignRole, sizeof(_ns7__ReassignRole), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__ReassignRole(struct soap *soap, _ns7__ReassignRole *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__ReassignRole);
	if (soap_out_PointerTo_ns7__ReassignRole(soap, tag?tag:"ns7:ReassignRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__ReassignRole ** SOAP_FMAC4 soap_get_PointerTo_ns7__ReassignRole(struct soap *soap, _ns7__ReassignRole **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__ReassignRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__AssignRoleResponse(struct soap *soap, _ns7__AssignRoleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__AssignRoleResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__AssignRoleResponse(struct soap *soap, const char *tag, int id, _ns7__AssignRoleResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__AssignRoleResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__AssignRoleResponse ** SOAP_FMAC4 soap_in_PointerTo_ns7__AssignRoleResponse(struct soap *soap, const char *tag, _ns7__AssignRoleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__AssignRoleResponse **)soap_malloc(soap, sizeof(_ns7__AssignRoleResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__AssignRoleResponse *)soap_instantiate__ns7__AssignRoleResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__AssignRoleResponse ** p = (_ns7__AssignRoleResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__AssignRoleResponse, sizeof(_ns7__AssignRoleResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__AssignRoleResponse(struct soap *soap, _ns7__AssignRoleResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__AssignRoleResponse);
	if (soap_out_PointerTo_ns7__AssignRoleResponse(soap, tag?tag:"ns7:AssignRoleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__AssignRoleResponse ** SOAP_FMAC4 soap_get_PointerTo_ns7__AssignRoleResponse(struct soap *soap, _ns7__AssignRoleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__AssignRoleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns7__AssignRole(struct soap *soap, _ns7__AssignRole *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns7__AssignRole))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns7__AssignRole(struct soap *soap, const char *tag, int id, _ns7__AssignRole *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns7__AssignRole);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns7__AssignRole ** SOAP_FMAC4 soap_in_PointerTo_ns7__AssignRole(struct soap *soap, const char *tag, _ns7__AssignRole **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns7__AssignRole **)soap_malloc(soap, sizeof(_ns7__AssignRole *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns7__AssignRole *)soap_instantiate__ns7__AssignRole(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns7__AssignRole ** p = (_ns7__AssignRole **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns7__AssignRole, sizeof(_ns7__AssignRole), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns7__AssignRole(struct soap *soap, _ns7__AssignRole *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns7__AssignRole);
	if (soap_out_PointerTo_ns7__AssignRole(soap, tag?tag:"ns7:AssignRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns7__AssignRole ** SOAP_FMAC4 soap_get_PointerTo_ns7__AssignRole(struct soap *soap, _ns7__AssignRole **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns7__AssignRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__ValidatedPeekResponse(struct soap *soap, _ns4__ValidatedPeekResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__ValidatedPeekResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__ValidatedPeekResponse(struct soap *soap, const char *tag, int id, _ns4__ValidatedPeekResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__ValidatedPeekResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__ValidatedPeekResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__ValidatedPeekResponse(struct soap *soap, const char *tag, _ns4__ValidatedPeekResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__ValidatedPeekResponse **)soap_malloc(soap, sizeof(_ns4__ValidatedPeekResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__ValidatedPeekResponse *)soap_instantiate__ns4__ValidatedPeekResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__ValidatedPeekResponse ** p = (_ns4__ValidatedPeekResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__ValidatedPeekResponse, sizeof(_ns4__ValidatedPeekResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__ValidatedPeekResponse(struct soap *soap, _ns4__ValidatedPeekResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__ValidatedPeekResponse);
	if (soap_out_PointerTo_ns4__ValidatedPeekResponse(soap, tag?tag:"ns4:ValidatedPeekResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__ValidatedPeekResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__ValidatedPeekResponse(struct soap *soap, _ns4__ValidatedPeekResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__ValidatedPeekResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__ValidatedPeek(struct soap *soap, _ns4__ValidatedPeek *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__ValidatedPeek))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__ValidatedPeek(struct soap *soap, const char *tag, int id, _ns4__ValidatedPeek *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__ValidatedPeek);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__ValidatedPeek ** SOAP_FMAC4 soap_in_PointerTo_ns4__ValidatedPeek(struct soap *soap, const char *tag, _ns4__ValidatedPeek **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__ValidatedPeek **)soap_malloc(soap, sizeof(_ns4__ValidatedPeek *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__ValidatedPeek *)soap_instantiate__ns4__ValidatedPeek(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__ValidatedPeek ** p = (_ns4__ValidatedPeek **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__ValidatedPeek, sizeof(_ns4__ValidatedPeek), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__ValidatedPeek(struct soap *soap, _ns4__ValidatedPeek *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__ValidatedPeek);
	if (soap_out_PointerTo_ns4__ValidatedPeek(soap, tag?tag:"ns4:ValidatedPeek", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__ValidatedPeek ** SOAP_FMAC4 soap_get_PointerTo_ns4__ValidatedPeek(struct soap *soap, _ns4__ValidatedPeek **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__ValidatedPeek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__PeekResponse(struct soap *soap, _ns4__PeekResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__PeekResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__PeekResponse(struct soap *soap, const char *tag, int id, _ns4__PeekResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__PeekResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__PeekResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__PeekResponse(struct soap *soap, const char *tag, _ns4__PeekResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__PeekResponse **)soap_malloc(soap, sizeof(_ns4__PeekResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__PeekResponse *)soap_instantiate__ns4__PeekResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__PeekResponse ** p = (_ns4__PeekResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__PeekResponse, sizeof(_ns4__PeekResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__PeekResponse(struct soap *soap, _ns4__PeekResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__PeekResponse);
	if (soap_out_PointerTo_ns4__PeekResponse(soap, tag?tag:"ns4:PeekResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__PeekResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__PeekResponse(struct soap *soap, _ns4__PeekResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__PeekResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__Peek(struct soap *soap, _ns4__Peek *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__Peek))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__Peek(struct soap *soap, const char *tag, int id, _ns4__Peek *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__Peek);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__Peek ** SOAP_FMAC4 soap_in_PointerTo_ns4__Peek(struct soap *soap, const char *tag, _ns4__Peek **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__Peek **)soap_malloc(soap, sizeof(_ns4__Peek *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__Peek *)soap_instantiate__ns4__Peek(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__Peek ** p = (_ns4__Peek **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__Peek, sizeof(_ns4__Peek), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__Peek(struct soap *soap, _ns4__Peek *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__Peek);
	if (soap_out_PointerTo_ns4__Peek(soap, tag?tag:"ns4:Peek", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__Peek ** SOAP_FMAC4 soap_get_PointerTo_ns4__Peek(struct soap *soap, _ns4__Peek **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__Peek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__ReclassifyResponse(struct soap *soap, _ns4__ReclassifyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__ReclassifyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__ReclassifyResponse(struct soap *soap, const char *tag, int id, _ns4__ReclassifyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__ReclassifyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__ReclassifyResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__ReclassifyResponse(struct soap *soap, const char *tag, _ns4__ReclassifyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__ReclassifyResponse **)soap_malloc(soap, sizeof(_ns4__ReclassifyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__ReclassifyResponse *)soap_instantiate__ns4__ReclassifyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__ReclassifyResponse ** p = (_ns4__ReclassifyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__ReclassifyResponse, sizeof(_ns4__ReclassifyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__ReclassifyResponse(struct soap *soap, _ns4__ReclassifyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__ReclassifyResponse);
	if (soap_out_PointerTo_ns4__ReclassifyResponse(soap, tag?tag:"ns4:ReclassifyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__ReclassifyResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__ReclassifyResponse(struct soap *soap, _ns4__ReclassifyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__ReclassifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__Reclassify(struct soap *soap, _ns4__Reclassify *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__Reclassify))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__Reclassify(struct soap *soap, const char *tag, int id, _ns4__Reclassify *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__Reclassify);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__Reclassify ** SOAP_FMAC4 soap_in_PointerTo_ns4__Reclassify(struct soap *soap, const char *tag, _ns4__Reclassify **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__Reclassify **)soap_malloc(soap, sizeof(_ns4__Reclassify *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__Reclassify *)soap_instantiate__ns4__Reclassify(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__Reclassify ** p = (_ns4__Reclassify **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__Reclassify, sizeof(_ns4__Reclassify), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__Reclassify(struct soap *soap, _ns4__Reclassify *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__Reclassify);
	if (soap_out_PointerTo_ns4__Reclassify(soap, tag?tag:"ns4:Reclassify", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__Reclassify ** SOAP_FMAC4 soap_get_PointerTo_ns4__Reclassify(struct soap *soap, _ns4__Reclassify **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__Reclassify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__ResealResponse(struct soap *soap, _ns4__ResealResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__ResealResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__ResealResponse(struct soap *soap, const char *tag, int id, _ns4__ResealResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__ResealResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__ResealResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__ResealResponse(struct soap *soap, const char *tag, _ns4__ResealResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__ResealResponse **)soap_malloc(soap, sizeof(_ns4__ResealResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__ResealResponse *)soap_instantiate__ns4__ResealResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__ResealResponse ** p = (_ns4__ResealResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__ResealResponse, sizeof(_ns4__ResealResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__ResealResponse(struct soap *soap, _ns4__ResealResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__ResealResponse);
	if (soap_out_PointerTo_ns4__ResealResponse(soap, tag?tag:"ns4:ResealResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__ResealResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__ResealResponse(struct soap *soap, _ns4__ResealResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__ResealResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__Reseal(struct soap *soap, _ns4__Reseal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__Reseal))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__Reseal(struct soap *soap, const char *tag, int id, _ns4__Reseal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__Reseal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__Reseal ** SOAP_FMAC4 soap_in_PointerTo_ns4__Reseal(struct soap *soap, const char *tag, _ns4__Reseal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__Reseal **)soap_malloc(soap, sizeof(_ns4__Reseal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__Reseal *)soap_instantiate__ns4__Reseal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__Reseal ** p = (_ns4__Reseal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__Reseal, sizeof(_ns4__Reseal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__Reseal(struct soap *soap, _ns4__Reseal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__Reseal);
	if (soap_out_PointerTo_ns4__Reseal(soap, tag?tag:"ns4:Reseal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__Reseal ** SOAP_FMAC4 soap_get_PointerTo_ns4__Reseal(struct soap *soap, _ns4__Reseal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__Reseal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__UnsealResponse(struct soap *soap, _ns4__UnsealResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__UnsealResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__UnsealResponse(struct soap *soap, const char *tag, int id, _ns4__UnsealResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__UnsealResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__UnsealResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__UnsealResponse(struct soap *soap, const char *tag, _ns4__UnsealResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__UnsealResponse **)soap_malloc(soap, sizeof(_ns4__UnsealResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__UnsealResponse *)soap_instantiate__ns4__UnsealResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__UnsealResponse ** p = (_ns4__UnsealResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__UnsealResponse, sizeof(_ns4__UnsealResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__UnsealResponse(struct soap *soap, _ns4__UnsealResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__UnsealResponse);
	if (soap_out_PointerTo_ns4__UnsealResponse(soap, tag?tag:"ns4:UnsealResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__UnsealResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__UnsealResponse(struct soap *soap, _ns4__UnsealResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__UnsealResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__Unseal(struct soap *soap, _ns4__Unseal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__Unseal))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__Unseal(struct soap *soap, const char *tag, int id, _ns4__Unseal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__Unseal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__Unseal ** SOAP_FMAC4 soap_in_PointerTo_ns4__Unseal(struct soap *soap, const char *tag, _ns4__Unseal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__Unseal **)soap_malloc(soap, sizeof(_ns4__Unseal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__Unseal *)soap_instantiate__ns4__Unseal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__Unseal ** p = (_ns4__Unseal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__Unseal, sizeof(_ns4__Unseal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__Unseal(struct soap *soap, _ns4__Unseal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__Unseal);
	if (soap_out_PointerTo_ns4__Unseal(soap, tag?tag:"ns4:Unseal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__Unseal ** SOAP_FMAC4 soap_get_PointerTo_ns4__Unseal(struct soap *soap, _ns4__Unseal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__Unseal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__SealResponse(struct soap *soap, _ns4__SealResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__SealResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__SealResponse(struct soap *soap, const char *tag, int id, _ns4__SealResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__SealResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__SealResponse ** SOAP_FMAC4 soap_in_PointerTo_ns4__SealResponse(struct soap *soap, const char *tag, _ns4__SealResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__SealResponse **)soap_malloc(soap, sizeof(_ns4__SealResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__SealResponse *)soap_instantiate__ns4__SealResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__SealResponse ** p = (_ns4__SealResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__SealResponse, sizeof(_ns4__SealResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__SealResponse(struct soap *soap, _ns4__SealResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__SealResponse);
	if (soap_out_PointerTo_ns4__SealResponse(soap, tag?tag:"ns4:SealResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__SealResponse ** SOAP_FMAC4 soap_get_PointerTo_ns4__SealResponse(struct soap *soap, _ns4__SealResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__SealResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns4__Seal(struct soap *soap, _ns4__Seal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns4__Seal))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns4__Seal(struct soap *soap, const char *tag, int id, _ns4__Seal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns4__Seal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns4__Seal ** SOAP_FMAC4 soap_in_PointerTo_ns4__Seal(struct soap *soap, const char *tag, _ns4__Seal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns4__Seal **)soap_malloc(soap, sizeof(_ns4__Seal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns4__Seal *)soap_instantiate__ns4__Seal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns4__Seal ** p = (_ns4__Seal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns4__Seal, sizeof(_ns4__Seal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns4__Seal(struct soap *soap, _ns4__Seal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns4__Seal);
	if (soap_out_PointerTo_ns4__Seal(soap, tag?tag:"ns4:Seal", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns4__Seal ** SOAP_FMAC4 soap_get_PointerTo_ns4__Seal(struct soap *soap, _ns4__Seal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns4__Seal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__UnsupportedDocumentRoleFault(struct soap *soap, ns6__UnsupportedDocumentRoleFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__UnsupportedDocumentRoleFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__UnsupportedDocumentRoleFault(struct soap *soap, const char *tag, int id, ns6__UnsupportedDocumentRoleFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__UnsupportedDocumentRoleFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__UnsupportedDocumentRoleFault ** SOAP_FMAC4 soap_in_PointerTons6__UnsupportedDocumentRoleFault(struct soap *soap, const char *tag, ns6__UnsupportedDocumentRoleFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__UnsupportedDocumentRoleFault **)soap_malloc(soap, sizeof(ns6__UnsupportedDocumentRoleFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__UnsupportedDocumentRoleFault *)soap_instantiate_ns6__UnsupportedDocumentRoleFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__UnsupportedDocumentRoleFault ** p = (ns6__UnsupportedDocumentRoleFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__UnsupportedDocumentRoleFault, sizeof(ns6__UnsupportedDocumentRoleFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__UnsupportedDocumentRoleFault(struct soap *soap, ns6__UnsupportedDocumentRoleFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__UnsupportedDocumentRoleFault);
	if (soap_out_PointerTons6__UnsupportedDocumentRoleFault(soap, tag?tag:"ns6:UnsupportedDocumentRoleFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__UnsupportedDocumentRoleFault ** SOAP_FMAC4 soap_get_PointerTons6__UnsupportedDocumentRoleFault(struct soap *soap, ns6__UnsupportedDocumentRoleFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__UnsupportedDocumentRoleFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__UnknownDocumentRoleFault(struct soap *soap, ns6__UnknownDocumentRoleFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__UnknownDocumentRoleFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__UnknownDocumentRoleFault(struct soap *soap, const char *tag, int id, ns6__UnknownDocumentRoleFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__UnknownDocumentRoleFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__UnknownDocumentRoleFault ** SOAP_FMAC4 soap_in_PointerTons6__UnknownDocumentRoleFault(struct soap *soap, const char *tag, ns6__UnknownDocumentRoleFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__UnknownDocumentRoleFault **)soap_malloc(soap, sizeof(ns6__UnknownDocumentRoleFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__UnknownDocumentRoleFault *)soap_instantiate_ns6__UnknownDocumentRoleFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__UnknownDocumentRoleFault ** p = (ns6__UnknownDocumentRoleFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__UnknownDocumentRoleFault, sizeof(ns6__UnknownDocumentRoleFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__UnknownDocumentRoleFault(struct soap *soap, ns6__UnknownDocumentRoleFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__UnknownDocumentRoleFault);
	if (soap_out_PointerTons6__UnknownDocumentRoleFault(soap, tag?tag:"ns6:UnknownDocumentRoleFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__UnknownDocumentRoleFault ** SOAP_FMAC4 soap_get_PointerTons6__UnknownDocumentRoleFault(struct soap *soap, ns6__UnknownDocumentRoleFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__UnknownDocumentRoleFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__UnknownDocumentRightFault(struct soap *soap, ns6__UnknownDocumentRightFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__UnknownDocumentRightFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__UnknownDocumentRightFault(struct soap *soap, const char *tag, int id, ns6__UnknownDocumentRightFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__UnknownDocumentRightFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__UnknownDocumentRightFault ** SOAP_FMAC4 soap_in_PointerTons6__UnknownDocumentRightFault(struct soap *soap, const char *tag, ns6__UnknownDocumentRightFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__UnknownDocumentRightFault **)soap_malloc(soap, sizeof(ns6__UnknownDocumentRightFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__UnknownDocumentRightFault *)soap_instantiate_ns6__UnknownDocumentRightFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__UnknownDocumentRightFault ** p = (ns6__UnknownDocumentRightFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__UnknownDocumentRightFault, sizeof(ns6__UnknownDocumentRightFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__UnknownDocumentRightFault(struct soap *soap, ns6__UnknownDocumentRightFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__UnknownDocumentRightFault);
	if (soap_out_PointerTons6__UnknownDocumentRightFault(soap, tag?tag:"ns6:UnknownDocumentRightFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__UnknownDocumentRightFault ** SOAP_FMAC4 soap_get_PointerTons6__UnknownDocumentRightFault(struct soap *soap, ns6__UnknownDocumentRightFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__UnknownDocumentRightFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__UnknownContextFault(struct soap *soap, ns5__UnknownContextFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__UnknownContextFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__UnknownContextFault(struct soap *soap, const char *tag, int id, ns5__UnknownContextFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__UnknownContextFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__UnknownContextFault ** SOAP_FMAC4 soap_in_PointerTons5__UnknownContextFault(struct soap *soap, const char *tag, ns5__UnknownContextFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__UnknownContextFault **)soap_malloc(soap, sizeof(ns5__UnknownContextFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__UnknownContextFault *)soap_instantiate_ns5__UnknownContextFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__UnknownContextFault ** p = (ns5__UnknownContextFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__UnknownContextFault, sizeof(ns5__UnknownContextFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__UnknownContextFault(struct soap *soap, ns5__UnknownContextFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__UnknownContextFault);
	if (soap_out_PointerTons5__UnknownContextFault(soap, tag?tag:"ns5:UnknownContextFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__UnknownContextFault ** SOAP_FMAC4 soap_get_PointerTons5__UnknownContextFault(struct soap *soap, ns5__UnknownContextFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__UnknownContextFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__AccountAlreadyAssignedFault(struct soap *soap, ns6__AccountAlreadyAssignedFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__AccountAlreadyAssignedFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__AccountAlreadyAssignedFault(struct soap *soap, const char *tag, int id, ns6__AccountAlreadyAssignedFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__AccountAlreadyAssignedFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__AccountAlreadyAssignedFault ** SOAP_FMAC4 soap_in_PointerTons6__AccountAlreadyAssignedFault(struct soap *soap, const char *tag, ns6__AccountAlreadyAssignedFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__AccountAlreadyAssignedFault **)soap_malloc(soap, sizeof(ns6__AccountAlreadyAssignedFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__AccountAlreadyAssignedFault *)soap_instantiate_ns6__AccountAlreadyAssignedFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__AccountAlreadyAssignedFault ** p = (ns6__AccountAlreadyAssignedFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__AccountAlreadyAssignedFault, sizeof(ns6__AccountAlreadyAssignedFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__AccountAlreadyAssignedFault(struct soap *soap, ns6__AccountAlreadyAssignedFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__AccountAlreadyAssignedFault);
	if (soap_out_PointerTons6__AccountAlreadyAssignedFault(soap, tag?tag:"ns6:AccountAlreadyAssignedFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__AccountAlreadyAssignedFault ** SOAP_FMAC4 soap_get_PointerTons6__AccountAlreadyAssignedFault(struct soap *soap, ns6__AccountAlreadyAssignedFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__AccountAlreadyAssignedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__UnsupportedContentTypeFault(struct soap *soap, ns2__UnsupportedContentTypeFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__UnsupportedContentTypeFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__UnsupportedContentTypeFault(struct soap *soap, const char *tag, int id, ns2__UnsupportedContentTypeFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__UnsupportedContentTypeFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__UnsupportedContentTypeFault ** SOAP_FMAC4 soap_in_PointerTons2__UnsupportedContentTypeFault(struct soap *soap, const char *tag, ns2__UnsupportedContentTypeFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__UnsupportedContentTypeFault **)soap_malloc(soap, sizeof(ns2__UnsupportedContentTypeFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__UnsupportedContentTypeFault *)soap_instantiate_ns2__UnsupportedContentTypeFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__UnsupportedContentTypeFault ** p = (ns2__UnsupportedContentTypeFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__UnsupportedContentTypeFault, sizeof(ns2__UnsupportedContentTypeFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__UnsupportedContentTypeFault(struct soap *soap, ns2__UnsupportedContentTypeFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__UnsupportedContentTypeFault);
	if (soap_out_PointerTons2__UnsupportedContentTypeFault(soap, tag?tag:"ns2:UnsupportedContentTypeFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__UnsupportedContentTypeFault ** SOAP_FMAC4 soap_get_PointerTons2__UnsupportedContentTypeFault(struct soap *soap, ns2__UnsupportedContentTypeFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__UnsupportedContentTypeFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__PublicHeaderLengthFault(struct soap *soap, ns2__PublicHeaderLengthFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__PublicHeaderLengthFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__PublicHeaderLengthFault(struct soap *soap, const char *tag, int id, ns2__PublicHeaderLengthFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__PublicHeaderLengthFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__PublicHeaderLengthFault ** SOAP_FMAC4 soap_in_PointerTons2__PublicHeaderLengthFault(struct soap *soap, const char *tag, ns2__PublicHeaderLengthFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__PublicHeaderLengthFault **)soap_malloc(soap, sizeof(ns2__PublicHeaderLengthFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__PublicHeaderLengthFault *)soap_instantiate_ns2__PublicHeaderLengthFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__PublicHeaderLengthFault ** p = (ns2__PublicHeaderLengthFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__PublicHeaderLengthFault, sizeof(ns2__PublicHeaderLengthFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__PublicHeaderLengthFault(struct soap *soap, ns2__PublicHeaderLengthFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__PublicHeaderLengthFault);
	if (soap_out_PointerTons2__PublicHeaderLengthFault(soap, tag?tag:"ns2:PublicHeaderLengthFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__PublicHeaderLengthFault ** SOAP_FMAC4 soap_get_PointerTons2__PublicHeaderLengthFault(struct soap *soap, ns2__PublicHeaderLengthFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__PublicHeaderLengthFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, ns2__IllegalEncryptedContentBlockSizeFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, const char *tag, int id, ns2__IllegalEncryptedContentBlockSizeFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__IllegalEncryptedContentBlockSizeFault ** SOAP_FMAC4 soap_in_PointerTons2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, const char *tag, ns2__IllegalEncryptedContentBlockSizeFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__IllegalEncryptedContentBlockSizeFault **)soap_malloc(soap, sizeof(ns2__IllegalEncryptedContentBlockSizeFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__IllegalEncryptedContentBlockSizeFault *)soap_instantiate_ns2__IllegalEncryptedContentBlockSizeFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__IllegalEncryptedContentBlockSizeFault ** p = (ns2__IllegalEncryptedContentBlockSizeFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault, sizeof(ns2__IllegalEncryptedContentBlockSizeFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, ns2__IllegalEncryptedContentBlockSizeFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__IllegalEncryptedContentBlockSizeFault);
	if (soap_out_PointerTons2__IllegalEncryptedContentBlockSizeFault(soap, tag?tag:"ns2:IllegalEncryptedContentBlockSizeFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__IllegalEncryptedContentBlockSizeFault ** SOAP_FMAC4 soap_get_PointerTons2__IllegalEncryptedContentBlockSizeFault(struct soap *soap, ns2__IllegalEncryptedContentBlockSizeFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__IllegalEncryptedContentBlockSizeFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentParseFault(struct soap *soap, ns2__ContentParseFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentParseFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentParseFault(struct soap *soap, const char *tag, int id, ns2__ContentParseFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentParseFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentParseFault ** SOAP_FMAC4 soap_in_PointerTons2__ContentParseFault(struct soap *soap, const char *tag, ns2__ContentParseFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentParseFault **)soap_malloc(soap, sizeof(ns2__ContentParseFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentParseFault *)soap_instantiate_ns2__ContentParseFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentParseFault ** p = (ns2__ContentParseFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentParseFault, sizeof(ns2__ContentParseFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentParseFault(struct soap *soap, ns2__ContentParseFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentParseFault);
	if (soap_out_PointerTons2__ContentParseFault(soap, tag?tag:"ns2:ContentParseFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentParseFault ** SOAP_FMAC4 soap_get_PointerTons2__ContentParseFault(struct soap *soap, ns2__ContentParseFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentParseFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons3__AuthorizationDeniedFault(struct soap *soap, ns3__AuthorizationDeniedFault *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns3__AuthorizationDeniedFault))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons3__AuthorizationDeniedFault(struct soap *soap, const char *tag, int id, ns3__AuthorizationDeniedFault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns3__AuthorizationDeniedFault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns3__AuthorizationDeniedFault ** SOAP_FMAC4 soap_in_PointerTons3__AuthorizationDeniedFault(struct soap *soap, const char *tag, ns3__AuthorizationDeniedFault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns3__AuthorizationDeniedFault **)soap_malloc(soap, sizeof(ns3__AuthorizationDeniedFault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns3__AuthorizationDeniedFault *)soap_instantiate_ns3__AuthorizationDeniedFault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns3__AuthorizationDeniedFault ** p = (ns3__AuthorizationDeniedFault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__AuthorizationDeniedFault, sizeof(ns3__AuthorizationDeniedFault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons3__AuthorizationDeniedFault(struct soap *soap, ns3__AuthorizationDeniedFault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons3__AuthorizationDeniedFault);
	if (soap_out_PointerTons3__AuthorizationDeniedFault(soap, tag?tag:"ns3:AuthorizationDeniedFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns3__AuthorizationDeniedFault ** SOAP_FMAC4 soap_get_PointerTons3__AuthorizationDeniedFault(struct soap *soap, ns3__AuthorizationDeniedFault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons3__AuthorizationDeniedFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ContextTemplateRef(struct soap *soap, ns6__ContextTemplateRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ContextTemplateRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ContextTemplateRef(struct soap *soap, const char *tag, int id, ns6__ContextTemplateRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ContextTemplateRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ContextTemplateRef ** SOAP_FMAC4 soap_in_PointerTons6__ContextTemplateRef(struct soap *soap, const char *tag, ns6__ContextTemplateRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ContextTemplateRef **)soap_malloc(soap, sizeof(ns6__ContextTemplateRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ContextTemplateRef *)soap_instantiate_ns6__ContextTemplateRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ContextTemplateRef ** p = (ns6__ContextTemplateRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ContextTemplateRef, sizeof(ns6__ContextTemplateRef), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ContextTemplateRef(struct soap *soap, ns6__ContextTemplateRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ContextTemplateRef);
	if (soap_out_PointerTons6__ContextTemplateRef(soap, tag?tag:"ns6:ContextTemplateRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ContextTemplateRef ** SOAP_FMAC4 soap_get_PointerTons6__ContextTemplateRef(struct soap *soap, ns6__ContextTemplateRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ContextTemplateRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__XPathExpression(struct soap *soap, ns1__XPathExpression *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__XPathExpression))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__XPathExpression(struct soap *soap, const char *tag, int id, ns1__XPathExpression *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__XPathExpression);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__XPathExpression ** SOAP_FMAC4 soap_in_PointerTons1__XPathExpression(struct soap *soap, const char *tag, ns1__XPathExpression **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__XPathExpression **)soap_malloc(soap, sizeof(ns1__XPathExpression *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__XPathExpression *)soap_instantiate_ns1__XPathExpression(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__XPathExpression ** p = (ns1__XPathExpression **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__XPathExpression, sizeof(ns1__XPathExpression), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__XPathExpression(struct soap *soap, ns1__XPathExpression *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__XPathExpression);
	if (soap_out_PointerTons1__XPathExpression(soap, tag?tag:"ns1:XPathExpression", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__XPathExpression ** SOAP_FMAC4 soap_get_PointerTons1__XPathExpression(struct soap *soap, ns1__XPathExpression **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__XPathExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PageRange(struct soap *soap, ns1__PageRange *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PageRange))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PageRange(struct soap *soap, const char *tag, int id, ns1__PageRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PageRange);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PageRange ** SOAP_FMAC4 soap_in_PointerTons1__PageRange(struct soap *soap, const char *tag, ns1__PageRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PageRange **)soap_malloc(soap, sizeof(ns1__PageRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PageRange *)soap_instantiate_ns1__PageRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PageRange ** p = (ns1__PageRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PageRange, sizeof(ns1__PageRange), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PageRange(struct soap *soap, ns1__PageRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PageRange);
	if (soap_out_PointerTons1__PageRange(soap, tag?tag:"ns1:PageRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PageRange ** SOAP_FMAC4 soap_get_PointerTons1__PageRange(struct soap *soap, ns1__PageRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PageRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__DocumentRightRef(struct soap *soap, ns6__DocumentRightRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__DocumentRightRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__DocumentRightRef(struct soap *soap, const char *tag, int id, ns6__DocumentRightRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__DocumentRightRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__DocumentRightRef ** SOAP_FMAC4 soap_in_PointerTons6__DocumentRightRef(struct soap *soap, const char *tag, ns6__DocumentRightRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__DocumentRightRef **)soap_malloc(soap, sizeof(ns6__DocumentRightRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__DocumentRightRef *)soap_instantiate_ns6__DocumentRightRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__DocumentRightRef ** p = (ns6__DocumentRightRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__DocumentRightRef, sizeof(ns6__DocumentRightRef), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__DocumentRightRef(struct soap *soap, ns6__DocumentRightRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__DocumentRightRef);
	if (soap_out_PointerTons6__DocumentRightRef(soap, tag?tag:"ns6:DocumentRightRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__DocumentRightRef ** SOAP_FMAC4 soap_get_PointerTons6__DocumentRightRef(struct soap *soap, ns6__DocumentRightRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__DocumentRightRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__DocumentRight(struct soap *soap, ns6__DocumentRight *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__DocumentRight))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__DocumentRight(struct soap *soap, const char *tag, int id, ns6__DocumentRight *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__DocumentRight);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__DocumentRight ** SOAP_FMAC4 soap_in_PointerTons6__DocumentRight(struct soap *soap, const char *tag, ns6__DocumentRight **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__DocumentRight **)soap_malloc(soap, sizeof(ns6__DocumentRight *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__DocumentRight *)soap_instantiate_ns6__DocumentRight(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__DocumentRight ** p = (ns6__DocumentRight **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__DocumentRight, sizeof(ns6__DocumentRight), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__DocumentRight(struct soap *soap, ns6__DocumentRight *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__DocumentRight);
	if (soap_out_PointerTons6__DocumentRight(soap, tag?tag:"ns6:DocumentRight", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__DocumentRight ** SOAP_FMAC4 soap_get_PointerTons6__DocumentRight(struct soap *soap, ns6__DocumentRight **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__DocumentRight(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__ContextInstanceRef(struct soap *soap, ns6__ContextInstanceRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__ContextInstanceRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__ContextInstanceRef(struct soap *soap, const char *tag, int id, ns6__ContextInstanceRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__ContextInstanceRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__ContextInstanceRef ** SOAP_FMAC4 soap_in_PointerTons6__ContextInstanceRef(struct soap *soap, const char *tag, ns6__ContextInstanceRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__ContextInstanceRef **)soap_malloc(soap, sizeof(ns6__ContextInstanceRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__ContextInstanceRef *)soap_instantiate_ns6__ContextInstanceRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__ContextInstanceRef ** p = (ns6__ContextInstanceRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__ContextInstanceRef, sizeof(ns6__ContextInstanceRef), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__ContextInstanceRef(struct soap *soap, ns6__ContextInstanceRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__ContextInstanceRef);
	if (soap_out_PointerTons6__ContextInstanceRef(soap, tag?tag:"ns6:ContextInstanceRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__ContextInstanceRef ** SOAP_FMAC4 soap_get_PointerTons6__ContextInstanceRef(struct soap *soap, ns6__ContextInstanceRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__ContextInstanceRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__DocumentRole(struct soap *soap, ns6__DocumentRole *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__DocumentRole))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__DocumentRole(struct soap *soap, const char *tag, int id, ns6__DocumentRole *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__DocumentRole);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__DocumentRole ** SOAP_FMAC4 soap_in_PointerTons6__DocumentRole(struct soap *soap, const char *tag, ns6__DocumentRole **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__DocumentRole **)soap_malloc(soap, sizeof(ns6__DocumentRole *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__DocumentRole *)soap_instantiate_ns6__DocumentRole(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__DocumentRole ** p = (ns6__DocumentRole **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__DocumentRole, sizeof(ns6__DocumentRole), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__DocumentRole(struct soap *soap, ns6__DocumentRole *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__DocumentRole);
	if (soap_out_PointerTons6__DocumentRole(soap, tag?tag:"ns6:DocumentRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__DocumentRole ** SOAP_FMAC4 soap_get_PointerTons6__DocumentRole(struct soap *soap, ns6__DocumentRole **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__DocumentRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AccountRef(struct soap *soap, ns1__AccountRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AccountRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AccountRef(struct soap *soap, const char *tag, int id, ns1__AccountRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AccountRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AccountRef ** SOAP_FMAC4 soap_in_PointerTons1__AccountRef(struct soap *soap, const char *tag, ns1__AccountRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AccountRef **)soap_malloc(soap, sizeof(ns1__AccountRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AccountRef *)soap_instantiate_ns1__AccountRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__AccountRef ** p = (ns1__AccountRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AccountRef, sizeof(ns1__AccountRef), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AccountRef(struct soap *soap, ns1__AccountRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AccountRef);
	if (soap_out_PointerTons1__AccountRef(soap, tag?tag:"ns1:AccountRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__AccountRef ** SOAP_FMAC4 soap_get_PointerTons1__AccountRef(struct soap *soap, ns1__AccountRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AccountRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__DomainRef(struct soap *soap, ns6__DomainRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__DomainRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__DomainRef(struct soap *soap, const char *tag, int id, ns6__DomainRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__DomainRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__DomainRef ** SOAP_FMAC4 soap_in_PointerTons6__DomainRef(struct soap *soap, const char *tag, ns6__DomainRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__DomainRef **)soap_malloc(soap, sizeof(ns6__DomainRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__DomainRef *)soap_instantiate_ns6__DomainRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__DomainRef ** p = (ns6__DomainRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__DomainRef, sizeof(ns6__DomainRef), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__DomainRef(struct soap *soap, ns6__DomainRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__DomainRef);
	if (soap_out_PointerTons6__DomainRef(soap, tag?tag:"ns6:DomainRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__DomainRef ** SOAP_FMAC4 soap_get_PointerTons6__DomainRef(struct soap *soap, ns6__DomainRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__DomainRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__DocumentRoleRef(struct soap *soap, ns6__DocumentRoleRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__DocumentRoleRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__DocumentRoleRef(struct soap *soap, const char *tag, int id, ns6__DocumentRoleRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__DocumentRoleRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns6__DocumentRoleRef ** SOAP_FMAC4 soap_in_PointerTons6__DocumentRoleRef(struct soap *soap, const char *tag, ns6__DocumentRoleRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns6__DocumentRoleRef **)soap_malloc(soap, sizeof(ns6__DocumentRoleRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns6__DocumentRoleRef *)soap_instantiate_ns6__DocumentRoleRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns6__DocumentRoleRef ** p = (ns6__DocumentRoleRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__DocumentRoleRef, sizeof(ns6__DocumentRoleRef), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__DocumentRoleRef(struct soap *soap, ns6__DocumentRoleRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons6__DocumentRoleRef);
	if (soap_out_PointerTons6__DocumentRoleRef(soap, tag?tag:"ns6:DocumentRoleRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns6__DocumentRoleRef ** SOAP_FMAC4 soap_get_PointerTons6__DocumentRoleRef(struct soap *soap, ns6__DocumentRoleRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__DocumentRoleRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__ItemCode(struct soap *soap, ns5__ItemCode *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__ItemCode))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__ItemCode(struct soap *soap, const char *tag, int id, ns5__ItemCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__ItemCode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__ItemCode ** SOAP_FMAC4 soap_in_PointerTons5__ItemCode(struct soap *soap, const char *tag, ns5__ItemCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__ItemCode **)soap_malloc(soap, sizeof(ns5__ItemCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__ItemCode *)soap_instantiate_ns5__ItemCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__ItemCode ** p = (ns5__ItemCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__ItemCode, sizeof(ns5__ItemCode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__ItemCode(struct soap *soap, ns5__ItemCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__ItemCode);
	if (soap_out_PointerTons5__ItemCode(soap, tag?tag:"ns5:ItemCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns5__ItemCode ** SOAP_FMAC4 soap_get_PointerTons5__ItemCode(struct soap *soap, ns5__ItemCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__ItemCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentDescription(struct soap *soap, ns2__ContentDescription *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentDescription))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentDescription(struct soap *soap, const char *tag, int id, ns2__ContentDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentDescription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentDescription ** SOAP_FMAC4 soap_in_PointerTons2__ContentDescription(struct soap *soap, const char *tag, ns2__ContentDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentDescription **)soap_malloc(soap, sizeof(ns2__ContentDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentDescription *)soap_instantiate_ns2__ContentDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentDescription ** p = (ns2__ContentDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentDescription, sizeof(ns2__ContentDescription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentDescription(struct soap *soap, ns2__ContentDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentDescription);
	if (soap_out_PointerTons2__ContentDescription(soap, tag?tag:"ns2:ContentDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentDescription ** SOAP_FMAC4 soap_get_PointerTons2__ContentDescription(struct soap *soap, ns2__ContentDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SealingOptions(struct soap *soap, ns2__SealingOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SealingOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SealingOptions(struct soap *soap, const char *tag, int id, ns2__SealingOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SealingOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SealingOptions ** SOAP_FMAC4 soap_in_PointerTons2__SealingOptions(struct soap *soap, const char *tag, ns2__SealingOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SealingOptions **)soap_malloc(soap, sizeof(ns2__SealingOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SealingOptions *)soap_instantiate_ns2__SealingOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SealingOptions ** p = (ns2__SealingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SealingOptions, sizeof(ns2__SealingOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SealingOptions(struct soap *soap, ns2__SealingOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SealingOptions);
	if (soap_out_PointerTons2__SealingOptions(soap, tag?tag:"ns2:SealingOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SealingOptions ** SOAP_FMAC4 soap_get_PointerTons2__SealingOptions(struct soap *soap, ns2__SealingOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SealingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EncryptionOptions(struct soap *soap, ns2__EncryptionOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EncryptionOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EncryptionOptions(struct soap *soap, const char *tag, int id, ns2__EncryptionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EncryptionOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EncryptionOptions ** SOAP_FMAC4 soap_in_PointerTons2__EncryptionOptions(struct soap *soap, const char *tag, ns2__EncryptionOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EncryptionOptions **)soap_malloc(soap, sizeof(ns2__EncryptionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EncryptionOptions *)soap_instantiate_ns2__EncryptionOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__EncryptionOptions ** p = (ns2__EncryptionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EncryptionOptions, sizeof(ns2__EncryptionOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EncryptionOptions(struct soap *soap, ns2__EncryptionOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EncryptionOptions);
	if (soap_out_PointerTons2__EncryptionOptions(soap, tag?tag:"ns2:EncryptionOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EncryptionOptions ** SOAP_FMAC4 soap_get_PointerTons2__EncryptionOptions(struct soap *soap, ns2__EncryptionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EncryptionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ContentSchema(struct soap *soap, ns2__ContentSchema *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ContentSchema))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ContentSchema(struct soap *soap, const char *tag, int id, ns2__ContentSchema *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ContentSchema);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ContentSchema ** SOAP_FMAC4 soap_in_PointerTons2__ContentSchema(struct soap *soap, const char *tag, ns2__ContentSchema **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ContentSchema **)soap_malloc(soap, sizeof(ns2__ContentSchema *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ContentSchema *)soap_instantiate_ns2__ContentSchema(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ContentSchema ** p = (ns2__ContentSchema **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ContentSchema, sizeof(ns2__ContentSchema), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ContentSchema(struct soap *soap, ns2__ContentSchema *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ContentSchema);
	if (soap_out_PointerTons2__ContentSchema(soap, tag?tag:"ns2:ContentSchema", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ContentSchema ** SOAP_FMAC4 soap_get_PointerTons2__ContentSchema(struct soap *soap, ns2__ContentSchema **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ContentSchema(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CustomData(struct soap *soap, ns2__CustomData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CustomData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CustomData(struct soap *soap, const char *tag, int id, ns2__CustomData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CustomData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CustomData ** SOAP_FMAC4 soap_in_PointerTons2__CustomData(struct soap *soap, const char *tag, ns2__CustomData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CustomData **)soap_malloc(soap, sizeof(ns2__CustomData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CustomData *)soap_instantiate_ns2__CustomData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CustomData ** p = (ns2__CustomData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CustomData, sizeof(ns2__CustomData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CustomData(struct soap *soap, ns2__CustomData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CustomData);
	if (soap_out_PointerTons2__CustomData(soap, tag?tag:"ns2:CustomData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CustomData ** SOAP_FMAC4 soap_get_PointerTons2__CustomData(struct soap *soap, ns2__CustomData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CustomData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Classification(struct soap *soap, ns1__Classification *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Classification))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Classification(struct soap *soap, const char *tag, int id, ns1__Classification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Classification);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Classification ** SOAP_FMAC4 soap_in_PointerTons1__Classification(struct soap *soap, const char *tag, ns1__Classification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Classification **)soap_malloc(soap, sizeof(ns1__Classification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Classification *)soap_instantiate_ns1__Classification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Classification ** p = (ns1__Classification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Classification, sizeof(ns1__Classification), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Classification(struct soap *soap, ns1__Classification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Classification);
	if (soap_out_PointerTons1__Classification(soap, tag?tag:"ns1:Classification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Classification ** SOAP_FMAC4 soap_get_PointerTons1__Classification(struct soap *soap, ns1__Classification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Classification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SchemaVersion(struct soap *soap, ns2__SchemaVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SchemaVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SchemaVersion(struct soap *soap, const char *tag, int id, ns2__SchemaVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SchemaVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SchemaVersion ** SOAP_FMAC4 soap_in_PointerTons2__SchemaVersion(struct soap *soap, const char *tag, ns2__SchemaVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SchemaVersion **)soap_malloc(soap, sizeof(ns2__SchemaVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SchemaVersion *)soap_instantiate_ns2__SchemaVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SchemaVersion ** p = (ns2__SchemaVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SchemaVersion, sizeof(ns2__SchemaVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SchemaVersion(struct soap *soap, ns2__SchemaVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SchemaVersion);
	if (soap_out_PointerTons2__SchemaVersion(soap, tag?tag:"ns2:SchemaVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SchemaVersion ** SOAP_FMAC4 soap_get_PointerTons2__SchemaVersion(struct soap *soap, ns2__SchemaVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SchemaVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__KeySetExtensions(struct soap *soap, ns2__KeySetExtensions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__KeySetExtensions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__KeySetExtensions(struct soap *soap, const char *tag, int id, ns2__KeySetExtensions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__KeySetExtensions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__KeySetExtensions ** SOAP_FMAC4 soap_in_PointerTons2__KeySetExtensions(struct soap *soap, const char *tag, ns2__KeySetExtensions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__KeySetExtensions **)soap_malloc(soap, sizeof(ns2__KeySetExtensions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__KeySetExtensions *)soap_instantiate_ns2__KeySetExtensions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__KeySetExtensions ** p = (ns2__KeySetExtensions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__KeySetExtensions, sizeof(ns2__KeySetExtensions), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__KeySetExtensions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DesktopKeySetExtensions, sizeof(ns1__DesktopKeySetExtensions), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__KeySetExtensions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RawKeySetExtensions, sizeof(ns2__RawKeySetExtensions), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns2__KeySetExtensions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__WrappedKeySetExtensions, sizeof(ns2__WrappedKeySetExtensions), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__KeySetExtensions(struct soap *soap, ns2__KeySetExtensions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__KeySetExtensions);
	if (soap_out_PointerTons2__KeySetExtensions(soap, tag?tag:"ns2:KeySetExtensions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__KeySetExtensions ** SOAP_FMAC4 soap_get_PointerTons2__KeySetExtensions(struct soap *soap, ns2__KeySetExtensions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__KeySetExtensions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__CryptoSchemaRef(struct soap *soap, ns2__CryptoSchemaRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__CryptoSchemaRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__CryptoSchemaRef(struct soap *soap, const char *tag, int id, ns2__CryptoSchemaRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__CryptoSchemaRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__CryptoSchemaRef ** SOAP_FMAC4 soap_in_PointerTons2__CryptoSchemaRef(struct soap *soap, const char *tag, ns2__CryptoSchemaRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__CryptoSchemaRef **)soap_malloc(soap, sizeof(ns2__CryptoSchemaRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__CryptoSchemaRef *)soap_instantiate_ns2__CryptoSchemaRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__CryptoSchemaRef ** p = (ns2__CryptoSchemaRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__CryptoSchemaRef, sizeof(ns2__CryptoSchemaRef), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__CryptoSchemaRef(struct soap *soap, ns2__CryptoSchemaRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__CryptoSchemaRef);
	if (soap_out_PointerTons2__CryptoSchemaRef(soap, tag?tag:"ns2:CryptoSchemaRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__CryptoSchemaRef ** SOAP_FMAC4 soap_get_PointerTons2__CryptoSchemaRef(struct soap *soap, ns2__CryptoSchemaRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__CryptoSchemaRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ClassificationFilter(struct soap *soap, ns1__ClassificationFilter *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ClassificationFilter))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ClassificationFilter(struct soap *soap, const char *tag, int id, ns1__ClassificationFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ClassificationFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ClassificationFilter ** SOAP_FMAC4 soap_in_PointerTons1__ClassificationFilter(struct soap *soap, const char *tag, ns1__ClassificationFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ClassificationFilter **)soap_malloc(soap, sizeof(ns1__ClassificationFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ClassificationFilter *)soap_instantiate_ns1__ClassificationFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ClassificationFilter ** p = (ns1__ClassificationFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ClassificationFilter, sizeof(ns1__ClassificationFilter), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__ClassificationFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__XPathClassificationFilter, sizeof(ns1__XPathClassificationFilter), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ClassificationFilter(struct soap *soap, ns1__ClassificationFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ClassificationFilter);
	if (soap_out_PointerTons1__ClassificationFilter(soap, tag?tag:"ns1:ClassificationFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ClassificationFilter ** SOAP_FMAC4 soap_get_PointerTons1__ClassificationFilter(struct soap *soap, ns1__ClassificationFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ClassificationFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TimePeriod(struct soap *soap, ns1__TimePeriod *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TimePeriod))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TimePeriod(struct soap *soap, const char *tag, int id, ns1__TimePeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TimePeriod);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TimePeriod ** SOAP_FMAC4 soap_in_PointerTons1__TimePeriod(struct soap *soap, const char *tag, ns1__TimePeriod **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TimePeriod **)soap_malloc(soap, sizeof(ns1__TimePeriod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TimePeriod *)soap_instantiate_ns1__TimePeriod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TimePeriod ** p = (ns1__TimePeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TimePeriod, sizeof(ns1__TimePeriod), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TimePeriod(struct soap *soap, ns1__TimePeriod *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TimePeriod);
	if (soap_out_PointerTons1__TimePeriod(soap, tag?tag:"ns1:TimePeriod", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TimePeriod ** SOAP_FMAC4 soap_get_PointerTons1__TimePeriod(struct soap *soap, ns1__TimePeriod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TimePeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TimeSpan(struct soap *soap, ns1__TimeSpan *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TimeSpan))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TimeSpan(struct soap *soap, const char *tag, int id, ns1__TimeSpan *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TimeSpan);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TimeSpan ** SOAP_FMAC4 soap_in_PointerTons1__TimeSpan(struct soap *soap, const char *tag, ns1__TimeSpan **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TimeSpan **)soap_malloc(soap, sizeof(ns1__TimeSpan *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TimeSpan *)soap_instantiate_ns1__TimeSpan(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TimeSpan ** p = (ns1__TimeSpan **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TimeSpan, sizeof(ns1__TimeSpan), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__TimeSpan **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RelativeTimeSpan, sizeof(ns1__RelativeTimeSpan), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__TimeSpan **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AbsoluteTimeSpan, sizeof(ns1__AbsoluteTimeSpan), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TimeSpan(struct soap *soap, ns1__TimeSpan *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TimeSpan);
	if (soap_out_PointerTons1__TimeSpan(soap, tag?tag:"ns1:TimeSpan", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TimeSpan ** SOAP_FMAC4 soap_get_PointerTons1__TimeSpan(struct soap *soap, ns1__TimeSpan **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TimeSpan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Feature(struct soap *soap, ns1__Feature *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Feature))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Feature(struct soap *soap, const char *tag, int id, ns1__Feature *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Feature);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Feature ** SOAP_FMAC4 soap_in_PointerTons1__Feature(struct soap *soap, const char *tag, ns1__Feature **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Feature **)soap_malloc(soap, sizeof(ns1__Feature *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Feature *)soap_instantiate_ns1__Feature(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Feature ** p = (ns1__Feature **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Feature, sizeof(ns1__Feature), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Feature(struct soap *soap, ns1__Feature *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Feature);
	if (soap_out_PointerTons1__Feature(soap, tag?tag:"ns1:Feature", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Feature ** SOAP_FMAC4 soap_get_PointerTons1__Feature(struct soap *soap, ns1__Feature **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Feature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Label(struct soap *soap, ns1__Label *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Label))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Label(struct soap *soap, const char *tag, int id, ns1__Label *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Label);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Label ** SOAP_FMAC4 soap_in_PointerTons1__Label(struct soap *soap, const char *tag, ns1__Label **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Label **)soap_malloc(soap, sizeof(ns1__Label *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Label *)soap_instantiate_ns1__Label(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Label ** p = (ns1__Label **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Label, sizeof(ns1__Label), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Label(struct soap *soap, ns1__Label *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Label);
	if (soap_out_PointerTons1__Label(soap, tag?tag:"ns1:Label", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Label ** SOAP_FMAC4 soap_get_PointerTons1__Label(struct soap *soap, ns1__Label **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Label(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__KeySetRef(struct soap *soap, ns2__KeySetRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__KeySetRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__KeySetRef(struct soap *soap, const char *tag, int id, ns2__KeySetRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__KeySetRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__KeySetRef ** SOAP_FMAC4 soap_in_PointerTons2__KeySetRef(struct soap *soap, const char *tag, ns2__KeySetRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__KeySetRef **)soap_malloc(soap, sizeof(ns2__KeySetRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__KeySetRef *)soap_instantiate_ns2__KeySetRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__KeySetRef ** p = (ns2__KeySetRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__KeySetRef, sizeof(ns2__KeySetRef), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__KeySetRef(struct soap *soap, ns2__KeySetRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__KeySetRef);
	if (soap_out_PointerTons2__KeySetRef(soap, tag?tag:"ns2:KeySetRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__KeySetRef ** SOAP_FMAC4 soap_get_PointerTons2__KeySetRef(struct soap *soap, ns2__KeySetRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__KeySetRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ClassificationSystemRef(struct soap *soap, ns1__ClassificationSystemRef *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ClassificationSystemRef))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ClassificationSystemRef(struct soap *soap, const char *tag, int id, ns1__ClassificationSystemRef *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ClassificationSystemRef);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ClassificationSystemRef ** SOAP_FMAC4 soap_in_PointerTons1__ClassificationSystemRef(struct soap *soap, const char *tag, ns1__ClassificationSystemRef **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ClassificationSystemRef **)soap_malloc(soap, sizeof(ns1__ClassificationSystemRef *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ClassificationSystemRef *)soap_instantiate_ns1__ClassificationSystemRef(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ClassificationSystemRef ** p = (ns1__ClassificationSystemRef **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ClassificationSystemRef, sizeof(ns1__ClassificationSystemRef), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ClassificationSystemRef(struct soap *soap, ns1__ClassificationSystemRef *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ClassificationSystemRef);
	if (soap_out_PointerTons1__ClassificationSystemRef(soap, tag?tag:"ns1:ClassificationSystemRef", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ClassificationSystemRef ** SOAP_FMAC4 soap_get_PointerTons1__ClassificationSystemRef(struct soap *soap, ns1__ClassificationSystemRef **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ClassificationSystemRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__ContextInstanceRef(struct soap *soap, std::vector<ns6__ContextInstanceRef * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__ContextInstanceRef(struct soap *soap, const std::vector<ns6__ContextInstanceRef * >*a)
{
	for (std::vector<ns6__ContextInstanceRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__ContextInstanceRef(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__ContextInstanceRef(struct soap *soap, const char *tag, int id, const std::vector<ns6__ContextInstanceRef * >*a, const char *type)
{
	for (std::vector<ns6__ContextInstanceRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__ContextInstanceRef(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__ContextInstanceRef * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__ContextInstanceRef(struct soap *soap, const char *tag, std::vector<ns6__ContextInstanceRef * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__ContextInstanceRef(soap, -1)))
		return NULL;
	ns6__ContextInstanceRef *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns6__ContextInstanceRef, SOAP_TYPE_std__vectorTemplateOfPointerTons6__ContextInstanceRef, sizeof(ns6__ContextInstanceRef), 1))
				break;
			if (!soap_in_PointerTons6__ContextInstanceRef(soap, tag, NULL, "ns6:ContextInstanceRef"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons6__ContextInstanceRef(soap, tag, &n, "ns6:ContextInstanceRef"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__ContextInstanceRef * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons6__ContextInstanceRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons6__ContextInstanceRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons6__ContextInstanceRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns6__ContextInstanceRef * >);
		if (size)
			*size = sizeof(std::vector<ns6__ContextInstanceRef * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns6__ContextInstanceRef * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns6__ContextInstanceRef * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns6__ContextInstanceRef * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons6__ContextInstanceRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns6__ContextInstanceRef * > %p -> %p\n", q, p));
	*(std::vector<ns6__ContextInstanceRef * >*)p = *(std::vector<ns6__ContextInstanceRef * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__DocumentRightRef(struct soap *soap, std::vector<ns6__DocumentRightRef * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRightRef(struct soap *soap, const std::vector<ns6__DocumentRightRef * >*a)
{
	for (std::vector<ns6__DocumentRightRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__DocumentRightRef(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__DocumentRightRef(struct soap *soap, const char *tag, int id, const std::vector<ns6__DocumentRightRef * >*a, const char *type)
{
	for (std::vector<ns6__DocumentRightRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__DocumentRightRef(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__DocumentRightRef * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__DocumentRightRef(struct soap *soap, const char *tag, std::vector<ns6__DocumentRightRef * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__DocumentRightRef(soap, -1)))
		return NULL;
	ns6__DocumentRightRef *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns6__DocumentRightRef, SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRightRef, sizeof(ns6__DocumentRightRef), 1))
				break;
			if (!soap_in_PointerTons6__DocumentRightRef(soap, tag, NULL, "ns6:DocumentRightRef"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons6__DocumentRightRef(soap, tag, &n, "ns6:DocumentRightRef"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__DocumentRightRef * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons6__DocumentRightRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons6__DocumentRightRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRightRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns6__DocumentRightRef * >);
		if (size)
			*size = sizeof(std::vector<ns6__DocumentRightRef * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns6__DocumentRightRef * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns6__DocumentRightRef * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns6__DocumentRightRef * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons6__DocumentRightRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns6__DocumentRightRef * > %p -> %p\n", q, p));
	*(std::vector<ns6__DocumentRightRef * >*)p = *(std::vector<ns6__DocumentRightRef * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__DocumentRight(struct soap *soap, std::vector<ns6__DocumentRight * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRight(struct soap *soap, const std::vector<ns6__DocumentRight * >*a)
{
	for (std::vector<ns6__DocumentRight * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__DocumentRight(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__DocumentRight(struct soap *soap, const char *tag, int id, const std::vector<ns6__DocumentRight * >*a, const char *type)
{
	for (std::vector<ns6__DocumentRight * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__DocumentRight(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__DocumentRight * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__DocumentRight(struct soap *soap, const char *tag, std::vector<ns6__DocumentRight * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__DocumentRight(soap, -1)))
		return NULL;
	ns6__DocumentRight *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns6__DocumentRight, SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRight, sizeof(ns6__DocumentRight), 1))
				break;
			if (!soap_in_PointerTons6__DocumentRight(soap, tag, NULL, "ns6:DocumentRight"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons6__DocumentRight(soap, tag, &n, "ns6:DocumentRight"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__DocumentRight * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons6__DocumentRight(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons6__DocumentRight(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRight, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns6__DocumentRight * >);
		if (size)
			*size = sizeof(std::vector<ns6__DocumentRight * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns6__DocumentRight * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns6__DocumentRight * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns6__DocumentRight * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons6__DocumentRight(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns6__DocumentRight * > %p -> %p\n", q, p));
	*(std::vector<ns6__DocumentRight * >*)p = *(std::vector<ns6__DocumentRight * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__AccountRef(struct soap *soap, std::vector<ns1__AccountRef * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__AccountRef(struct soap *soap, const std::vector<ns1__AccountRef * >*a)
{
	for (std::vector<ns1__AccountRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__AccountRef(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__AccountRef(struct soap *soap, const char *tag, int id, const std::vector<ns1__AccountRef * >*a, const char *type)
{
	for (std::vector<ns1__AccountRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__AccountRef(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__AccountRef * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__AccountRef(struct soap *soap, const char *tag, std::vector<ns1__AccountRef * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__AccountRef(soap, -1)))
		return NULL;
	ns1__AccountRef *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__AccountRef, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccountRef, sizeof(ns1__AccountRef), 1))
				break;
			if (!soap_in_PointerTons1__AccountRef(soap, tag, NULL, "ns1:AccountRef"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__AccountRef(soap, tag, &n, "ns1:AccountRef"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__AccountRef * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__AccountRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__AccountRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__AccountRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__AccountRef * >);
		if (size)
			*size = sizeof(std::vector<ns1__AccountRef * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__AccountRef * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__AccountRef * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__AccountRef * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__AccountRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__AccountRef * > %p -> %p\n", q, p));
	*(std::vector<ns1__AccountRef * >*)p = *(std::vector<ns1__AccountRef * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons6__DocumentRoleRef(struct soap *soap, std::vector<ns6__DocumentRoleRef * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons6__DocumentRoleRef(struct soap *soap, const std::vector<ns6__DocumentRoleRef * >*a)
{
	for (std::vector<ns6__DocumentRoleRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons6__DocumentRoleRef(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons6__DocumentRoleRef(struct soap *soap, const char *tag, int id, const std::vector<ns6__DocumentRoleRef * >*a, const char *type)
{
	for (std::vector<ns6__DocumentRoleRef * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons6__DocumentRoleRef(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns6__DocumentRoleRef * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons6__DocumentRoleRef(struct soap *soap, const char *tag, std::vector<ns6__DocumentRoleRef * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons6__DocumentRoleRef(soap, -1)))
		return NULL;
	ns6__DocumentRoleRef *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns6__DocumentRoleRef, SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRoleRef, sizeof(ns6__DocumentRoleRef), 1))
				break;
			if (!soap_in_PointerTons6__DocumentRoleRef(soap, tag, NULL, "ns6:DocumentRoleRef"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons6__DocumentRoleRef(soap, tag, &n, "ns6:DocumentRoleRef"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns6__DocumentRoleRef * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons6__DocumentRoleRef(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons6__DocumentRoleRef(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons6__DocumentRoleRef, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns6__DocumentRoleRef * >);
		if (size)
			*size = sizeof(std::vector<ns6__DocumentRoleRef * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns6__DocumentRoleRef * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns6__DocumentRoleRef * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns6__DocumentRoleRef * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons6__DocumentRoleRef(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns6__DocumentRoleRef * > %p -> %p\n", q, p));
	*(std::vector<ns6__DocumentRoleRef * >*)p = *(std::vector<ns6__DocumentRoleRef * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons5__ItemCode(struct soap *soap, std::vector<ns5__ItemCode * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons5__ItemCode(struct soap *soap, const std::vector<ns5__ItemCode * >*a)
{
	for (std::vector<ns5__ItemCode * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons5__ItemCode(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons5__ItemCode(struct soap *soap, const char *tag, int id, const std::vector<ns5__ItemCode * >*a, const char *type)
{
	for (std::vector<ns5__ItemCode * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons5__ItemCode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns5__ItemCode * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons5__ItemCode(struct soap *soap, const char *tag, std::vector<ns5__ItemCode * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons5__ItemCode(soap, -1)))
		return NULL;
	ns5__ItemCode *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns5__ItemCode, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ItemCode, sizeof(ns5__ItemCode), 1))
				break;
			if (!soap_in_PointerTons5__ItemCode(soap, tag, NULL, "ns5:ItemCode"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons5__ItemCode(soap, tag, &n, "ns5:ItemCode"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns5__ItemCode * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons5__ItemCode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons5__ItemCode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons5__ItemCode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__ItemCode * >);
		if (size)
			*size = sizeof(std::vector<ns5__ItemCode * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns5__ItemCode * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns5__ItemCode * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns5__ItemCode * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons5__ItemCode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns5__ItemCode * > %p -> %p\n", q, p));
	*(std::vector<ns5__ItemCode * >*)p = *(std::vector<ns5__ItemCode * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons2__CustomData(struct soap *soap, std::vector<ns2__CustomData * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons2__CustomData(struct soap *soap, const std::vector<ns2__CustomData * >*a)
{
	for (std::vector<ns2__CustomData * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons2__CustomData(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons2__CustomData(struct soap *soap, const char *tag, int id, const std::vector<ns2__CustomData * >*a, const char *type)
{
	for (std::vector<ns2__CustomData * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons2__CustomData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns2__CustomData * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons2__CustomData(struct soap *soap, const char *tag, std::vector<ns2__CustomData * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons2__CustomData(soap, -1)))
		return NULL;
	ns2__CustomData *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns2__CustomData, SOAP_TYPE_std__vectorTemplateOfPointerTons2__CustomData, sizeof(ns2__CustomData), 1))
				break;
			if (!soap_in_PointerTons2__CustomData(soap, tag, NULL, "ns2:CustomData"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons2__CustomData(soap, tag, &n, "ns2:CustomData"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns2__CustomData * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons2__CustomData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons2__CustomData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons2__CustomData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__CustomData * >);
		if (size)
			*size = sizeof(std::vector<ns2__CustomData * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns2__CustomData * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns2__CustomData * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns2__CustomData * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons2__CustomData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns2__CustomData * > %p -> %p\n", q, p));
	*(std::vector<ns2__CustomData * >*)p = *(std::vector<ns2__CustomData * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<xsd__QName >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<xsd__QName >*a)
{
	for (std::vector<xsd__QName >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<xsd__QName >*a, const char *type)
{
	for (std::vector<xsd__QName >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<xsd__QName >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<xsd__QName >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap, -1)))
		return NULL;
	xsd__QName n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_xsd__QName(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(xsd__QName), 0))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else
		{
			if (!soap_in_xsd__QName(soap, tag, &n, "xsd:QName"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<xsd__QName > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<xsd__QName >);
		if (size)
			*size = sizeof(std::vector<xsd__QName >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<xsd__QName >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<xsd__QName >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<xsd__QName >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<xsd__QName > %p -> %p\n", q, p));
	*(std::vector<xsd__QName >*)p = *(std::vector<xsd__QName >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__TimeSpan(struct soap *soap, std::vector<ns1__TimeSpan * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__TimeSpan(struct soap *soap, const std::vector<ns1__TimeSpan * >*a)
{
	for (std::vector<ns1__TimeSpan * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__TimeSpan(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__TimeSpan(struct soap *soap, const char *tag, int id, const std::vector<ns1__TimeSpan * >*a, const char *type)
{
	for (std::vector<ns1__TimeSpan * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__TimeSpan(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__TimeSpan * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__TimeSpan(struct soap *soap, const char *tag, std::vector<ns1__TimeSpan * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__TimeSpan(soap, -1)))
		return NULL;
	ns1__TimeSpan *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__TimeSpan, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TimeSpan, sizeof(ns1__TimeSpan), 1))
				break;
			if (!soap_in_PointerTons1__TimeSpan(soap, tag, NULL, "ns1:TimeSpan"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__TimeSpan(soap, tag, &n, "ns1:TimeSpan"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__TimeSpan * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__TimeSpan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__TimeSpan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TimeSpan, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__TimeSpan * >);
		if (size)
			*size = sizeof(std::vector<ns1__TimeSpan * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__TimeSpan * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__TimeSpan * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__TimeSpan * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__TimeSpan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__TimeSpan * > %p -> %p\n", q, p));
	*(std::vector<ns1__TimeSpan * >*)p = *(std::vector<ns1__TimeSpan * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Feature(struct soap *soap, std::vector<ns1__Feature * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Feature(struct soap *soap, const std::vector<ns1__Feature * >*a)
{
	for (std::vector<ns1__Feature * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Feature(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Feature(struct soap *soap, const char *tag, int id, const std::vector<ns1__Feature * >*a, const char *type)
{
	for (std::vector<ns1__Feature * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Feature(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Feature * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Feature(struct soap *soap, const char *tag, std::vector<ns1__Feature * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Feature(soap, -1)))
		return NULL;
	ns1__Feature *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Feature, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Feature, sizeof(ns1__Feature), 1))
				break;
			if (!soap_in_PointerTons1__Feature(soap, tag, NULL, "ns1:Feature"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__Feature(soap, tag, &n, "ns1:Feature"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Feature * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Feature(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Feature(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Feature, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Feature * >);
		if (size)
			*size = sizeof(std::vector<ns1__Feature * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Feature * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__Feature * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__Feature * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__Feature(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__Feature * > %p -> %p\n", q, p));
	*(std::vector<ns1__Feature * >*)p = *(std::vector<ns1__Feature * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Label(struct soap *soap, std::vector<ns1__Label * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Label(struct soap *soap, const std::vector<ns1__Label * >*a)
{
	for (std::vector<ns1__Label * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Label(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Label(struct soap *soap, const char *tag, int id, const std::vector<ns1__Label * >*a, const char *type)
{
	for (std::vector<ns1__Label * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Label(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Label * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Label(struct soap *soap, const char *tag, std::vector<ns1__Label * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Label(soap, -1)))
		return NULL;
	ns1__Label *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__Label, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Label, sizeof(ns1__Label), 1))
				break;
			if (!soap_in_PointerTons1__Label(soap, tag, NULL, "ns1:Label"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__Label(soap, tag, &n, "ns1:Label"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Label * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Label(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Label(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Label, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Label * >);
		if (size)
			*size = sizeof(std::vector<ns1__Label * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__Label * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__Label * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__Label * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__Label(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__Label * > %p -> %p\n", q, p));
	*(std::vector<ns1__Label * >*)p = *(std::vector<ns1__Label * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
