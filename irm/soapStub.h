/* soapStub.h
   Generated by gSOAP 2.7.16 from IRM.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://xmlns.oracle.com/irm/core"
#define SOAP_NAMESPACE_OF_ns2	"http://xmlns.oracle.com/irm/content"
#define SOAP_NAMESPACE_OF_ns3	"http://xmlns.oracle.com/irm/system"
#define SOAP_NAMESPACE_OF_ns4	"http://xmlns.oracle.com/irm/content/wsdl"
#define SOAP_NAMESPACE_OF_ns5	"http://xmlns.oracle.com/irm/classifications"
#define SOAP_NAMESPACE_OF_ns6	"http://xmlns.oracle.com/irm/rights"
#define SOAP_NAMESPACE_OF_ns7	"http://xmlns.oracle.com/irm/rights/wsdl"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__LicenseCriteria_USCOREStorage
#define SOAP_TYPE_ns1__LicenseCriteria_USCOREStorage (96)
/* ns1:LicenseCriteria_Storage */
enum ns1__LicenseCriteria_USCOREStorage {ns1__LicenseCriteria_USCOREStorage__PERSISTENT = 0, ns1__LicenseCriteria_USCOREStorage__TRANSIENT = 1, ns1__LicenseCriteria_USCOREStorage__ANY = 2};
#endif

#ifndef SOAP_TYPE_ns1__LicenseCriteria_USCOREDelivery
#define SOAP_TYPE_ns1__LicenseCriteria_USCOREDelivery (97)
/* ns1:LicenseCriteria_Delivery */
enum ns1__LicenseCriteria_USCOREDelivery {ns1__LicenseCriteria_USCOREDelivery__SYNCHRONIZATION = 0, ns1__LicenseCriteria_USCOREDelivery__ON_USCOREDEMAND = 1, ns1__LicenseCriteria_USCOREDelivery__CLIENT = 2};
#endif

#ifndef SOAP_TYPE_ns1__LicenseCriteria_USCOREUse
#define SOAP_TYPE_ns1__LicenseCriteria_USCOREUse (98)
/* ns1:LicenseCriteria_Use */
enum ns1__LicenseCriteria_USCOREUse {ns1__LicenseCriteria_USCOREUse__PRIMARY = 0, ns1__LicenseCriteria_USCOREUse__SECONDARY = 1};
#endif

#ifndef SOAP_TYPE_ns1__Feature_USCORESupport
#define SOAP_TYPE_ns1__Feature_USCORESupport (99)
/* ns1:Feature_Support */
enum ns1__Feature_USCORESupport {ns1__Feature_USCORESupport__AVAILABLE = 0, ns1__Feature_USCORESupport__ON_USCOREDEMAND = 1, ns1__Feature_USCORESupport__UNAVAILABLE = 2};
#endif

#ifndef SOAP_TYPE_ns1__Feature_USCOREUse
#define SOAP_TYPE_ns1__Feature_USCOREUse (100)
/* ns1:Feature_Use */
enum ns1__Feature_USCOREUse {ns1__Feature_USCOREUse__IMMEDIATE = 0, ns1__Feature_USCOREUse__DEMAND = 1};
#endif

#ifndef SOAP_TYPE_ns1__TimeSpan_USCOREReferencePoint
#define SOAP_TYPE_ns1__TimeSpan_USCOREReferencePoint (101)
/* ns1:TimeSpan_ReferencePoint */
enum ns1__TimeSpan_USCOREReferencePoint {ns1__TimeSpan_USCOREReferencePoint__CURRENT = 0, ns1__TimeSpan_USCOREReferencePoint__CLASSIFICATION = 1, ns1__TimeSpan_USCOREReferencePoint__LICENSE = 2};
#endif

#ifndef SOAP_TYPE_ns1__TimePeriod_USCOREUnits
#define SOAP_TYPE_ns1__TimePeriod_USCOREUnits (102)
/* ns1:TimePeriod_Units */
enum ns1__TimePeriod_USCOREUnits {ns1__TimePeriod_USCOREUnits__SECONDS = 0, ns1__TimePeriod_USCOREUnits__MINUTES = 1, ns1__TimePeriod_USCOREUnits__HOURS = 2, ns1__TimePeriod_USCOREUnits__DAYS = 3, ns1__TimePeriod_USCOREUnits__MONTHS = 4, ns1__TimePeriod_USCOREUnits__YEARS = 5};
#endif

#ifndef SOAP_TYPE_ns1__RelativeTimeSpan_USCORETimeBase
#define SOAP_TYPE_ns1__RelativeTimeSpan_USCORETimeBase (103)
/* ns1:RelativeTimeSpan_TimeBase */
enum ns1__RelativeTimeSpan_USCORETimeBase {ns1__RelativeTimeSpan_USCORETimeBase__CLASSIFICATION = 0, ns1__RelativeTimeSpan_USCORETimeBase__LICENSE = 1, ns1__RelativeTimeSpan_USCORETimeBase__REQUEST = 2};
#endif

#ifndef SOAP_TYPE_ns1__Account_USCOREType
#define SOAP_TYPE_ns1__Account_USCOREType (104)
/* ns1:Account_Type */
enum ns1__Account_USCOREType {ns1__Account_USCOREType__USER = 0, ns1__Account_USCOREType__GROUP = 1};
#endif

#ifndef SOAP_TYPE_ns2__ContentParseFault_USCOREReason
#define SOAP_TYPE_ns2__ContentParseFault_USCOREReason (105)
/* ns2:ContentParseFault_Reason */
enum ns2__ContentParseFault_USCOREReason {ns2__ContentParseFault_USCOREReason__CONTENT_USCORETRUNCATED = 0, ns2__ContentParseFault_USCOREReason__XML_USCOREBLOCK_USCOREINVALID_USCORESIZE = 1, ns2__ContentParseFault_USCOREReason__XML_USCOREBLOCK_USCOREEMPTY = 2, ns2__ContentParseFault_USCOREReason__XML_USCOREBLOCK_USCORETRUNCATED = 3, ns2__ContentParseFault_USCOREReason__PREAMBLE_USCORENOT_USCOREFOUND = 4, ns2__ContentParseFault_USCOREReason__MAGIC_USCORENOT_USCOREFOUND = 5, ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCOREMISSING = 6, ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORECORRUPT = 7, ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORESIGNATURE_USCOREMISMATCH = 8, ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORESIGNATURE_USCOREMISSING = 9, ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCORESIGNATURE_USCORECORRUPT = 10, ns2__ContentParseFault_USCOREReason__PUBLIC_USCOREHEADER_USCOREDATA_USCOREDIGEST_USCOREMISMATCH = 11, ns2__ContentParseFault_USCOREReason__PRIVATE_USCOREBLOCK_USCOREDIGEST_USCOREMISMATCH = 12, ns2__ContentParseFault_USCOREReason__PRIVATE_USCOREHEADER_USCORECORRUPT = 13};
#endif

#ifndef SOAP_TYPE_ns5__ItemConstraints_USCOREType
#define SOAP_TYPE_ns5__ItemConstraints_USCOREType (106)
/* ns5:ItemConstraints_Type */
enum ns5__ItemConstraints_USCOREType {ns5__ItemConstraints_USCOREType__LOCKS = 0, ns5__ItemConstraints_USCOREType__EXCLUSIONS = 1};
#endif

#ifndef SOAP_TYPE_ns6__ContextInstance_USCOREVisibility
#define SOAP_TYPE_ns6__ContextInstance_USCOREVisibility (107)
/* ns6:ContextInstance_Visibility */
enum ns6__ContextInstance_USCOREVisibility {ns6__ContextInstance_USCOREVisibility__DOMAIN = 0, ns6__ContextInstance_USCOREVisibility__CONTEXT = 1};
#endif

#ifndef SOAP_TYPE_ns6__ContextInstance_USCORERole
#define SOAP_TYPE_ns6__ContextInstance_USCORERole (108)
/* ns6:ContextInstance_Role */
enum ns6__ContextInstance_USCORERole {ns6__ContextInstance_USCORERole__NONE = 0, ns6__ContextInstance_USCORERole__MANAGER = 1, ns6__ContextInstance_USCORERole__INSPECTOR = 2};
#endif

#ifndef SOAP_TYPE_ns6__ContextTemplate_USCOREStatus
#define SOAP_TYPE_ns6__ContextTemplate_USCOREStatus (109)
/* ns6:ContextTemplate_Status */
enum ns6__ContextTemplate_USCOREStatus {ns6__ContextTemplate_USCOREStatus__INACTIVE = 0, ns6__ContextTemplate_USCOREStatus__ACTIVE = 1};
#endif

#ifndef SOAP_TYPE_ns6__DocumentRole_USCOREExportConstraints
#define SOAP_TYPE_ns6__DocumentRole_USCOREExportConstraints (110)
/* ns6:DocumentRole_ExportConstraints */
enum ns6__DocumentRole_USCOREExportConstraints {ns6__DocumentRole_USCOREExportConstraints__FULL = 0, ns6__DocumentRole_USCOREExportConstraints__TRUSTED = 1, ns6__DocumentRole_USCOREExportConstraints__NONE = 2};
#endif

#ifndef SOAP_TYPE_ns6__DocumentRole_USCORETimeConstraints
#define SOAP_TYPE_ns6__DocumentRole_USCORETimeConstraints (111)
/* ns6:DocumentRole_TimeConstraints */
enum ns6__DocumentRole_USCORETimeConstraints {ns6__DocumentRole_USCORETimeConstraints__NONE = 0, ns6__DocumentRole_USCORETimeConstraints__ABSOLUTE = 1, ns6__DocumentRole_USCORETimeConstraints__RELATIVE_USCOREASSIGNMENT = 2, ns6__DocumentRole_USCORETimeConstraints__RELATIVE_USCORECLASSIFICATION = 3, ns6__DocumentRole_USCORETimeConstraints__OTHER = 4};
#endif

#ifndef SOAP_TYPE_ns6__Domain_USCORERole
#define SOAP_TYPE_ns6__Domain_USCORERole (112)
/* ns6:Domain_Role */
enum ns6__Domain_USCORERole {ns6__Domain_USCORERole__NONE = 0, ns6__Domain_USCORERole__ADMINISTRATOR = 1, ns6__Domain_USCORERole__MANAGER = 2, ns6__Domain_USCORERole__INSPECTOR = 3};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (9)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (11)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary(): __ptr(NULL), id(NULL), type(NULL), options(NULL), soap(NULL) { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ClassificationSystem
#define SOAP_TYPE_ns1__ClassificationSystem (16)
/* ns1:ClassificationSystem */
class SOAP_CMAC ns1__ClassificationSystem
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__ClassificationSystem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ClassificationSystem(): soap(NULL) { ns1__ClassificationSystem::soap_default(NULL); }
	virtual ~ns1__ClassificationSystem() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ClassificationSystemRef
#define SOAP_TYPE_ns1__ClassificationSystemRef (17)
/* ns1:ClassificationSystemRef */
class SOAP_CMAC ns1__ClassificationSystemRef
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__ClassificationSystemRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ClassificationSystemRef(): soap(NULL) { ns1__ClassificationSystemRef::soap_default(NULL); }
	virtual ~ns1__ClassificationSystemRef() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Label
#define SOAP_TYPE_ns1__Label (19)
/* ns1:Label */
class SOAP_CMAC ns1__Label
{
public:
	std::string locale;	/* required element of type xsd:string */
	std::string name;	/* required element of type xsd:string */
	std::string *description;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__Label */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Label(): description(NULL), soap(NULL) { ns1__Label::soap_default(NULL); }
	virtual ~ns1__Label() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Classification
#define SOAP_TYPE_ns1__Classification (20)
/* ns1:Classification */
class SOAP_CMAC ns1__Classification
{
public:
	std::string id;	/* required element of type xsd:string */
	ns1__ClassificationSystemRef *system;	/* required element of type ns1:ClassificationSystemRef */
	class ns2__KeySetRef *keySet;	/* optional element of type ns2:KeySetRef */
	std::string uri;	/* required element of type xsd:anyURI */
	time_t *classificationTime;	/* optional element of type xsd:dateTime */
	std::vector<ns1__Label * >labels;	/* optional element of type ns1:Label */
	char *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__Classification */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Classification(): system(NULL), keySet(NULL), classificationTime(NULL), __any(NULL), soap(NULL) { ns1__Classification::soap_default(NULL); }
	virtual ~ns1__Classification() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LicenseCriteria
#define SOAP_TYPE_ns1__LicenseCriteria (21)
/* ns1:LicenseCriteria */
class SOAP_CMAC ns1__LicenseCriteria
{
public:
	enum ns1__LicenseCriteria_USCOREStorage storage;	/* required element of type ns1:LicenseCriteria_Storage */
	enum ns1__LicenseCriteria_USCOREDelivery delivery;	/* required element of type ns1:LicenseCriteria_Delivery */
	enum ns1__LicenseCriteria_USCOREUse use;	/* required element of type ns1:LicenseCriteria_Use */
	std::vector<class ns1__Feature * >features;	/* required element of type ns1:Feature */
	std::vector<class ns1__TimeSpan * >timeSpans;	/* optional element of type ns1:TimeSpan */
	class ns1__TimePeriod *refreshPeriod;	/* optional element of type ns1:TimePeriod */
	class ns1__ClassificationFilter *classifications;	/* required element of type ns1:ClassificationFilter */
	ns1__ClassificationFilter *destinations;	/* optional element of type ns1:ClassificationFilter */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__LicenseCriteria */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LicenseCriteria(): refreshPeriod(NULL), classifications(NULL), destinations(NULL), soap(NULL) { ns1__LicenseCriteria::soap_default(NULL); }
	virtual ~ns1__LicenseCriteria() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Feature
#define SOAP_TYPE_ns1__Feature (22)
/* ns1:Feature */
class SOAP_CMAC ns1__Feature
{
public:
	std::string id;	/* required element of type xsd:string */
	enum ns1__Feature_USCOREUse use;	/* required element of type ns1:Feature_Use */
	bool record;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__Feature */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Feature(): soap(NULL) { ns1__Feature::soap_default(NULL); }
	virtual ~ns1__Feature() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TimeSpan
#define SOAP_TYPE_ns1__TimeSpan (23)
/* ns1:TimeSpan */
class SOAP_CMAC ns1__TimeSpan
{
public:
	enum ns1__TimeSpan_USCOREReferencePoint referencePoint;	/* required element of type ns1:TimeSpan_ReferencePoint */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__TimeSpan */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TimeSpan(): soap(NULL) { ns1__TimeSpan::soap_default(NULL); }
	virtual ~ns1__TimeSpan() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TimePeriod
#define SOAP_TYPE_ns1__TimePeriod (24)
/* ns1:TimePeriod */
class SOAP_CMAC ns1__TimePeriod
{
public:
	int amount;	/* required element of type xsd:int */
	enum ns1__TimePeriod_USCOREUnits units;	/* required element of type ns1:TimePeriod_Units */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__TimePeriod */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TimePeriod(): soap(NULL) { ns1__TimePeriod::soap_default(NULL); }
	virtual ~ns1__TimePeriod() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ClassificationFilter
#define SOAP_TYPE_ns1__ClassificationFilter (25)
/* ns1:ClassificationFilter */
class SOAP_CMAC ns1__ClassificationFilter
{
public:
	ns1__ClassificationSystemRef *system;	/* required element of type ns1:ClassificationSystemRef */
	std::string uri;	/* required element of type xsd:anyURI */
	std::string *index;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__ClassificationFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ClassificationFilter(): system(NULL), index(NULL), soap(NULL) { ns1__ClassificationFilter::soap_default(NULL); }
	virtual ~ns1__ClassificationFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns1__XPathExpression
#define SOAP_TYPE_ns1__XPathExpression (29)
/* ns1:XPathExpression */
class SOAP_CMAC ns1__XPathExpression
{
public:
	std::vector<xsd__QName >namespaceContexts;	/* optional element of type xsd:QName */
	std::string value;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__XPathExpression */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__XPathExpression(): soap(NULL) { ns1__XPathExpression::soap_default(NULL); }
	virtual ~ns1__XPathExpression() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Account
#define SOAP_TYPE_ns1__Account (30)
/* ns1:Account */
class SOAP_CMAC ns1__Account
{
public:
	std::string uuid;	/* required element of type xsd:string */
	std::string name;	/* required element of type xsd:string */
	enum ns1__Account_USCOREType type;	/* required element of type ns1:Account_Type */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__Account */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Account(): soap(NULL) { ns1__Account::soap_default(NULL); }
	virtual ~ns1__Account() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AccountRef
#define SOAP_TYPE_ns1__AccountRef (31)
/* ns1:AccountRef */
class SOAP_CMAC ns1__AccountRef
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__AccountRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AccountRef(): soap(NULL) { ns1__AccountRef::soap_default(NULL); }
	virtual ~ns1__AccountRef() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PageRange
#define SOAP_TYPE_ns1__PageRange (32)
/* ns1:PageRange */
class SOAP_CMAC ns1__PageRange
{
public:
	int first;	/* required element of type xsd:int */
	int last;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__PageRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PageRange(): soap(NULL) { ns1__PageRange::soap_default(NULL); }
	virtual ~ns1__PageRange() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CryptoSchema
#define SOAP_TYPE_ns2__CryptoSchema (33)
/* ns2:CryptoSchema */
class SOAP_CMAC ns2__CryptoSchema
{
public:
	std::string id;	/* required element of type xsd:string */
	std::string encryptionTransformation;	/* required element of type xsd:string */
	int encryptionKeySize;	/* required element of type xsd:int */
	std::string hmacSigningAlgorithm;	/* required element of type xsd:string */
	int hmacSigningKeySize;	/* required element of type xsd:int */
	std::string digestAlgorithm;	/* required element of type xsd:string */
	std::string sessionKeyEncryptionTransformation;	/* required element of type xsd:string */
	int sessionKeyEncryptionKeySize;	/* required element of type xsd:int */
	bool useFips;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns2__CryptoSchema */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CryptoSchema(): soap(NULL) { ns2__CryptoSchema::soap_default(NULL); }
	virtual ~ns2__CryptoSchema() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CryptoSchemaRef
#define SOAP_TYPE_ns2__CryptoSchemaRef (34)
/* ns2:CryptoSchemaRef */
class SOAP_CMAC ns2__CryptoSchemaRef
{
public:
	std::string id;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns2__CryptoSchemaRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CryptoSchemaRef(): soap(NULL) { ns2__CryptoSchemaRef::soap_default(NULL); }
	virtual ~ns2__CryptoSchemaRef() { }
};
#endif

#ifndef SOAP_TYPE_ns2__KeySetExtensions
#define SOAP_TYPE_ns2__KeySetExtensions (37)
/* ns2:KeySetExtensions */
class SOAP_CMAC ns2__KeySetExtensions
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns2__KeySetExtensions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__KeySetExtensions(): soap(NULL) { ns2__KeySetExtensions::soap_default(NULL); }
	virtual ~ns2__KeySetExtensions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__KeySet
#define SOAP_TYPE_ns2__KeySet (38)
/* ns2:KeySet */
class SOAP_CMAC ns2__KeySet
{
public:
	std::string uuid;	/* required element of type xsd:string */
	ns2__CryptoSchemaRef *schema;	/* required element of type ns2:CryptoSchemaRef */
	time_t creationTime;	/* required element of type xsd:dateTime */
	ns2__KeySetExtensions *extensions;	/* optional element of type ns2:KeySetExtensions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns2__KeySet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__KeySet(): schema(NULL), extensions(NULL), soap(NULL) { ns2__KeySet::soap_default(NULL); }
	virtual ~ns2__KeySet() { }
};
#endif

#ifndef SOAP_TYPE_ns2__KeySetRef
#define SOAP_TYPE_ns2__KeySetRef (39)
/* ns2:KeySetRef */
class SOAP_CMAC ns2__KeySetRef
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns2__KeySetRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__KeySetRef(): soap(NULL) { ns2__KeySetRef::soap_default(NULL); }
	virtual ~ns2__KeySetRef() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CustomData
#define SOAP_TYPE_ns2__CustomData (40)
/* ns2:CustomData */
class SOAP_CMAC ns2__CustomData
{
public:
	std::string uuid;	/* required element of type xsd:string */
	char *__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns2__CustomData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CustomData(): __any(NULL), soap(NULL) { ns2__CustomData::soap_default(NULL); }
	virtual ~ns2__CustomData() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SchemaVersion
#define SOAP_TYPE_ns2__SchemaVersion (41)
/* ns2:SchemaVersion */
class SOAP_CMAC ns2__SchemaVersion
{
public:
	std::string version;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns2__SchemaVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SchemaVersion(): soap(NULL) { ns2__SchemaVersion::soap_default(NULL); }
	virtual ~ns2__SchemaVersion() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ContentSchema
#define SOAP_TYPE_ns2__ContentSchema (42)
/* ns2:ContentSchema */
class SOAP_CMAC ns2__ContentSchema
{
public:
	ns2__SchemaVersion *schemaVersion;	/* required element of type ns2:SchemaVersion */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns2__ContentSchema */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ContentSchema(): schemaVersion(NULL), soap(NULL) { ns2__ContentSchema::soap_default(NULL); }
	virtual ~ns2__ContentSchema() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EncryptionOptions
#define SOAP_TYPE_ns2__EncryptionOptions (43)
/* ns2:EncryptionOptions */
class SOAP_CMAC ns2__EncryptionOptions
{
public:
	int publicHeaderPeriod;	/* required element of type xsd:int */
	int encryptedContentBlockSize;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns2__EncryptionOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EncryptionOptions(): soap(NULL) { ns2__EncryptionOptions::soap_default(NULL); }
	virtual ~ns2__EncryptionOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SealingOptions
#define SOAP_TYPE_ns2__SealingOptions (44)
/* ns2:SealingOptions */
class SOAP_CMAC ns2__SealingOptions
{
public:
	ns1__Classification *classification;	/* required element of type ns1:Classification */
	std::vector<ns2__CustomData * >customData;	/* optional element of type ns2:CustomData */
	ns2__ContentSchema *contentSchema;	/* optional element of type ns2:ContentSchema */
	time_t *creationTime;	/* optional element of type xsd:dateTime */
	ns2__EncryptionOptions *encryptionOptions;	/* optional element of type ns2:EncryptionOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns2__SealingOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SealingOptions(): classification(NULL), contentSchema(NULL), creationTime(NULL), encryptionOptions(NULL), soap(NULL) { ns2__SealingOptions::soap_default(NULL); }
	virtual ~ns2__SealingOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ContentDescription
#define SOAP_TYPE_ns2__ContentDescription (45)
/* ns2:ContentDescription */
class SOAP_CMAC ns2__ContentDescription
{
public:
	ns2__ContentSchema *schema;	/* required element of type ns2:ContentSchema */
	ns1__Classification *classification;	/* required element of type ns1:Classification */
	std::vector<ns2__CustomData * >customData;	/* optional element of type ns2:CustomData */
	time_t creationTime;	/* required element of type xsd:dateTime */
	time_t editTime;	/* required element of type xsd:dateTime */
	std::string sealedMime;	/* required element of type xsd:string */
	LONG64 unsealedSize;	/* required element of type xsd:long */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns2__ContentDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ContentDescription(): schema(NULL), classification(NULL), soap(NULL) { ns2__ContentDescription::soap_default(NULL); }
	virtual ~ns2__ContentDescription() { }
};
#endif

#ifndef SOAP_TYPE_ns2__UnsupportedContentTypeFault
#define SOAP_TYPE_ns2__UnsupportedContentTypeFault (46)
/* ns2:UnsupportedContentTypeFault */
class SOAP_CMAC ns2__UnsupportedContentTypeFault
{
public:
	std::string value;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns2__UnsupportedContentTypeFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__UnsupportedContentTypeFault(): soap(NULL) { ns2__UnsupportedContentTypeFault::soap_default(NULL); }
	virtual ~ns2__UnsupportedContentTypeFault() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault
#define SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault (47)
/* ns2:IllegalEncryptedContentBlockSizeFault */
class SOAP_CMAC ns2__IllegalEncryptedContentBlockSizeFault
{
public:
	int blockSize;	/* required element of type xsd:int */
	int encryptedContentBlockSize;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns2__IllegalEncryptedContentBlockSizeFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IllegalEncryptedContentBlockSizeFault(): soap(NULL) { ns2__IllegalEncryptedContentBlockSizeFault::soap_default(NULL); }
	virtual ~ns2__IllegalEncryptedContentBlockSizeFault() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PublicHeaderLengthFault
#define SOAP_TYPE_ns2__PublicHeaderLengthFault (48)
/* ns2:PublicHeaderLengthFault */
class SOAP_CMAC ns2__PublicHeaderLengthFault
{
public:
	int length;	/* required element of type xsd:int */
	int maximum;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns2__PublicHeaderLengthFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PublicHeaderLengthFault(): soap(NULL) { ns2__PublicHeaderLengthFault::soap_default(NULL); }
	virtual ~ns2__PublicHeaderLengthFault() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ContentParseFault
#define SOAP_TYPE_ns2__ContentParseFault (49)
/* ns2:ContentParseFault */
class SOAP_CMAC ns2__ContentParseFault
{
public:
	enum ns2__ContentParseFault_USCOREReason reason;	/* required element of type ns2:ContentParseFault_Reason */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns2__ContentParseFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ContentParseFault(): soap(NULL) { ns2__ContentParseFault::soap_default(NULL); }
	virtual ~ns2__ContentParseFault() { }
};
#endif

#ifndef SOAP_TYPE_ns3__AuthorizationDeniedFault
#define SOAP_TYPE_ns3__AuthorizationDeniedFault (50)
/* ns3:AuthorizationDeniedFault */
class SOAP_CMAC ns3__AuthorizationDeniedFault
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns3__AuthorizationDeniedFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__AuthorizationDeniedFault(): soap(NULL) { ns3__AuthorizationDeniedFault::soap_default(NULL); }
	virtual ~ns3__AuthorizationDeniedFault() { }
};
#endif

#ifndef SOAP_TYPE__ns4__Seal
#define SOAP_TYPE__ns4__Seal (51)
/* ns4:Seal */
class SOAP_CMAC _ns4__Seal
{
public:
	xsd__base64Binary stream;	/* required element of type xsd:base64Binary */
	std::string mimeType;	/* required element of type xsd:string */
	ns2__SealingOptions *options;	/* required element of type ns2:SealingOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE__ns4__Seal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__Seal(): options(NULL), soap(NULL) { _ns4__Seal::soap_default(NULL); }
	virtual ~_ns4__Seal() { }
};
#endif

#ifndef SOAP_TYPE__ns4__SealResponse
#define SOAP_TYPE__ns4__SealResponse (52)
/* ns4:SealResponse */
class SOAP_CMAC _ns4__SealResponse
{
public:
	xsd__base64Binary return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE__ns4__SealResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__SealResponse(): soap(NULL) { _ns4__SealResponse::soap_default(NULL); }
	virtual ~_ns4__SealResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__Unseal
#define SOAP_TYPE__ns4__Unseal (53)
/* ns4:Unseal */
class SOAP_CMAC _ns4__Unseal
{
public:
	xsd__base64Binary input;	/* required element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE__ns4__Unseal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__Unseal(): soap(NULL) { _ns4__Unseal::soap_default(NULL); }
	virtual ~_ns4__Unseal() { }
};
#endif

#ifndef SOAP_TYPE__ns4__UnsealResponse
#define SOAP_TYPE__ns4__UnsealResponse (54)
/* ns4:UnsealResponse */
class SOAP_CMAC _ns4__UnsealResponse
{
public:
	xsd__base64Binary return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE__ns4__UnsealResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__UnsealResponse(): soap(NULL) { _ns4__UnsealResponse::soap_default(NULL); }
	virtual ~_ns4__UnsealResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__Reseal
#define SOAP_TYPE__ns4__Reseal (55)
/* ns4:Reseal */
class SOAP_CMAC _ns4__Reseal
{
public:
	xsd__base64Binary input;	/* required element of type xsd:base64Binary */
	std::vector<ns2__CustomData * >customData;	/* optional element of type ns2:CustomData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE__ns4__Reseal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__Reseal(): soap(NULL) { _ns4__Reseal::soap_default(NULL); }
	virtual ~_ns4__Reseal() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ResealResponse
#define SOAP_TYPE__ns4__ResealResponse (56)
/* ns4:ResealResponse */
class SOAP_CMAC _ns4__ResealResponse
{
public:
	xsd__base64Binary return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE__ns4__ResealResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ResealResponse(): soap(NULL) { _ns4__ResealResponse::soap_default(NULL); }
	virtual ~_ns4__ResealResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__Reclassify
#define SOAP_TYPE__ns4__Reclassify (57)
/* ns4:Reclassify */
class SOAP_CMAC _ns4__Reclassify
{
public:
	xsd__base64Binary input;	/* required element of type xsd:base64Binary */
	ns1__Classification *classification;	/* required element of type ns1:Classification */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE__ns4__Reclassify */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__Reclassify(): classification(NULL), soap(NULL) { _ns4__Reclassify::soap_default(NULL); }
	virtual ~_ns4__Reclassify() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ReclassifyResponse
#define SOAP_TYPE__ns4__ReclassifyResponse (58)
/* ns4:ReclassifyResponse */
class SOAP_CMAC _ns4__ReclassifyResponse
{
public:
	xsd__base64Binary return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE__ns4__ReclassifyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ReclassifyResponse(): soap(NULL) { _ns4__ReclassifyResponse::soap_default(NULL); }
	virtual ~_ns4__ReclassifyResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__Peek
#define SOAP_TYPE__ns4__Peek (59)
/* ns4:Peek */
class SOAP_CMAC _ns4__Peek
{
public:
	xsd__base64Binary input;	/* required element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__ns4__Peek */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__Peek(): soap(NULL) { _ns4__Peek::soap_default(NULL); }
	virtual ~_ns4__Peek() { }
};
#endif

#ifndef SOAP_TYPE__ns4__PeekResponse
#define SOAP_TYPE__ns4__PeekResponse (60)
/* ns4:PeekResponse */
class SOAP_CMAC _ns4__PeekResponse
{
public:
	ns2__ContentDescription *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:ContentDescription */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__ns4__PeekResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__PeekResponse(): return_(NULL), soap(NULL) { _ns4__PeekResponse::soap_default(NULL); }
	virtual ~_ns4__PeekResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ValidatedPeek
#define SOAP_TYPE__ns4__ValidatedPeek (61)
/* ns4:ValidatedPeek */
class SOAP_CMAC _ns4__ValidatedPeek
{
public:
	xsd__base64Binary input;	/* required element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__ns4__ValidatedPeek */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ValidatedPeek(): soap(NULL) { _ns4__ValidatedPeek::soap_default(NULL); }
	virtual ~_ns4__ValidatedPeek() { }
};
#endif

#ifndef SOAP_TYPE__ns4__ValidatedPeekResponse
#define SOAP_TYPE__ns4__ValidatedPeekResponse (62)
/* ns4:ValidatedPeekResponse */
class SOAP_CMAC _ns4__ValidatedPeekResponse
{
public:
	ns2__ContentDescription *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:ContentDescription */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__ns4__ValidatedPeekResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns4__ValidatedPeekResponse(): return_(NULL), soap(NULL) { _ns4__ValidatedPeekResponse::soap_default(NULL); }
	virtual ~_ns4__ValidatedPeekResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ItemCode
#define SOAP_TYPE_ns5__ItemCode (63)
/* ns5:ItemCode */
class SOAP_CMAC ns5__ItemCode
{
public:
	std::string value;	/* required element of type xsd:string */
	time_t *time;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ns5__ItemCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ItemCode(): time(NULL), soap(NULL) { ns5__ItemCode::soap_default(NULL); }
	virtual ~ns5__ItemCode() { }
};
#endif

#ifndef SOAP_TYPE_ns5__Context
#define SOAP_TYPE_ns5__Context (64)
/* ns5:Context */
class SOAP_CMAC ns5__Context
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns5__Context */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__Context(): soap(NULL) { ns5__Context::soap_default(NULL); }
	virtual ~ns5__Context() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ContextRef
#define SOAP_TYPE_ns5__ContextRef (65)
/* ns5:ContextRef */
class SOAP_CMAC ns5__ContextRef
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns5__ContextRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ContextRef(): soap(NULL) { ns5__ContextRef::soap_default(NULL); }
	virtual ~ns5__ContextRef() { }
};
#endif

#ifndef SOAP_TYPE_ns5__ItemConstraints
#define SOAP_TYPE_ns5__ItemConstraints (66)
/* ns5:ItemConstraints */
class SOAP_CMAC ns5__ItemConstraints
{
public:
	std::vector<ns5__ItemCode * >itemCodes;	/* optional element of type ns5:ItemCode */
	enum ns5__ItemConstraints_USCOREType type;	/* required element of type ns5:ItemConstraints_Type */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns5__ItemConstraints */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__ItemConstraints(): soap(NULL) { ns5__ItemConstraints::soap_default(NULL); }
	virtual ~ns5__ItemConstraints() { }
};
#endif

#ifndef SOAP_TYPE_ns5__UnknownContextFault
#define SOAP_TYPE_ns5__UnknownContextFault (67)
/* ns5:UnknownContextFault */
class SOAP_CMAC ns5__UnknownContextFault
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ns5__UnknownContextFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__UnknownContextFault(): soap(NULL) { ns5__UnknownContextFault::soap_default(NULL); }
	virtual ~ns5__UnknownContextFault() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ContextTemplate
#define SOAP_TYPE_ns6__ContextTemplate (70)
/* ns6:ContextTemplate */
class SOAP_CMAC ns6__ContextTemplate
{
public:
	std::string uuid;	/* required element of type xsd:string */
	std::vector<ns1__Label * >labels;	/* optional element of type ns1:Label */
	enum ns6__ContextTemplate_USCOREStatus status;	/* required element of type ns6:ContextTemplate_Status */
	std::vector<class ns6__DocumentRoleRef * >roles;	/* optional element of type ns6:DocumentRoleRef */
	class ns6__DomainRef *domain;	/* optional element of type ns6:DomainRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns6__ContextTemplate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ContextTemplate(): domain(NULL), soap(NULL) { ns6__ContextTemplate::soap_default(NULL); }
	virtual ~ns6__ContextTemplate() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ContextTemplateRef
#define SOAP_TYPE_ns6__ContextTemplateRef (71)
/* ns6:ContextTemplateRef */
class SOAP_CMAC ns6__ContextTemplateRef
{
public:
	std::string uuid;	/* required element of type xsd:string */
	ns6__DomainRef *domain;	/* required element of type ns6:DomainRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns6__ContextTemplateRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ContextTemplateRef(): domain(NULL), soap(NULL) { ns6__ContextTemplateRef::soap_default(NULL); }
	virtual ~ns6__ContextTemplateRef() { }
};
#endif

#ifndef SOAP_TYPE_ns6__DocumentRole
#define SOAP_TYPE_ns6__DocumentRole (72)
/* ns6:DocumentRole */
class SOAP_CMAC ns6__DocumentRole
{
public:
	std::string uuid;	/* required element of type xsd:string */
	std::vector<ns1__Label * >labels;	/* optional element of type ns1:Label */
	enum ns1__LicenseCriteria_USCOREStorage storage;	/* required element of type ns1:LicenseCriteria_Storage */
	std::vector<ns1__Feature * >features;	/* optional element of type ns1:Feature */
	std::vector<ns1__TimeSpan * >timeSpans;	/* optional element of type ns1:TimeSpan */
	ns1__TimePeriod *refreshPeriod;	/* optional element of type ns1:TimePeriod */
	enum ns5__ItemConstraints_USCOREType itemConstraints;	/* required element of type ns5:ItemConstraints_Type */
	enum ns6__DocumentRole_USCOREExportConstraints exportConstraints;	/* required element of type ns6:DocumentRole_ExportConstraints */
	ns6__DomainRef *domain;	/* optional element of type ns6:DomainRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns6__DocumentRole */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__DocumentRole(): refreshPeriod(NULL), domain(NULL), soap(NULL) { ns6__DocumentRole::soap_default(NULL); }
	virtual ~ns6__DocumentRole() { }
};
#endif

#ifndef SOAP_TYPE_ns6__DocumentRoleRef
#define SOAP_TYPE_ns6__DocumentRoleRef (73)
/* ns6:DocumentRoleRef */
class SOAP_CMAC ns6__DocumentRoleRef
{
public:
	std::string uuid;	/* required element of type xsd:string */
	ns6__DomainRef *domain;	/* required element of type ns6:DomainRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ns6__DocumentRoleRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__DocumentRoleRef(): domain(NULL), soap(NULL) { ns6__DocumentRoleRef::soap_default(NULL); }
	virtual ~ns6__DocumentRoleRef() { }
};
#endif

#ifndef SOAP_TYPE_ns6__Domain
#define SOAP_TYPE_ns6__Domain (74)
/* ns6:Domain */
class SOAP_CMAC ns6__Domain
{
public:
	std::string uuid;	/* required element of type xsd:string */
	std::vector<ns1__Label * >labels;	/* optional element of type ns1:Label */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns6__Domain */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__Domain(): soap(NULL) { ns6__Domain::soap_default(NULL); }
	virtual ~ns6__Domain() { }
};
#endif

#ifndef SOAP_TYPE_ns6__DomainRef
#define SOAP_TYPE_ns6__DomainRef (75)
/* ns6:DomainRef */
class SOAP_CMAC ns6__DomainRef
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ns6__DomainRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__DomainRef(): soap(NULL) { ns6__DomainRef::soap_default(NULL); }
	virtual ~ns6__DomainRef() { }
};
#endif

#ifndef SOAP_TYPE_ns6__DocumentRight
#define SOAP_TYPE_ns6__DocumentRight (76)
/* ns6:DocumentRight */
class SOAP_CMAC ns6__DocumentRight
{
public:
	std::string uuid;	/* required element of type xsd:string */
	ns1__AccountRef *account;	/* required element of type ns1:AccountRef */
	ns6__DocumentRole *role;	/* required element of type ns6:DocumentRole */
	time_t assignedTime;	/* required element of type xsd:dateTime */
	std::vector<ns5__ItemCode * >itemCodes;	/* optional element of type ns5:ItemCode */
	class ns6__ContextInstanceRef *context;	/* required element of type ns6:ContextInstanceRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ns6__DocumentRight */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__DocumentRight(): account(NULL), role(NULL), context(NULL), soap(NULL) { ns6__DocumentRight::soap_default(NULL); }
	virtual ~ns6__DocumentRight() { }
};
#endif

#ifndef SOAP_TYPE_ns6__DocumentRightRef
#define SOAP_TYPE_ns6__DocumentRightRef (77)
/* ns6:DocumentRightRef */
class SOAP_CMAC ns6__DocumentRightRef
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ns6__DocumentRightRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__DocumentRightRef(): soap(NULL) { ns6__DocumentRightRef::soap_default(NULL); }
	virtual ~ns6__DocumentRightRef() { }
};
#endif

#ifndef SOAP_TYPE_ns6__AccountAlreadyAssignedFault
#define SOAP_TYPE_ns6__AccountAlreadyAssignedFault (78)
/* ns6:AccountAlreadyAssignedFault */
class SOAP_CMAC ns6__AccountAlreadyAssignedFault
{
public:
	ns1__AccountRef *account;	/* required element of type ns1:AccountRef */
	ns6__DocumentRoleRef *role;	/* required element of type ns6:DocumentRoleRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns6__AccountAlreadyAssignedFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__AccountAlreadyAssignedFault(): account(NULL), role(NULL), soap(NULL) { ns6__AccountAlreadyAssignedFault::soap_default(NULL); }
	virtual ~ns6__AccountAlreadyAssignedFault() { }
};
#endif

#ifndef SOAP_TYPE_ns6__UnsupportedDocumentRoleFault
#define SOAP_TYPE_ns6__UnsupportedDocumentRoleFault (79)
/* ns6:UnsupportedDocumentRoleFault */
class SOAP_CMAC ns6__UnsupportedDocumentRoleFault
{
public:
	ns6__DocumentRoleRef *role;	/* required element of type ns6:DocumentRoleRef */
	ns6__ContextInstanceRef *context;	/* required element of type ns6:ContextInstanceRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns6__UnsupportedDocumentRoleFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__UnsupportedDocumentRoleFault(): role(NULL), context(NULL), soap(NULL) { ns6__UnsupportedDocumentRoleFault::soap_default(NULL); }
	virtual ~ns6__UnsupportedDocumentRoleFault() { }
};
#endif

#ifndef SOAP_TYPE_ns6__UnknownDocumentRoleFault
#define SOAP_TYPE_ns6__UnknownDocumentRoleFault (80)
/* ns6:UnknownDocumentRoleFault */
class SOAP_CMAC ns6__UnknownDocumentRoleFault
{
public:
	std::string uuid;	/* required element of type xsd:string */
	ns6__DomainRef *domain;	/* required element of type ns6:DomainRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ns6__UnknownDocumentRoleFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__UnknownDocumentRoleFault(): domain(NULL), soap(NULL) { ns6__UnknownDocumentRoleFault::soap_default(NULL); }
	virtual ~ns6__UnknownDocumentRoleFault() { }
};
#endif

#ifndef SOAP_TYPE_ns6__UnknownDocumentRightFault
#define SOAP_TYPE_ns6__UnknownDocumentRightFault (81)
/* ns6:UnknownDocumentRightFault */
class SOAP_CMAC ns6__UnknownDocumentRightFault
{
public:
	std::string uuid;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns6__UnknownDocumentRightFault */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__UnknownDocumentRightFault(): soap(NULL) { ns6__UnknownDocumentRightFault::soap_default(NULL); }
	virtual ~ns6__UnknownDocumentRightFault() { }
};
#endif

#ifndef SOAP_TYPE__ns7__AssignRole
#define SOAP_TYPE__ns7__AssignRole (82)
/* ns7:AssignRole */
class SOAP_CMAC _ns7__AssignRole
{
public:
	ns6__ContextInstanceRef *context;	/* required element of type ns6:ContextInstanceRef */
	ns6__DocumentRoleRef *role;	/* required element of type ns6:DocumentRoleRef */
	std::vector<ns1__AccountRef * >accounts;	/* optional element of type ns1:AccountRef */
	std::vector<ns5__ItemCode * >items;	/* optional element of type ns5:ItemCode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE__ns7__AssignRole */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__AssignRole(): context(NULL), role(NULL), soap(NULL) { _ns7__AssignRole::soap_default(NULL); }
	virtual ~_ns7__AssignRole() { }
};
#endif

#ifndef SOAP_TYPE__ns7__AssignRoleResponse
#define SOAP_TYPE__ns7__AssignRoleResponse (83)
/* ns7:AssignRoleResponse */
class SOAP_CMAC _ns7__AssignRoleResponse
{
public:
	std::vector<ns6__DocumentRight * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:DocumentRight */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE__ns7__AssignRoleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__AssignRoleResponse(): soap(NULL) { _ns7__AssignRoleResponse::soap_default(NULL); }
	virtual ~_ns7__AssignRoleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns7__ReassignRole
#define SOAP_TYPE__ns7__ReassignRole (84)
/* ns7:ReassignRole */
class SOAP_CMAC _ns7__ReassignRole
{
public:
	std::vector<ns6__DocumentRightRef * >rights;	/* optional element of type ns6:DocumentRightRef */
	ns6__DocumentRoleRef *role;	/* required element of type ns6:DocumentRoleRef */
	std::vector<ns5__ItemCode * >items;	/* optional element of type ns5:ItemCode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE__ns7__ReassignRole */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__ReassignRole(): role(NULL), soap(NULL) { _ns7__ReassignRole::soap_default(NULL); }
	virtual ~_ns7__ReassignRole() { }
};
#endif

#ifndef SOAP_TYPE__ns7__ReassignRoleResponse
#define SOAP_TYPE__ns7__ReassignRoleResponse (85)
/* ns7:ReassignRoleResponse */
class SOAP_CMAC _ns7__ReassignRoleResponse
{
public:
	std::vector<ns6__DocumentRight * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:DocumentRight */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE__ns7__ReassignRoleResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__ReassignRoleResponse(): soap(NULL) { _ns7__ReassignRoleResponse::soap_default(NULL); }
	virtual ~_ns7__ReassignRoleResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns7__CheckInRightsForAccount
#define SOAP_TYPE__ns7__CheckInRightsForAccount (86)
/* ns7:CheckInRightsForAccount */
class SOAP_CMAC _ns7__CheckInRightsForAccount
{
public:
	ns1__AccountRef *account;	/* required element of type ns1:AccountRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE__ns7__CheckInRightsForAccount */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__CheckInRightsForAccount(): account(NULL), soap(NULL) { _ns7__CheckInRightsForAccount::soap_default(NULL); }
	virtual ~_ns7__CheckInRightsForAccount() { }
};
#endif

#ifndef SOAP_TYPE__ns7__CheckInRightsForAccountResponse
#define SOAP_TYPE__ns7__CheckInRightsForAccountResponse (87)
/* ns7:CheckInRightsForAccountResponse */
class SOAP_CMAC _ns7__CheckInRightsForAccountResponse
{
public:
	std::vector<ns6__DocumentRight * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:DocumentRight */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE__ns7__CheckInRightsForAccountResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__CheckInRightsForAccountResponse(): soap(NULL) { _ns7__CheckInRightsForAccountResponse::soap_default(NULL); }
	virtual ~_ns7__CheckInRightsForAccountResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns7__SaveChangesToItems
#define SOAP_TYPE__ns7__SaveChangesToItems (88)
/* ns7:SaveChangesToItems */
class SOAP_CMAC _ns7__SaveChangesToItems
{
public:
	std::vector<ns6__DocumentRightRef * >rights;	/* optional element of type ns6:DocumentRightRef */
	std::vector<ns5__ItemCode * >itemCodes;	/* optional element of type ns5:ItemCode */
	std::vector<ns5__ItemCode * >delta;	/* optional element of type ns5:ItemCode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE__ns7__SaveChangesToItems */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__SaveChangesToItems(): soap(NULL) { _ns7__SaveChangesToItems::soap_default(NULL); }
	virtual ~_ns7__SaveChangesToItems() { }
};
#endif

#ifndef SOAP_TYPE__ns7__SaveChangesToItemsResponse
#define SOAP_TYPE__ns7__SaveChangesToItemsResponse (89)
/* ns7:SaveChangesToItemsResponse */
class SOAP_CMAC _ns7__SaveChangesToItemsResponse
{
public:
	std::vector<ns6__DocumentRight * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:DocumentRight */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE__ns7__SaveChangesToItemsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__SaveChangesToItemsResponse(): soap(NULL) { _ns7__SaveChangesToItemsResponse::soap_default(NULL); }
	virtual ~_ns7__SaveChangesToItemsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns7__UnassignRights
#define SOAP_TYPE__ns7__UnassignRights (90)
/* ns7:UnassignRights */
class SOAP_CMAC _ns7__UnassignRights
{
public:
	std::vector<ns6__DocumentRightRef * >rights;	/* optional element of type ns6:DocumentRightRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE__ns7__UnassignRights */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__UnassignRights(): soap(NULL) { _ns7__UnassignRights::soap_default(NULL); }
	virtual ~_ns7__UnassignRights() { }
};
#endif

#ifndef SOAP_TYPE__ns7__UnassignRightsResponse
#define SOAP_TYPE__ns7__UnassignRightsResponse (91)
/* ns7:UnassignRightsResponse */
class SOAP_CMAC _ns7__UnassignRightsResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE__ns7__UnassignRightsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__UnassignRightsResponse(): soap(NULL) { _ns7__UnassignRightsResponse::soap_default(NULL); }
	virtual ~_ns7__UnassignRightsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns7__ListRightsByContext
#define SOAP_TYPE__ns7__ListRightsByContext (92)
/* ns7:ListRightsByContext */
class SOAP_CMAC _ns7__ListRightsByContext
{
public:
	ns6__ContextInstanceRef *context;	/* required element of type ns6:ContextInstanceRef */
	ns1__PageRange *pageRange;	/* required element of type ns1:PageRange */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE__ns7__ListRightsByContext */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__ListRightsByContext(): context(NULL), pageRange(NULL), soap(NULL) { _ns7__ListRightsByContext::soap_default(NULL); }
	virtual ~_ns7__ListRightsByContext() { }
};
#endif

#ifndef SOAP_TYPE__ns7__ListRightsByContextResponse
#define SOAP_TYPE__ns7__ListRightsByContextResponse (93)
/* ns7:ListRightsByContextResponse */
class SOAP_CMAC _ns7__ListRightsByContextResponse
{
public:
	std::vector<ns6__DocumentRight * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:DocumentRight */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE__ns7__ListRightsByContextResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__ListRightsByContextResponse(): soap(NULL) { _ns7__ListRightsByContextResponse::soap_default(NULL); }
	virtual ~_ns7__ListRightsByContextResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns7__ListRightsByAccount
#define SOAP_TYPE__ns7__ListRightsByAccount (94)
/* ns7:ListRightsByAccount */
class SOAP_CMAC _ns7__ListRightsByAccount
{
public:
	ns1__AccountRef *account;	/* required element of type ns1:AccountRef */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE__ns7__ListRightsByAccount */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__ListRightsByAccount(): account(NULL), soap(NULL) { _ns7__ListRightsByAccount::soap_default(NULL); }
	virtual ~_ns7__ListRightsByAccount() { }
};
#endif

#ifndef SOAP_TYPE__ns7__ListRightsByAccountResponse
#define SOAP_TYPE__ns7__ListRightsByAccountResponse (95)
/* ns7:ListRightsByAccountResponse */
class SOAP_CMAC _ns7__ListRightsByAccountResponse
{
public:
	std::vector<ns6__DocumentRight * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns6:DocumentRight */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE__ns7__ListRightsByAccountResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns7__ListRightsByAccountResponse(): soap(NULL) { _ns7__ListRightsByAccountResponse::soap_default(NULL); }
	virtual ~_ns7__ListRightsByAccountResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DesktopKeySetExtensions
#define SOAP_TYPE_ns1__DesktopKeySetExtensions (18)
/* ns1:DesktopKeySetExtensions */
class SOAP_CMAC ns1__DesktopKeySetExtensions : public ns2__KeySetExtensions
{
public:
	std::string identityToken;	/* required element of type xsd:string */
	xsd__base64Binary encryptedContentKey;	/* required element of type xsd:base64Binary */
	xsd__base64Binary encryptedSigningKey;	/* required element of type xsd:base64Binary */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__DesktopKeySetExtensions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DesktopKeySetExtensions() { ns1__DesktopKeySetExtensions::soap_default(NULL); }
	virtual ~ns1__DesktopKeySetExtensions() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RelativeTimeSpan
#define SOAP_TYPE_ns1__RelativeTimeSpan (26)
/* ns1:RelativeTimeSpan */
class SOAP_CMAC ns1__RelativeTimeSpan : public ns1__TimeSpan
{
public:
	enum ns1__RelativeTimeSpan_USCORETimeBase timeBase;	/* required element of type ns1:RelativeTimeSpan_TimeBase */
	ns1__TimePeriod *startTime;	/* optional element of type ns1:TimePeriod */
	ns1__TimePeriod *stopTime;	/* optional element of type ns1:TimePeriod */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__RelativeTimeSpan */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RelativeTimeSpan(): startTime(NULL), stopTime(NULL) { ns1__RelativeTimeSpan::soap_default(NULL); }
	virtual ~ns1__RelativeTimeSpan() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AbsoluteTimeSpan
#define SOAP_TYPE_ns1__AbsoluteTimeSpan (27)
/* ns1:AbsoluteTimeSpan */
class SOAP_CMAC ns1__AbsoluteTimeSpan : public ns1__TimeSpan
{
public:
	time_t *startTime;	/* optional element of type xsd:dateTime */
	time_t *stopTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__AbsoluteTimeSpan */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AbsoluteTimeSpan(): startTime(NULL), stopTime(NULL) { ns1__AbsoluteTimeSpan::soap_default(NULL); }
	virtual ~ns1__AbsoluteTimeSpan() { }
};
#endif

#ifndef SOAP_TYPE_ns1__XPathClassificationFilter
#define SOAP_TYPE_ns1__XPathClassificationFilter (28)
/* ns1:XPathClassificationFilter */
class SOAP_CMAC ns1__XPathClassificationFilter : public ns1__ClassificationFilter
{
public:
	ns1__XPathExpression *expression;	/* required element of type ns1:XPathExpression */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__XPathClassificationFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__XPathClassificationFilter(): expression(NULL) { ns1__XPathClassificationFilter::soap_default(NULL); }
	virtual ~ns1__XPathClassificationFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RawKeySetExtensions
#define SOAP_TYPE_ns2__RawKeySetExtensions (35)
/* ns2:RawKeySetExtensions */
class SOAP_CMAC ns2__RawKeySetExtensions : public ns2__KeySetExtensions
{
public:
	xsd__base64Binary encryptionKey;	/* required element of type xsd:base64Binary */
	xsd__base64Binary signingKey;	/* required element of type xsd:base64Binary */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns2__RawKeySetExtensions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RawKeySetExtensions() { ns2__RawKeySetExtensions::soap_default(NULL); }
	virtual ~ns2__RawKeySetExtensions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WrappedKeySetExtensions
#define SOAP_TYPE_ns2__WrappedKeySetExtensions (36)
/* ns2:WrappedKeySetExtensions */
class SOAP_CMAC ns2__WrappedKeySetExtensions : public ns2__KeySetExtensions
{
public:
	std::string alias;	/* required element of type xsd:string */
	xsd__base64Binary encryptionKey;	/* required element of type xsd:base64Binary */
	xsd__base64Binary signingKey;	/* required element of type xsd:base64Binary */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns2__WrappedKeySetExtensions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WrappedKeySetExtensions() { ns2__WrappedKeySetExtensions::soap_default(NULL); }
	virtual ~ns2__WrappedKeySetExtensions() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ContextInstance
#define SOAP_TYPE_ns6__ContextInstance (68)
/* ns6:ContextInstance */
class SOAP_CMAC ns6__ContextInstance : public ns5__Context
{
public:
	std::vector<ns1__Label * >labels;	/* optional element of type ns1:Label */
	std::vector<ns5__ItemCode * >items;	/* optional element of type ns5:ItemCode */
	std::vector<ns6__ContextInstanceRef * >trustedContexts;	/* optional element of type ns6:ContextInstanceRef */
	enum ns6__ContextInstance_USCOREVisibility visibility;	/* required element of type ns6:ContextInstance_Visibility */
	ns6__ContextTemplateRef *template_;	/* required element of type ns6:ContextTemplateRef */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns6__ContextInstance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ContextInstance(): template_(NULL) { ns6__ContextInstance::soap_default(NULL); }
	virtual ~ns6__ContextInstance() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ContextInstanceRef
#define SOAP_TYPE_ns6__ContextInstanceRef (69)
/* ns6:ContextInstanceRef */
class SOAP_CMAC ns6__ContextInstanceRef : public ns5__ContextRef
{
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ns6__ContextInstanceRef */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ContextInstanceRef() { ns6__ContextInstanceRef::soap_default(NULL); }
	virtual ~ns6__ContextInstanceRef() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (156)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	ns3__AuthorizationDeniedFault *ns4__AuthorizationDeniedFault;	/* optional element of type ns3:AuthorizationDeniedFault */
	ns2__ContentParseFault *ns4__ContentParseFault;	/* optional element of type ns2:ContentParseFault */
	ns2__IllegalEncryptedContentBlockSizeFault *ns4__IllegalEncryptedContentBlockSizeFault;	/* optional element of type ns2:IllegalEncryptedContentBlockSizeFault */
	ns2__PublicHeaderLengthFault *ns4__PublicHeaderLengthFault;	/* optional element of type ns2:PublicHeaderLengthFault */
	ns2__UnsupportedContentTypeFault *ns4__UnsupportedContentTypeFault;	/* optional element of type ns2:UnsupportedContentTypeFault */
	ns6__AccountAlreadyAssignedFault *ns7__AccountAlreadyAssignedFault;	/* optional element of type ns6:AccountAlreadyAssignedFault */
	ns3__AuthorizationDeniedFault *ns7__AuthorizationDeniedFault;	/* optional element of type ns3:AuthorizationDeniedFault */
	ns5__UnknownContextFault *ns7__UnknownContextFault;	/* optional element of type ns5:UnknownContextFault */
	ns6__UnknownDocumentRightFault *ns7__UnknownDocumentRightFault;	/* optional element of type ns6:UnknownDocumentRightFault */
	ns6__UnknownDocumentRoleFault *ns7__UnknownDocumentRoleFault;	/* optional element of type ns6:UnknownDocumentRoleFault */
	ns6__UnsupportedDocumentRoleFault *ns7__UnsupportedDocumentRoleFault;	/* optional element of type ns6:UnsupportedDocumentRoleFault */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns4__Seal
#define SOAP_TYPE___ns4__Seal (172)
/* Operation wrapper: */
struct __ns4__Seal
{
public:
	_ns4__Seal *ns4__Seal;	/* optional element of type ns4:Seal */
};
#endif

#ifndef SOAP_TYPE___ns4__Unseal
#define SOAP_TYPE___ns4__Unseal (176)
/* Operation wrapper: */
struct __ns4__Unseal
{
public:
	_ns4__Unseal *ns4__Unseal;	/* optional element of type ns4:Unseal */
};
#endif

#ifndef SOAP_TYPE___ns4__Reseal
#define SOAP_TYPE___ns4__Reseal (180)
/* Operation wrapper: */
struct __ns4__Reseal
{
public:
	_ns4__Reseal *ns4__Reseal;	/* optional element of type ns4:Reseal */
};
#endif

#ifndef SOAP_TYPE___ns4__Reclassify
#define SOAP_TYPE___ns4__Reclassify (184)
/* Operation wrapper: */
struct __ns4__Reclassify
{
public:
	_ns4__Reclassify *ns4__Reclassify;	/* optional element of type ns4:Reclassify */
};
#endif

#ifndef SOAP_TYPE___ns4__Peek
#define SOAP_TYPE___ns4__Peek (188)
/* Operation wrapper: */
struct __ns4__Peek
{
public:
	_ns4__Peek *ns4__Peek;	/* optional element of type ns4:Peek */
};
#endif

#ifndef SOAP_TYPE___ns4__ValidatedPeek
#define SOAP_TYPE___ns4__ValidatedPeek (192)
/* Operation wrapper: */
struct __ns4__ValidatedPeek
{
public:
	_ns4__ValidatedPeek *ns4__ValidatedPeek;	/* optional element of type ns4:ValidatedPeek */
};
#endif

#ifndef SOAP_TYPE___ns7__AssignRole
#define SOAP_TYPE___ns7__AssignRole (196)
/* Operation wrapper: */
struct __ns7__AssignRole
{
public:
	_ns7__AssignRole *ns7__AssignRole;	/* optional element of type ns7:AssignRole */
};
#endif

#ifndef SOAP_TYPE___ns7__ReassignRole
#define SOAP_TYPE___ns7__ReassignRole (200)
/* Operation wrapper: */
struct __ns7__ReassignRole
{
public:
	_ns7__ReassignRole *ns7__ReassignRole;	/* optional element of type ns7:ReassignRole */
};
#endif

#ifndef SOAP_TYPE___ns7__CheckInRightsForAccount
#define SOAP_TYPE___ns7__CheckInRightsForAccount (204)
/* Operation wrapper: */
struct __ns7__CheckInRightsForAccount
{
public:
	_ns7__CheckInRightsForAccount *ns7__CheckInRightsForAccount;	/* optional element of type ns7:CheckInRightsForAccount */
};
#endif

#ifndef SOAP_TYPE___ns7__SaveChangesToItems
#define SOAP_TYPE___ns7__SaveChangesToItems (208)
/* Operation wrapper: */
struct __ns7__SaveChangesToItems
{
public:
	_ns7__SaveChangesToItems *ns7__SaveChangesToItems;	/* optional element of type ns7:SaveChangesToItems */
};
#endif

#ifndef SOAP_TYPE___ns7__UnassignRights
#define SOAP_TYPE___ns7__UnassignRights (212)
/* Operation wrapper: */
struct __ns7__UnassignRights
{
public:
	_ns7__UnassignRights *ns7__UnassignRights;	/* optional element of type ns7:UnassignRights */
};
#endif

#ifndef SOAP_TYPE___ns7__ListRightsByContext
#define SOAP_TYPE___ns7__ListRightsByContext (216)
/* Operation wrapper: */
struct __ns7__ListRightsByContext
{
public:
	_ns7__ListRightsByContext *ns7__ListRightsByContext;	/* optional element of type ns7:ListRightsByContext */
};
#endif

#ifndef SOAP_TYPE___ns7__ListRightsByAccount
#define SOAP_TYPE___ns7__ListRightsByAccount (220)
/* Operation wrapper: */
struct __ns7__ListRightsByAccount
{
public:
	_ns7__ListRightsByAccount *ns7__ListRightsByAccount;	/* optional element of type ns7:ListRightsByAccount */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (221)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (222)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (224)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (225)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (10)
typedef std::string xsd__anyURI;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
